<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 4b4ae3e9937a6520b272d4fd794cd6670d47f9e0 Maintainer: cucinato Status: ready -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Operatori</title>
  <simpara>
   Un operatore è un qualcosa che si posiziona tra uno o più valori (od espressioni,
   in gergo tecnico) e produce un'altro valore (in modo tale che la costruzione
   stessa diventi a sua volta un'espressione). i
  </simpara>
  <para>
   Gli operatori possono essere raggruppati a seconda del numero di valori che trattano. Gli
   operatori unari quali richiedono un solo valore, ad esempio <literal>!</literal>i
   (l'<link linkend="language.operators.logical">operatore logico noti</link>) oppure
   <literal>++</literal> 
   (l'<link linkend="language.operators.increment">operatore di autoincremento</link>).
   Gli operatori binari accettano due valor, come i familiari
   <link linkend="language.operators.arithmetic">operatori aritmetici</link>
   <literal>+</literal> (più) e <literal>-</literal> (meno), e la
   maggior parte degli operatori disponibili in PHP ricadono in questa categoria. Infine, esiste un
   solo <link linkend="language.operators.comparison.ternary">operatore
   ternario</link>, <literal>? :</literal>, che accetta tre valori; viene
   normalmente chiamato "l'operatore ternario" (anche se potrebbe
   forse essere chiamato più precisamente operatore condizionale).
  </para>
  <para>
   Una lista completa degli operatore è fornita nella sezione
   <link linkend="language.operators.precedence">Precedenza degli operatori</link>.
   Questa sezione spiega anche la precedenza degli operatori e l'associatività, che stabiliscono
   esattamente come le espressioni contenenti differenti operatori sono
   valutate ed eseguite.
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>Precedenza degli operatori</title>
   <para>
    La precedenza di un operatore specifica come esso tenga legate assieme "strettamente" due
    espressioni. Per esempio, nell'espressione <literal>1 +
    5 * 3</literal>, la risposta è <literal>16</literal> e non
    <literal>18</literal> perché l'operatore di moltiplicazione ("*")
    ha una precedenza più alta rispetto all'operatore di addizione ("+").
    Le parentesi possono essere usate per forzare la precedenza, se necessario. Per
    esempio: <literal>(1 + 5) * 3</literal> viene valutata
    <literal>18</literal>.
   </para>
   <para>
    Quando gli operatori hanno precedenza identica, la loro associatività decide
    se sono valutati partendo da destra o da
    sinistra - vedere gli esempi qui sotto.
   </para>
   <para>
    La seguente tabella fornisce una lista della precedenza degli operatori con gli
    operatori a più alta precedenza elencati prima. Gli operatori presenti nella medesima linea
    hanno uguale precedenza, in questi casi la loro associativià
    decide l'ordine con cui sono valutati.
    <table>
     <title>Precedenza degli operatori</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associatività</entry>
        <entry>Operatori</entry>
        <entry>Informazioni aggiuntive</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>non associativi</entry>
        <entry>clone new</entry>
        <entry><link linkend="language.oop5.cloning">clone</link> e <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>[</entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry>++ -- ~ (int) (float) (string) (array) (object) (bool) @</entry>
        <entry>
         <link linkend="language.types">types</link> and <link linkend="language.operators.increment">increment/decrement</link>
        </entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>instanceof</entry>
        <entry>
         <link linkend="language.types">tipi</link>
        </entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry>!</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>* / %</entry>
        <entry>
         <link linkend="language.operators.arithmetic">operatori aritmetici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>+ - .</entry>
        <entry>
         <link linkend="language.operators.arithmetic">operatori aritmetici</link>&listendand;
         <link linkend="language.operators.string">operatori su stringhe</link></entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
        <entry>
         <link linkend="language.operators.comparison">operatori di confronto</link>
        </entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>== != === !== &lt;&gt;</entry>
        <entry>
         <link linkend="language.operators.comparison">operatori di confronto</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>&amp;</entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>&listendand;
         <link linkend="language.references">riferimenti</link></entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>^</entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>|</entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>&amp;&amp;</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>||</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>? :</entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">Operatore ternario</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= =&gt;
        </entry>
        <entry>
         <link linkend="language.operators.assignment">operatori di assegnazione</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>and</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>xor</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>or</entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>,</entry>
        <entry>diversi usi</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    Per operatori con uguale precedenza, l'associazione a sinistra indica che
    l'espressione viene valutata da sinistra verso destra, e l'associazione destra indica
    il contrario.
    <example>
     <title>Associatività</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5

// mescolare  ++ e + produce un comportamento indefinito
$a = 1;
echo ++$a + $a++; // può stampare 4 o 5
?>
]]>
     </programlisting>
    </example>
    Utilizzare le parentesi, anche quando non è strettamente necessarion, pùò spesso aumentare
    la leggibilità del codice.
   </para>
   <note>
    <para>
     Sebbene <literal>=</literal> abbia una precedenza minore rispetto
     alla maggior parte degli altri operatori, PHP permette comunque espressioni
     simili alla seguente: <literal>if (!$a = foo())</literal>,
     in questo caso l'output di <literal>foo()</literal> viene
     inserito in <varname>$a</varname>.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Operatori aritmetici</title>
   <simpara>
    Ricordate l'aritmetica di base dalla scuola? Questi operatori funzionano esattamente
    nello stesso modo.
   </simpara>
   <table>
    <title>Operatori aritmetici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>Negazione</entry>
       <entry>Opposto di <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Addizione</entry>
       <entry>La somma di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Sottrazione</entry>
       <entry>La differenza di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Moltiplicazione</entry>
       <entry>il prodotto di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Divisione</entry>
       <entry>Quoziente di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Modulo</entry>
       <entry>Il resto di <varname>$a</varname> diviso da <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    L'operatore di divisione ("/") restituisce un valore float a meno che i due operandi
    siano interi (oppure stringhe che vengono convertite in interi) e i numeri
    siano divisibili, nel qual caso viene restituito un valore intero.
   </simpara>
   <simpara>
    Gli operandi del modulo sono convertiti a interi (rimuovendo la parte decimale)
    prima dell'operazione.
   </simpara>
   <para>
    Il risultato dell'operatore modulo <literal>%</literal> ha lo stesso segno
    del dividendo - ovvero, il risultato di <literal>$a % $b</literal>
    avrà lo stesso segno di <varname>$a</varname>. Per esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // prints 2
echo (5 % -3)."\n";          // prints 2
echo (-5 % 3)."\n";          // prints -2
echo (-5 % -3)."\n";         // prints -2

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Vedere anche le pagine del manuale sulle
    <link linkend="ref.math">funzioni matematiche</link>.
   </simpara>

  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Operatori di assegnazione</title>
   <simpara>
    L'operatore di base dell'assegnazione è "=". Il primo impulso può
    essere quello di pensare che corrisponda a "uguale a". Invece questo operatore significa che
    l'operando a sinistra assume il valore dell'espressione a
    destra (cioè, "assegna il valore a").
   </simpara>
   <para>
    Il valore di un'espressione di assegnazione è il valore assegnato. Ovvero
    il valore di "$a = 3" è 3. Questo permette di fare qualche
    trucchetto:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a è uguale a 9 ora, e $b è stato impostato a 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Per gli <type>array</type>, l'assegnazione di un valore a una chiave è ottenuto usando
    l'operatore "=&gt;". La <link linkend="language.operators.precedence">precedenza</link>
    di questo operatore è la stessa degli altri operatori d'assegnazione.
   </para>
   <para>
    In aggiunta all'operatore di base dell'assegnazione, ci sono gli "operatori
    combinati" per tutta <link linkend="language.operators">l'aritmetica binaria</link>
    e gli operatori di stringa
    che consentono di usare un valore in un'espressione e poi impostare il suo
    valore al risultato di quell'espressione. Per esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // imposta $a a 8, corrispondente a: $a = $a + 5;
$b = "Ciao ";
$b .= "come va?"; // imposta $b a "Ciao come va?", proprio come $b = $b . "come va?";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Si noti che l'assegnazione copia la variabile originale nella nuova
    (assegnazione per valore), così i cambiamenti della prima non si verificheranno nell'
    altra. Ciò può anche avere rilevanza se si ha bisogno di copiare
    un grande array in un ciclo molto stretto. 
   </para>
   <para>
    Un'eccezione al comportamento standard dell'assegnazione per valore avviene
    con gli<type>object</type>, che sono assegnati per riferimento in PHP 5.
    Gli oggetti possono essere copiati esplicitamente attraverso la keyword <link
    linkend="language.oop5.cloning">clone</link>.
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>Assegnazione per referimento</title>
    <para>
     L'assegnazione per riferimento è pure supportato, usando la sintassi
     "<computeroutput>$var = &amp;$othervar;</computeroutput>.
     'Assegnazione per riferimento' significa che entrambe le variabili finiscono con il puntare agli
     stessi dati, e nulla è copiato.
    </para>
    <para>
     <example>
      <title>Assegnare per riferimento</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b è un riferimento ad $a

print "$a\n"; // stampa 3
print "$b\n"; // stampa 3

$a = 4; // modifica $a

print "$a\n"; // stampa 4
print "$b\n"; // stampa ugualmente 4, dal momento che $b è un riferimento ad $a, che è
              // stata modificata
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Da PHP 5, l'operatore <link linkend="language.oop5.basic.new">new</link>
     restituisce automaticamente un riferimento, quindi assegnare il risultato di
     <link linkend="language.oop5.basic.new">new</link> per riferimento risulta
     in un messaggio <constant>E6DEPRECATED</constant> in PHP 5.3 e successivi, e
     un messaggio <constant>E_STRICT</constant> nelle version precedenti.
    </para>
    <para>
     Per esempio, quesco codice provocherà un avvertimento:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

/* la prossima linea genera il seguente messaggio di errore:
 * Deprecated: Assigning the return value of new by reference is deprecated in...
 */
$o = &new C;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Ulteriori informazioni sui riferimenti e sul loro uso possono essere trovati
     nella sezione del manuale <link linkend="language.references">Spiegazioni sui riferimenti</link>
     .
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Operatori sui bit</title>
   <simpara>
    Gli operatori sui bit permettono la valutazione e manipolazione di specifici
    bit in un valore intero.
   </simpara>
   <table>
    <title>Operatori sui bit</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>And</entry>
       <entry>Vengono accesi i bit che sono accesi sia in <varname>$a</varname> che in <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Or (inclusive or)</entry>
       <entry>Vengono accesi i bit che sono accesi o in <varname>$a</varname> oppure in <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Xor (exclusive or)</entry>
       <entry>
 Vengono accesi i bit che sono accesi in <varname>$a</varname> o in <varname>$b</varname>, ma non quelli accesi in entrambe le variabili.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Not</entry>
       <entry>
 Vengono accesi i bit che sono spenti in <varname>$a</varname>, e viceversa
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Shift left</entry>
       <entry>
 Sposta verso sinistra i bit di <varname>$a</varname> per <varname>$b</varname> volte (ogni passo significa
 "moltiplica per due")
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Shift right</entry>
       <entry>
 Sposta verso destra i bit di <varname>$a</varname> per <varname>$b</varname> volte (ogni passo significa
 "dividi per due")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Lo spostamento di bit in PHP è aritmetico.
    I bit spostati al di fuori delle estremità sono scartati.
    Gli spostamenti a sinistra inseriscono zeri a destra mentre il bit
    di segno è scartato sulla sinistra, quindi il segno di un operando
    non è conservato.
    Gli spostamenti a destra copiano il bit di segno sulla sinistra,
    quindi il segno di un operando è conservato.
   </para>
   <para>
    Utilizzare le parentesi per assicurare la
    <link linkend="language.operators.precedence">precedenza</link> desiderata.
    Per esempio, <literal>$a &amp; $b == true</literal> valuta
    l'equivalenza e poi l'operatore and; mentre
    <literal>($a &amp; $b) == true</literal> valuta l'operatore and e
    poi l'equivalenza.
   </para>
   <para>
    Prestare attenzione alle conversioni tra tipi di dato. Se entrambi gli operandi
    sono stringhe, l'operatore bit lavorarà
    sui valori ASCII dei caratter.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
L'opzione ini error_reporting di PHP usa valori imappati sui bit,
fornendo quindi una dimostrazione reale dello spegnimento 
dei bit. Per mostrare tutti gli errori, eccettuati gli avvisi,
le istruzioni del file php.ini dicono di usare:
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Si prende il valore di E_ALL:
<computeroutput>00000000000000000111011111111111</computeroutput>
Quindi quello di E_NOTICE...
<computeroutput>00000000000000000000000000001000</computeroutput>
... e lo si inverte con <literal>~</literal>:
<computeroutput>11111111111111111111111111110111</computeroutput>
infine, si usa AND (&amp;) pre trovare i bit che sono accesi
in entrambi i valori:
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Un altro metodo per ottenere questo risultato è usare XOR (<literal>^</literal>)
per trovare i bit che sono accesi solo in uno dei due operandi:
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting può essere usata anche per dimostrare come accendere i bit.
Il modo per mostrare solo gli errori e gli errori recuperabili è:
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Questo processo combina E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
e
<computeroutput>00000000000000000001000000000000</computeroutput>
usando l'operatore OR (<literal>|</literal>)
per recuperare i bit accesi in entrambi i valori:
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>Operazioni AND, OR e XOR su interi</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Ignorare la sezione iniziale,
 * server solo a formattare per rendere più leggibile il risultato.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 risultato     valore     op test
 ---------     ---------  -- ---------
EOH;


/*
 * Ecco gli esempi.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitwise AND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitwise Inclusive OR \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitwise Exclusive OR (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 risultato     valore     op test
 ---------     ---------  -- ---------
 Bitwise AND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitwise Inclusive OR
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitwise Exclusive OR (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>Operazioni XOR su stringhe</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Ritorna '5'

echo "12" ^ "9"; // Ritorna il carattere Backspace (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Ritorna i valori ascii #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Ritorna 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Ritorna 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Spostamento di bit su interi</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Ecco gli esempi.
 */

echo "\n--- SPOSTAMENTO A DESTRA SU INTERI POSITIVI ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copia del bit di segno inserito a sinistra');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'i bit escono dal lato destro');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'come sopra; non c'è spostamento oltre lo 0');


echo "\n--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copia del bit di segno inserito a sinistra');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'i bit escono dal lato destro');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'come sopra; non c'è spostamento oltre il -1');


echo "\n--- SPOSTAMENTO A SINISTRA SU INTERI POSITIVI ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeri inseriti a destra');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'i bit di segno sono spostati');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'i bit escono dal lato sinistro');


echo "\n--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeri inseriti a destra');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'i bit escono dal lato sinistro, incluso il bit di segno');


/*
 * Ignorare questa sezione finale,
 * server solo a formattare per rendere più leggibile il risultato.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Espressione: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Decimale:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binario:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " NOTA: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- SPOSTAMENTO A DESTRA SU INTERI POSITIVI ---
Espressione: 2 = 4 >> 1
 Decimale:
  val=4
  res=2
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTA: copia del bit di segno inserito a sinistra

Espressione: 1 = 4 >> 2
 Decimale:
  val=4
  res=1
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Espressione: 0 = 4 >> 3
 Decimale:
  val=4
  res=0
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: i bit escono dal lato destro

Espressione: 0 = 4 >> 4
 Decimale:
  val=4
  res=0
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: come sopra; non c'è spostamento oltre lo 0


--- SPOSTAMENTO A DESTRA SU INTERI NEGATIVI ---
Espressione: -2 = -4 >> 1
 Decimale:
  val=-4
  res=-2
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTA: copia del bit di segno inserito a sinistra

Espressione: -1 = -4 >> 2
 Decimale:
  val=-4
  res=-1
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTA: i bit escono dal lato destro

Espressione: -1 = -4 >> 3
 Decimale:
  val=-4
  res=-1
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTA: come sopra; non c'è spostamento oltre il -1


--- SPOSTAMENTO A SINISTRA SU INTERI POSITIVI ---
Espressione: 8 = 4 << 1
 Decimale:
  val=4
  res=8
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTA: zeri inseriti a destra

Espressione: 1073741824 = 4 << 28
 Decimale:
  val=4
  res=1073741824
 Binario:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Espressione: -2147483648 = 4 << 29
 Decimale:
  val=4
  res=-2147483648
 Binario:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTA:i bit di segno sono spostati

Espressione: 0 = 4 << 30
 Decimale:
  val=4
  res=0
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro


--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---
Espressione: -8 = -4 << 1
 Decimale:
  val=-4
  res=-8
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTA: zeri inseriti a destra

Espressione: -2147483648 = -4 << 29
 Decimale:
  val=-4
  res=-2147483648
 Binario:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Espressione: 0 = -4 << 30
 Decimale:
  val=-4
  res=0
 Binario:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro, incluso il bit di segno
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- SPOSTAMENTO A DESTRA SU INTERI POSITIVI ---
Espressione: 2 = 4 >> 1
 Decimale:
  val=4
  res=2
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTA: copia del bit di segno inserito a sinistra

Espressione: 1 = 4 >> 2
 Decimale:
  val=4
  res=1
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Espressione: 0 = 4 >> 3
 Decimale:
  val=4
  res=0
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit escono dal lato destro

Espressione: 0 = 4 >> 4
 Decimale:
  val=4
  res=0
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: come sopra; non c'è spostamento oltre lo 0


--- SPOSTAMENTO A DESTRA SU INTERI NEGATIVI ---
Espressione: -2 = -4 >> 1
 Decimale:
  val=-4
  res=-2
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTA: copia del bit di segno inserito a sinistra

Espressione: -1 = -4 >> 2
 Decimale:
  val=-4
  res=-1
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTA: i bit escono dal lato destro

Espressione: -1 = -4 >> 3
 Decimale:
  val=-4
  res=-1
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTA: come sopra; non c'è spostamento oltre il -1


--- SPOSTAMENTO A SINISTRA SU INTERI POSITIVI ---
Espressione: 8 = 4 << 1
 Decimale:
  val=4
  res=8
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTA: zeri inseriti a destra

Espressione: 4611686018427387904 = 4 << 60
 Decimale:
  val=4
  res=4611686018427387904
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Espressione: -9223372036854775808 = 4 << 61
 Decimale:
  val=4
  res=-9223372036854775808
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit di segno sono spostati

Espressione: 0 = 4 << 62
 Decimale:
  val=4
  res=0
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro


--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---
Espressione: -8 = -4 << 1
 Decimale:
  val=-4
  res=-8
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTA: zeri inseriti a destra

Espressione: -9223372036854775808 = -4 << 61
 Decimale:
  val=-4
  res=-9223372036854775808
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Espressione: 0 = -4 << 62
 Decimale:
  val=-4
  res=0
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro, incluso il bit di segno
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     Non spostare a destra per più di 32 bit sui sistemi a 32 bit. 
     Non spostare a sinistra nei casi in cui il risultato è un numero più lungo di 32 bit.
     Utilizzare le funzioni dell'estensione gmp per manipolazioni di bit su
     numeri più grandi di PHP_INT_MAX.
    </para>
   </warning>
   <para>
    vedere anche
    <function>pack</function>,
    <function>unpack</function>,
    <function>gmp_and</function>,
    <function>gmp_or</function>,
    <function>gmp_xor</function>,
    <function>gmp_testbit</function>,
    <function>gmp_clrbit</function>
   </para>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Operatori di confronto</title>
   <simpara>
    Gli operatori di confronto, come suggerisce il loro nome, permettono di confrontare
    due valori. Può essere interessante vedere la
    <link linkend="types.comparisons">tabella di raffronto dei tipi</link>,
    dato che mostra esempi di vari confronti tra i tipi di variabili.
   </simpara>
   <table>
    <title>Operatori di confronto</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Uguale</entry>
       <entry>&true; se <varname>$a</varname> è uguale a <varname>$b</varname> dopo la manipolazione dei tipi.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identico</entry>
       <entry>
        &true; se <varname>$a</varname> è uguale a <varname>$b</varname>, ed sono dello stesso
        tipo.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Diversi</entry>
       <entry>&true; se <varname>$a</varname> è diverso da <varname>$b</varname> dopo la manipolazione dei tipi.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Diversi</entry>
       <entry>&true; se <varname>$a</varname> è diverso da <varname>$b</varname> dopo la manipolazione dei tipi.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Non identici</entry>
       <entry>
        &true; se <varname>$a</varname> è diverso da <varname>$b</varname>, o se non sono dello stesso
        tipo.
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Minore</entry>
       <entry>&true; se <varname>$a</varname> è strettamente minore di <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Maggiore</entry>
       <entry>&true; se <varname>$a</varname> è strettamente maggiore di <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Minore o uguale</entry>
       <entry>&true; se <varname>$a</varname> è minore o uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Maggiore o uguale</entry>
       <entry>&true; se <varname>$a</varname> è maggiore o uguale a <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Se si confrontano interi con stringhe o il confronto coinvolge stringhe
    numeriche, ogni stringa viene
    <link linkend="language.types.string.conversion">convertita in numero</link>
    e il confronto è effettuato sui numeri. Queste regole valgono anche per l'istruzione
    <link linkend="control-structures.switch">switch</link>. La
    conversione di tipo non avviene quando il confronto è === o !== dal momento
    che ciò include anche il confronto del tipo. 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // mai raggiunta perchè "a" è già riconosciuta come 0
    echo "a";
    break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Se i tipi di operandi utilizzati differiscono, il confronto viene svolto
    nell'ordine indicato della seguente tabella.
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Confronti con differenti tipi</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Tipo dell'operando 1</entry>
       <entry>Tipo dell'operando 2</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> oppure <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>Si converte &null; in "", confronto numerico o lessicale</entry>
      </row>
      <row>
       <entry><type>bool</type> oppure <type>null</type></entry>
       <entry>qualsiasi</entry>
       <entry>Convertito in <type>bool</type>, &false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>Le classi predefinite possono avere la propria funzione di confronto, classi differenti
        non sono confrontabili, classi uguali confrontano le proprietà nello stesso modo delle
        matrici (PHP 4), PHP 5 ha il suo <link
        linkend="language.oop5.object-comparison">metodo di confronto</link>.
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> oppure <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> oppure <type>number</type></entry>
       <entry>Stringhe e risorse sono converti in numeri, confronto matematico</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>La matrice con meno membri è più piccola, se la chiave dell'operando 1 non si
        trova nell'operando 2 allora le matrici non si possono confrontare, in altri casi
        il confronto avviene valore per valore (vedere l'esempio seguente)</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>qualsiasi</entry>
       <entry><type>array</type> è sempre più grande</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>qualsiasi</entry>
       <entry><type>object</type> è sempre più grande</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>Trascrizione del confronto standard tra matrici</title>
     <programlisting role="php">
<![CDATA[
<?php
// Le matrici vengono confrontate come illustrato in questa funzione
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // uncomparable
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Vedere anche <function>strcasecmp</function>,
    <function>strcmp</function>,
    <link linkend="language.operators.array">Array operators</link>,
    e la sezione del manuale su
    <link linkend="language.types">Types</link>.
   </para>

   <warning>
    <title>Confronto di numeri in virgola mobile</title>

    <para>
     A causa del modo in cui i <type>float</type> sono rappresentati internamente al PHP, non
     si dovrebbe esaminare l'eguaglianza di due <type>float</type>.
    </para>

    <para>
     Per maggior informazioni, fare riferimento alla documentazione del tipo <type>float</type>.
    </para>
   </warning>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Operatore ternario</title>
    <para>
     Un altro operatore condizionale è l'operatore ternario "?:".
     <example>
      <title>Assegnazione di un valore di default</title>
      <programlisting role="php">
<![CDATA[
<?php
// Esempio di utilizzo dell'operatore ternario
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// La riga precedente è simile a
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example>
     L'espressione <literal>(espressione1) ? (espressione2) : (espressione3)</literal>
     vale <replaceable>espressione2</replaceable> se
     <replaceable>espressione1</replaceable> è &true;, e
     <replaceable>espressione3</replaceable> se
     <replaceable>espressione1</replaceable> è &false;.
    </para>
    <para>
     Dal PHP 5.3, è possibile tralasciare l'elemento centrale dell'operatore
     ternario. L'espressione <literal>espressione1 ?: espressione3</literal> restituisce
     <replaceable>espressione1</replaceable> se <replaceable>espressione1</replaceable>
     è &true;, e <replaceable>espressione3</replaceable> in caso contrario.
    </para>
    <note>
     <simpara>
      Si noti che l'operatore ternario è un'istruzione, e non viene valutato
      come variabile, ma come risultato di un'istruzione. Questo
      è importante da sapere nel caso si desideri restituire una variabile per riferimento.
      La riga <literal>return $var == 42 ? $a : $b;</literal> in una funzione
      che restituisce per riferimento non funzionerà e, nelle ultime versioni di PHP,
      genererà un avvertimento.
     </simpara>
    </note>
    <note>
     <para>
      si raccomanda di non sovrapporre le espressioni ternarie. Il 
      comportamento di PHP quando si usa più di un operatore ternario nella stessa
      istruzione non è ovvio:
      <example>
       <title>Comportamento ternario non ovvio</title>
       <programlisting role="php">
<![CDATA[
<?php
// a prima vista, questa istruzione dovrebbe restituire 'true'
echo (true?'true':false?'t':'f');

// invece, il risultato è 't'
// perché le espressioni ternarie sono valutate da sinistra a destra

// quanti segue è una versione più chiara dello stesso codice
echo ((true ? 'true' : false) ? 't' : 'f');

// si può notare che la prima espressione è 'true', che
// a sua volta diventa (bool)true, e quindi restituisce il ramo true della
// seconda espressione ternaria.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Operatori di controllo errori</title>
   <simpara>
    PHP supporta un operatore di controllo dell'errore: il carattere at (@). Quando
    prefisso ad una espressione in PHP, qualunque messaggio di errore che possa
    essere generato da quella espressione sarà ignorato.
   </simpara>
   <simpara>
    Se è stata assegnata una funzione personalizzata di gestione degli errori con
    <function>set_error_handler</function> questa verrà comunque
    chiamata, ma questa funzione può (e dovrebbe) chiamare <function>error_reporting</function>
    che restituirà 0 quando la chiamata che ha attivato l'errore era preceduta da un @.
   </simpara>
   <simpara>
    Se la caratteristica <link linkend="ini.track-errors"><option>track_errors</option></link>
    è abilitata, qualsiasi messaggio di errore generato dall'espressione
    sarà salvato nella variabile globale 
    <varname>$php_errormsg</varname>.
    Questa variabile sarà sovrascritta ad ogni errore, quindi va controllata spesso per
    poterla utilizzare.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Errore di file intenzionale */
$my_file = @file ('file_inesistente') or
    die ("Apertura del file fallita: l'errore è '$php_errormsg'");

// questo funziona per qualsiasi espressione, non solo funzioni:
$value = @$cache[$key];
// non verrà generata una notifica se l'indice $key non esiste.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     L'operatore @ funziona solo sulle 
     <link linkend="language.expressions">espressioni</link>. Una semplice regola
     è: se si può ottenere il valore di qualcosa, allora si può anteporre ad esso
     l'operatore @. Per esempio, si può anteporre a variabili,
     funzioni e chiamate ad <function>include</function>, costanti, e
     così via. non si può anteporre a definizioni di funzioni o classi,
     o strutture condizionali come <literal>if</literal> e
     <literal>foreach</literal>, e così via.
    </simpara>
   </note>
   <simpara>
    Vedere anche <function>error_reporting</function> e la sezione del manuale
    <link linkend="ref.errorfunc">Gestione degli errori e funzioni di log</link>.
   </simpara>
   <warning>
    <para>
     In effetti, il prefisso operatore di controllo dell'errore "@" disabiliterà
     la restituzione di errori per errori critici che interrompono l'esecuzione
     dello script. Tra le altre cose, questo significa che se si usa "@"
     per sopprimere errori da una certa funzione ed essa non è disponibile
     oppure è stata scritta male, lo script terminerà
     senza dare indicazioni sul motivo.
    </para>
   </warning>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Operatori di esecuzione</title>
   <para>
    PHP supporta un operatore di esecuzione: backticks (``). Si noti che
    non sono apostrofi o apici! PHP cercherà di eseguire
    il contenuto dei backticks come comando di shell; sarà restituito l'output
    (ovvero, non sarà semplicemente inviato all'output, ma potrà
    essere assegnato ad una variabile). L'uso dell'operatore backtick è identico
    alla funzione <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     L'operatore backtick è disabilitato quando è abilitata &safemode;
     oppure quando è disabilitata <function>shell_exec</function>.
    </para>
   </note>
   <note>
    <para>
     Diversamente da altri linguaggi, i backtick non posso essere usati all'interno
     di stringhe delimitate da doppi apici.
    </para>
   </note>
   <para>
    Vedere anche la sezione del manuale <link linkend="ref.exec">Funzioni
    per l'esecuzione di programmi</link>, <function>popen</function>,
    <function>proc_open</function> e
    <link linkend="features.commandline">Utilizzo del PHP da
    linea di comando</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Operatori di incremento/decremento</title>
   <para>
    PHP supporta lo stile C degli operatori di pre- e post-incremento
    e decremento.
   </para>
   <note>
    <simpara>
     Gli operatori di incremento e decremento non agiscono sui valori boolean.
     Anche decrementare il valore &null; non ha effetti, ma incrementarlo
     darà come risultato <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Operatori di incremento/decremento</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Effetto</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pre-incremento</entry>
       <entry>Incrementa <varname>$a</varname> di una unità, quindi restituisce <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-incremento</entry>
       <entry>Restituisce <varname>$a</varname>, quindi incrementa <varname>$a</varname> di una unità.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pre-decremento</entry>
       <entry>Decrementa <varname>$a</varname> di una unità, quindi restituisce <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-decremento</entry>
       <entry>Restituisce <varname>$a</varname>, quindi decrementa <varname>$a</varname> di una unità.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Un semplice script di esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Dovrebbe essere 5: " . $a++ . "<br />\n";
echo "Dovrebbe essere 6: " . $a . "<br />\n";

echo "<h3>Pre-incremento</h3>";
$a = 5;
echo "Dovrebbe essere 6: " . ++$a . "<br />\n";
echo "Dovrebbe essere 6: " . $a . "<br />\n";

echo "<h3>Post-decremento</h3>";
$a = 5;
echo "Dovrebbe essere 5: " . $a-- . "<br />\n";
echo "Dovrebbe essere 4: " . $a . "<br />\n";

echo "<h3>Pre-decremento</h3>";
$a = 5;
echo "Dovrebbe essere 4: " . --$a . "<br />\n";
echo "Dovrebbe essere 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Il PHP segue le convenzioni di Perl e non del C quando tratta le operazioni matematiche
    sui caratteri. Ad esempio, in PHP e Perl
    <literal>$a = 'Z'; $a++;</literal> modifica <literal>$a</literal> in <literal>'AA'</literal>, mentre in C
    <literal>a = 'Z'; a++;</literal> modifica <literal>a</literal> in <literal>'['</literal>
    (il valore ASCII di <literal>'Z'</literal> è 90, quello di <literal>'['</literal> è 91).
    Si noti che le variabili carattere possono essere incrementate ma non decrementate e
    anche in questo caso solo i caratteri ASCII (a-z e A-Z) sono supportati.
    Incrementare/decrementare altre variabili di carattere non ha effetto, la
    stringa originale non viene modificata.
    <example>
     <title>Operazioni aritmetiche su variabili carattere</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$i . "\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
     </screen>
    </example>
   </para>
   <para>
    Incrementare o decrementare valori booleani non ha effetto.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>Operatori logici</title>

   <table>
    <title>Operatori logici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>And</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> sono entrambe &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Or</entry>
       <entry>&true; se <varname>$a</varname> o <varname>$b</varname> è &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Xor</entry>
       <entry>&true; se <varname>$a</varname> o <varname>$b</varname> è &true;, ma non entrambe.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Not</entry>
       <entry>&true; se <varname>$a</varname> non è &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>And</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> sono entrambe &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Or</entry>
       <entry>&true; se <varname>$a</varname> o <varname>$b</varname> è &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    La ragione per le due differenti variazioni degli operatori "and" e "or"
    è che operano con differenti precedenze. (Vedere
    <link linkend="language.operators.precedence">Precedenza degli
    operatori</link>.)
   </simpara>
   <example>
    <title>Dimostrazione degli operatori logici</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() non viene mai chiamata in quanto gli operatori sono in corto-circuito

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" ha una precedenza maggiore rispetto a "or"

// Il risultato dell'espressione (false || true) è assegnato a $e
// Funziona come: ($e = (false || true))
$e = false || true;

// La costante false è assegnata a $f e quindi true è ignorato
// Funziona come: (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" ha una precesenza maggiore rispetto a "and"

// Il risultato dell'espressione (true && false) è assegnato a $g
// Funziona come: ($g = (true && false))
$g = true && false;

// La costante true è assegnata a $h e quindi false è ignorato
// Funziona come: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Operatori di stringa</title>
   <simpara>
    Ci sono due operatori di <type>stringa</type>. Il primo è l'operatore di
    concatenazione ('.'), che restituisce la concatenazione dei suoi argomenti di destra e
    di sinistra. Il secondo è l'operatore di
    assegnazione concatenato ('.='), che accoda l'argomento sul lato destro all'argomento sul lato
    sinistro. Vedere <link
    linkend="language.operators.assignment">Operatori di
    assegnazione</link> per maggiori informazioni.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Ciao ";
$b = $a . "Mondo!"; // ora $b contiene "Ciao Mondo!"

$a = "Ciao ";
$a .= "Mondo!";     // ora $a contiene "Ciao Mondo!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Vedere anche le sezioni 
    <link linkend="language.types.string">Stringhe</link> e
    <link linkend="ref.strings">Funzioni per le stringhe</link> nel manuale.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Operatori per matrici</title>
   <table>
    <title>Operatori per matrici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Unione</entry>
       <entry>Unione di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Uguaglianza</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> hanno le stesse coppie di chiavi/valori.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identità</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> hanno le stesse coppie di chiavi/valori nel
        medesimo ordine e dl medesimo tipo.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Disuguaglianza</entry>
       <entry>&true; se <varname>$a</varname> non è uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Disuguaglianza</entry>
       <entry>&true; se <varname>$a</varname> non è uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Non-identità</entry>
       <entry>&true; se <varname>$a</varname> non è identico a <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    L'operatore <literal>+</literal> restituisce la matrice di destra aggiunta
    a quella di sinistra; per le chiavi esistenti in entrambe le matrici, vengono usati gli elementi
    della matrice di sinistra, e gli elementi duplicati in quella
    di destra sono ignorati.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Unione di $a e $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Unione di $b e $a
echo "Union of \$b and \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    Una volta eseguito, lo script visualizzerà:
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    Gli elementi di una matrice sono uguali nel confronto se hanno le
    stesse chiavi e gli stessi valori.
   </para>
   <para>
    <example>
     <title>Confrontare le matrici</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Vedere anche la sezione del manuale sulle
    <link linkend="language.types.array">Matrici</link> e
    <link linkend="ref.array">Funzioni per le matrici</link>.
   </para>
  </sect1>
  <sect1 xml:id="language.operators.type">
   <title>Operatori di tipi</title>
   <para>
    <literal>instanceof</literal> è utilizzato per determinare se una variabile PHP
    è un oggetto istanza di una certa
    <link linkend="language.oop5.basic.class">classe</link>:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con le classi</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> può essere usato anche per determinare se una variabile
    è un oggetto istanziato da una classe che eredita da una classe parente:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con le classi ereditate</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Al fine di controllare se un oggetto <emphasis>non</emphasis> è un instanceof di una classe, si
    può usare l'<link linkend="language.operators.logical">operatore logico <literal>not</literal>
    </link>.
    <example>
     <title>Utilizzo di <literal>instanceof</literal> per controllare se un oggetto <emphasis>non</emphasis> è
     un'instanceof di una classe</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Infine, <literal>instanceof</literal> può essere usato anche per deretmnare se
    una variable è un oggetto istanziato da una classe che implementa una
    <link linkend="language.oop5.interfaces">interfaccia</link>:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> per una classe</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Anche se <literal>instanceof</literal> è normalmente usata con un nome di classe letterale,
    può essere usata con un altro oggetto o con una variabile stringa:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con altre variabili</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b è un oggetto di classe MyClass
var_dump($a instanceof $c); // $c è la stringa 'MyClass'
var_dump($a instanceof $d); // $d è la stringa 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Ci sono alcune trappole da evitare. Prima di PHP 5.1.0,
    <literal>instanceof</literal> chiama <function>__autoload</function>
    se il nome della classe non esiste. Inoltre, se la classe non è stata caricata,
    viene generato un errore fatale. Ciò può essere evitato usando un riferimento
    dinamico alla classe, o una variabile stringa che contenga il nome della classe:
    <example>
     <title>Evitare richerce del nome della classe ed errori fatali con <literal>instanceof</literal> in PHP 5.0</title>
     <programlisting role="php">
<![CDATA[
<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // l'errore fatale non avviene
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    L'operatore <literal>instanceof</literal> è stato introdotto in PHP 5.
    Prima di questo si utilizzava <function>is_a</function>, ma ora
    <function>is_a</function> è deprecata in favore di
    <literal>instanceof</literal>. Si noti che dal PHP 5.3.0,
    <function>is_a</function> non è più deprecata.
   </simpara>
   <para>
    Vedere anche <function>get_class</function> e
    <function>is_a</function>.
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
