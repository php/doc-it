<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 52407313885d27a4e891e08dd2e2481bcc39e244 Maintainer: pastore Status: ready -->
<!-- CREDITS: cucinato -->
<sect1 xml:id="language.operators.precedence">
 <title>Precedenza degli operatori</title>
 <para>
  La precedenza di un operatore specifica come esso tenga legate assieme "strettamente" due
  espressioni. Per esempio, nell'espressione <literal>1 +
  5 * 3</literal>, la risposta è <literal>16</literal> e non
  <literal>18</literal> perché l'operatore di moltiplicazione ("*")
  ha una precedenza più alta rispetto all'operatore di addizione ("+").
  Le parentesi possono essere usate per forzare la precedenza, se necessario. Per
  esempio: <literal>(1 + 5) * 3</literal> viene valutata
  <literal>18</literal>.
 </para>
 <para>
  Quando gli operatori hanno precedenza identica, la loro associatività decide
  come gli operatori sono raggruppati. Per esempio "-" è associativo a sinistra, quindi
  <literal>1 - 2 - 3</literal> è raggruppato come <literal>(1 - 2) - 3</literal>
  e valutato come <literal>-4</literal>. D'altra parte "=" è
  associativo a destra, quindi <literal>$a = $b = $c</literal> è raggruppato come
  <literal>$a = ($b = $c)</literal>.
 </para>
 <para>
  Operatori di uguale precedenza che non sono associativi non possono essere usati
  vicini l'uno all'altro, per esempio <literal>1 &lt; 2 &gt; 1</literal> è
  illegale in PHP. D'altra parte l'espressione <literal>1 &lt;= 1 == 1</literal>
  è legale, perchè l'operatore <literal>==</literal> ha una minore
  precedenza dell'operatore <literal>&lt;=</literal>.
 </para>
 <para>
  L'associatività è significativa solo per gli operatori binari (e ternari).
  Gli operatori unari sono prefisso o suffisso, quindi questa nozione non è applicabile.
  Ad esempio <literal>!!$a</literal> può essere raggruppato solo come <literal>!(!$a)</literal>.
 </para>
 <para>
  L'uso delle parentesi, anche quando non strettamente necessario, può spesso aumentare
  la leggibilità del codice rendendo il raggruppamento esplicito piuttosto che fare affidamento
  sulla precedenza e sull'associatività implicite degli operatori.
 </para>
 <para>
  La seguente tabella fornisce una lista della precedenza degli operatori con gli
  operatori a più alta precedenza elencati prima. Gli operatori presenti nella medesima linea
  hanno uguale precedenza, in questi casi la loro associativià decide il raggruppamento.
  <table>
   <title>Precedenza degli operatori</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Associatività</entry>
      <entry>Operatori</entry>
      <entry>Informazioni aggiuntive</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>(n/a)</entry>
      <entry>
       <literal>clone</literal>
       <literal>new</literal>
      </entry>
      <entry><link linkend="language.oop5.cloning">clone</link> e <link linkend="language.oop5.basic.new">new</link></entry>
     </row>
     <row>
      <entry>destra</entry>
      <entry><literal>**</literal></entry>
      <entry><link linkend="language.operators.arithmetic">operatori aritmetici</link></entry>
     </row>
     <row>
      <entry>(n/a)</entry>
      <entry>
       <literal>+</literal> 
       <literal>-</literal> 
       <literal>++</literal> 
       <literal>--</literal> 
       <literal>~</literal> 
       <literal>(int)</literal> 
       <literal>(float)</literal> 
       <literal>(string)</literal> 
       <literal>(array)</literal>
       <literal>(object)</literal> 
       <literal>(bool)</literal> 
       <literal>@</literal>
      </entry>
      <entry>
       <link linkend="language.operators.arithmetic">aritmetici</link> (unari <literal>+</literal> e <literal>-</literal>),
       <link linkend="language.operators.increment">incremento/decremento</link>,
       <link linkend="language.operators.bitwise">bitwise</link>,
       <link linkend="language.types.typecasting">casting del tipo</link>&listendand;
       <link linkend="language.operators.errorcontrol">controllo dell'errore</link>
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry><literal>instanceof</literal></entry>
      <entry>
       <link linkend="language.operators.type">tipo</link>
      </entry>
     </row>
     <row>
      <entry>(n/a)</entry>
      <entry><literal>!</literal></entry>
      <entry>
       <link linkend="language.operators.logical">logici</link>
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry>
       <literal>*</literal>
       <literal>/</literal>
       <literal>%</literal>
      </entry>
      <entry>
       <link linkend="language.operators.arithmetic">aritmetici</link>
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry>
       <literal>+</literal> 
       <literal>-</literal> 
       <literal>.</literal>
      </entry>
      <entry>
       <link linkend="language.operators.arithmetic">aritmetici</link> (binari <literal>+</literal> e <literal>-</literal>),
       <link linkend="language.operators.array">array</link>&listendand;
       <link linkend="language.operators.string">stringhe</link> (<literal>.</literal> prima di PHP 8.0.0)
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry>
       <literal>&lt;&lt;</literal> 
       <literal>&gt;&gt;</literal>
      </entry>
      <entry>
       <link linkend="language.operators.bitwise">bit</link>
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry><literal>.</literal></entry>
      <entry>
       <link linkend="language.operators.string">stringhe</link> (a partire da PHP 8.0.0)
      </entry>
     </row>
     <row>
      <entry>non associativi</entry>
      <entry>
       <literal>&lt;</literal> 
       <literal>&lt;=</literal> 
       <literal>&gt;</literal> 
       <literal>&gt;=</literal>
      </entry>
      <entry>
       <link linkend="language.operators.comparison">confronto</link>
      </entry>
     </row>
     <row>
      <entry>non associativi</entry>
      <entry>
       <literal>==</literal>
       <literal>!=</literal> 
       <literal>===</literal> 
       <literal>!==</literal> 
       <literal>&lt;&gt;</literal>
       <literal>&lt;=&gt;</literal>
      </entry>
      <entry>
       <link linkend="language.operators.comparison">operatori di confronto</link>
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry><literal>&amp;</literal></entry>
      <entry>
       <link linkend="language.operators.bitwise">operatori sui bit</link>&listendand;
       <link linkend="language.references">riferimenti</link></entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry><literal>^</literal></entry>
      <entry>
       <link linkend="language.operators.bitwise">operatori sui bit</link>
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry><literal>|</literal></entry>
      <entry>
       <link linkend="language.operators.bitwise">operatori sui bit</link>
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry><literal>&amp;&amp;</literal></entry>
      <entry>
       <link linkend="language.operators.logical">operatori logici</link>
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry><literal>||</literal></entry>
      <entry>
       <link linkend="language.operators.logical">operatori logici</link>
      </entry>
     </row>
     <row>
      <entry>destra</entry>
      <entry><literal>??</literal></entry>
      <entry>
       <link linkend="language.operators.comparison.coalesce">null coalescing</link>
      </entry>
     </row>
     <row>
      <entry>non associativi</entry>
      <entry><literal>? :</literal></entry>
      <entry>
       <link linkend="language.operators.comparison.ternary">ternari</link>
       (associativi a sinistra prima di PHP 8.0.0)
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry>
       <literal>=</literal> 
       <literal>+=</literal> 
       <literal>-=</literal> 
       <literal>*=</literal> 
       <literal>**=</literal> 
       <literal>/=</literal> 
       <literal>.=</literal> 
       <literal>%=</literal> 
       <literal>&amp;=</literal> 
       <literal>|=</literal> 
       <literal>^=</literal> 
       <literal>&lt;&lt;=</literal> 
       <literal>&gt;&gt;=</literal>
       <literal>??=</literal>
      </entry>
      <entry>
       <link linkend="language.operators.assignment">operatori di assegnazione</link>
      </entry>
     </row>
     <row>
      <entry>(n/a)</entry>
      <entry><literal>yield from</literal></entry>
      <entry>
       <link linkend="control-structures.yield.from">yield from</link>
      </entry>
     </row>
     <row>
      <entry>(n/a)</entry>
      <entry><literal>yield</literal></entry>
      <entry>
       <link linkend="control-structures.yield">yield</link>
      </entry>
     </row>
     <row>
      <entry>(n/a)</entry>
      <entry><literal>print</literal></entry>
      <entry><function>print</function></entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry><literal>and</literal></entry>
      <entry>
       <link linkend="language.operators.logical">operatori logici</link>
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry><literal>xor</literal></entry>
      <entry>
       <link linkend="language.operators.logical">operatori logici</link>
      </entry>
     </row>
     <row>
      <entry>sinistra</entry>
      <entry><literal>or</literal></entry>
      <entry>
       <link linkend="language.operators.logical">operatori logici</link>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <para>
  <example>
   <title>Associatività</title>
   <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// l'associatività dell'operatore ternario differisce da quella di C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2 (prima di PHP 8.0.0)

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
   </programlisting>
  </example>
  </para>
 <para>
  La precedenza e l'associatività dell'operatore determinano solo come le espressioni
  sono raggruppate, esse non specificano un ordine di valutazione. PHP non
  specifica (nel caso generale) in quale ordine un'espressione è valutata
  e un codice che presuppone uno specifico ordine di valutazione dovrebbe essere evitato,
  perchè il comportamento può cambiare tra le versioni di PHP o in base al
  codice circostante.
  <example>
   <title>Ordine di valutazione indefinito</title>
   <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // può stampare 2 o 3

$i = 1;
$array[$i] = $i++; // può impostare l'indice 1 o 2
?>
]]>
   </programlisting>
  </example>
  <example>
   <title><literal>+</literal>, <literal>-</literal> e <literal>.</literal> hanno la stessa precedenza (prima di PHP 8.0.0)</title>
   <programlisting role="php">
<![CDATA[
<?php
$x = 4;
// questa linea potrebbe causare un risultato inaspettato:
echo "x minus one equals " . $x-1 . ", or so I hope\n";
// perché è valutata come questa linea (prima di PHP 8.0.0):
echo (("x minus one equals " . $x) - 1) . ", or so I hope\n";
// la precedenza desiderata può essere forzata usando le parentesi:
echo "x minus one equals " . ($x-1) . ", or so I hope\n";
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
-1, or so I hope
-1, or so I hope
x minus one equals 3, or so I hope
]]>
   </screen>
  </example>
 </para>
 <note>
  <para>
   Sebbene <literal>=</literal> abbia una precedenza minore rispetto
   alla maggior parte degli altri operatori, PHP permette comunque espressioni
   simili alla seguente: <literal>if (!$a = foo())</literal>,
   in questo caso l'output di <literal>foo()</literal> viene
   inserito in <varname>$a</varname>.
  </para>
 </note>
 <sect2 role="changelog">
  &reftitle.changelog;
  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>&Version;</entry>
      <entry>&Description;</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>8.0.0</entry>
      <entry>
       La concatenazione delle stringhe (<literal>.</literal>) ora ha una precedenza inferiore rispetto
       all'addizione/sottrazione aritmetica (<literal>+</literal> e <literal>-</literal>) e
       lo spostamento bit a bit a sinistra/destra (<literal>&lt;&lt;</literal> e <literal>&gt;&gt;</literal>);
       precedentemente aveva la stessa precedenza di <literal>+</literal> e <literal>-</literal>
       e una precedenza superiore a <literal>&lt;&lt;</literal> e <literal>&gt;&gt;</literal>.
      </entry>
     </row>
     <row>
      <entry>8.0.0</entry>
      <entry>
       L'operatore ternario (<literal>? :</literal>) ora è non-associativo;
       precedentemente era associativo a sinistra.
      </entry>
     </row>
     <row>
      <entry>7.4.0</entry>
      <entry>
       Fare affidamento sulla precedenza della concatenazione di stringhe (<literal>.</literal>) rispetto all'
       addizione/sottrazione aritmetica (<literal>+</literal> o <literal>-</literal>) o
       lo spostamento bit a bit a sinistra/destra (<literal>&lt;&lt;</literal> o <literal>&gt;&gt;</literal>),
       ovvero utilizzarli insieme in un'espressione senza parentesi, è deprecato.
      </entry>
     </row>
     <row>
      <entry>7.4.0</entry>
      <entry>
       Fare affidamento sull'associatività a sinistra dell'operatore ternario (<literal>? :</literal>),
       ovvero annidare più operatori ternari senza parentesi, è deprecato.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </sect2>
</sect1>