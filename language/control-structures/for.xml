<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 7104ee97ced1768a3231588dfc0bc0d7eb1117ad Maintainer: lacatoire Status: ready -->

<sect1 xml:id="control-structures.for" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>for</title>
 <?phpdoc print-version-for="for"?>
 <para>
  I cicli <literal>for</literal> sono i cicli più complessi in PHP.
  Si comportano come i loro equivalenti in C. La sintassi di un
  ciclo <literal>for</literal> è:
  <informalexample>
   <programlisting>
<![CDATA[
for (expr1; expr2; expr3)
    statement
]]>
   </programlisting>
  </informalexample>
 </para>
 <simpara>
  La prima espressione (<varname>expr1</varname>) viene
  valutata (eseguita) una volta incondizionatamente all'inizio del
  ciclo.
 </simpara>
 <simpara>
  All'inizio di ogni iterazione,
  <varname>expr2</varname> viene valutata. Se viene valutata come
  &true;, il ciclo continua e le istruzioni
  annidate vengono eseguite. Se viene valutata come
  &false;, l'esecuzione del ciclo termina.
 </simpara>
 <simpara>
  Alla fine di ogni iterazione, <varname>expr3</varname> viene
  valutata (eseguita).
 </simpara>
 <simpara>
  Ciascuna delle espressioni può essere vuota o contenere più
  espressioni separate da virgole. In <varname>expr2</varname>, tutte le
  espressioni separate da una virgola vengono valutate ma il risultato viene preso
  dall'ultima parte.
  <varname>expr2</varname> vuota significa che il ciclo deve essere
  eseguito indefinitamente (PHP lo considera implicitamente come
  &true;, come il C). Questo potrebbe non essere così inutile come
  si potrebbe pensare, poiché spesso si desidera terminare il ciclo utilizzando
  un'istruzione condizionale <link
  linkend="control-structures.break"><literal>break</literal></link>
  invece di utilizzare l'espressione di verità del <literal>for</literal>.
 </simpara>
 <para>
  Si considerino i seguenti esempi. Tutti visualizzano i numeri
  da 1 a 10:
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
/* example 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* example 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* example 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* example 4 */

for ($i = 1, $j = 0; $i <= 10; $j += $i, print $i, $i++);
?>
]]>
   </programlisting>
  </informalexample>
 </para>
 <simpara>
  Naturalmente, il primo esempio sembra essere il più elegante (o
  forse il quarto), ma è possibile constatare che l'utilizzo di espressioni vuote
  nei cicli <literal>for</literal> risulta utile in molte
  occasioni.
 </simpara>
 <para>
  PHP supporta anche la sintassi alternativa con i "due punti" per
  i cicli <literal>for</literal>.
  <informalexample>
   <programlisting>
<![CDATA[
for (expr1; expr2; expr3):
    statement
    ...
endfor;
]]>
   </programlisting>
  </informalexample>
 </para>
 <simpara>
  È comune per molti utenti iterare attraverso gli array come nell'esempio
  seguente.
 </simpara>
 <para>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
/*
 * This is an array with some data we want to modify
 * when running through the for loop.
 */
$people = array(
    array('name' => 'Kalle', 'salt' => 856412),
    array('name' => 'Pierre', 'salt' => 215863)
);

for($i = 0; $i < count($people); ++$i) {
    $people[$i]['salt'] = mt_rand(000000, 999999);
}
?>
]]>
   </programlisting>
  </informalexample>
 </para>
 <simpara>
  Il codice precedente può essere lento, poiché la dimensione dell'array viene calcolata
  ad ogni iterazione. Poiché la dimensione non cambia mai, il ciclo può essere facilmente
  ottimizzato utilizzando una variabile intermedia per memorizzare la dimensione invece
  di chiamare ripetutamente <function>count</function>:
 </simpara>
 <para>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$people = array(
    array('name' => 'Kalle', 'salt' => 856412),
    array('name' => 'Pierre', 'salt' => 215863)
);

for($i = 0, $size = count($people); $i < $size; ++$i) {
    $people[$i]['salt'] = mt_rand(000000, 999999);
}
?>
]]>
   </programlisting>
  </informalexample>
 </para>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
