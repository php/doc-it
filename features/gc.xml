<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 04f4545c02b4643283da216e6b62e39a307a9a9a Maintainer: lucalzetta Status: ready -->
<!-- $Revision$ -->
 <chapter xml:id="features.gc" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Garbage Collection</title>

  <para>
   Questa sezione spiega i meriti del nuovo Garbage Collection (altrimenti 
   conosciuto come GC), meccanismo che è parte di PHP 5.3. 
  </para>

  <sect1 xml:id="features.gc.refcounting-basics">
   <title>Racconti delle referenze di base</title>
   <para>
    Una variabile PHP è un'entità archiviata in un container chiamato "zval". 
    Un container zval oltre al nome e al tipo della variabile, contiene 
    altri due bit di informazione: il primo è chiamato "is ref" ed è un 
    valore booleano che indica se una variabile è o meno parte di un gruppo 
    di referenze. Con questo bit il motore di PHP capisce come differenziare 
    le variabili tra quelle normali e le references variabili. Finché PHP 
    permette l'area utente delle referenze, così come viene creata dall'operatore 
    &amp;, un contenitore zval ha un contatore interno delle referenze 
    utilizzato in un meccanismo per ottimizzare l'uso della memoria. Questa 
    seconda parte di informazione aggiuntiva, chiamata "refcount", contiene 
    la quantità di nomi di variabili (chiamati anche simboli) che puntano 
    a questo contenitore zval. Tutti i nomi sono archiviati in una tabella 
    di simboli in cui ce n'è uno per ogni processo. C'è un processo (scope) 
    per lo script main (cioè quello richiesto dal browser), così come ce 
    n'è uno per ogni metodo o funzione. 
   </para>
   <para>
    Un zval viene creato quando viene creata una nuova variabile con un 
    valore costante, in questo modo: 
    <example>
     <title>Creazione di un nuovo contenitore zval</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    In questo caso il nuovo nome di simbolo, <literal>a</literal>, è creato 
    nel processo corrente, e un uovo contenitore di variabili è creato con 
    il tipo <type>string</type> e il valore <literal>new string</literal>. 
    Il bit "is_ref" è impostato per impostazione predefinita a &false; perché
    non sono state create aree di referenze utente. Il "refcount" è impostato 
    a <literal>1</literal> perchè c'è un solo simbolo (nome di variabile) che 
    fa uso di questo contenitore di variabili. Si osservi che se "refcount" 
    è <literal>1</literal>, "is_ref" è sempre &false;. Se abbiamo installato 
    <link xlink:href="&url.xdebug;">Xdebug</link>, è possibile visualizzare 
    queste informazioni chiamando la funzione <function>xdebug_debug_zval</function>. 
   </para>
   <para>
    <example>
     <title>VIsualizzare le informazioni su zval</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
xdebug_debug_zval('a');
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=1, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    L'assegnazione di questa variabile ad un'altra incrementa il valore di refcont. 
   </para>
   <para>
    <example>
     <title>Incremento di refcount in un contenitore zval</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
$b = $a;
xdebug_debug_zval( 'a' );
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=2, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Refcont ora è <literal>2</literal> perchè lo stesso contenitore della 
    variabile è stato collegato sia con <varname>a</varname> che con 
    <varname>b</varname>. PHP è 'furbo' abbastanza da non copiare l'intero 
    container della variabile se non è necessario. Questo andrà distrutto 
    quando refcount raggiunge lo zero. Refcount viene decrementato di uno 
    quando ogni simbolo collegato al contenitore delle variabili esce dal 
    suo scopo (cioè quando la funzione finisce la sua esecuzione) oppure 
    quando un simbolo (nome di variabile) non è più assegnato (magari 
    chiamando la funzione <function>unset</function>). Il seguente esempio 
    da una dimostrazione di questo comportamento: 
   </para>
   <para>
    <example>
     <title>Decremento di zval refcount</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
$c = $b = $a;
xdebug_debug_zval( 'a' );
$b = 42;
xdebug_debug_zval( 'a' );
unset( $c );
xdebug_debug_zval( 'a' );
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=3, is_ref=0)='new string'
a: (refcount=2, is_ref=0)='new string'
a: (refcount=1, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Se a questo punto chiamiamo <literal>unset($a);</literal>, il contenitore 
    delle variabili, incluso il tipo e il valore della variabile, verrà 
    rimoso dalla memoria. 
   </para>

   <sect2 xml:id="features.gc.compound-types">
    <title>Tipi composti</title>

    <para>
     Le cose poi si complicano con i tipi composti come gli <type>array</type>
     e gli<type>object</type>. In contrapposizione ai valori <type>scalari</type>, 
     gli <type>array</type> e gli <type>object</type> archiviano le loro 
     proprietà in una tabella di simboli tutta loro. Ciò significa, ad 
     esempio, che il seguente script creerà tre contenitori zval: 
    </para>
    <para>
     <example>
      <title>Creare un <type>array</type> zval</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=1, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42
)
]]>
      </screen>
      <para>O graficamente</para>
      <mediaobject>
       <alt>Zvals per un semplice array</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/simple-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     I tre contenitori zval sono: <varname>a</varname>, <
     varname>meaning</varname>, e <varname>number</varname>.
     Regole simili si applicano per incrementare e decrementare i refcounts. 
     Sotto aggiungiamo un altro elemento all'array e impostiamo il suo valore 
     al contenuto di quello di un altro elemento preesistente. 
    </para>
    <para>
     <example>
      <title>Aggiunta di un elemento ad un array</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=2, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42,
   'life' => (refcount=2, is_ref=0)='life'
)
]]>
      </screen>
      <para>O graficamente</para>
      <mediaobject>
       <alt>Zval per un array semplice con una referenza</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/simple-array2.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     Dal precedente output di Xdebug noi vediamo che entrambi, il vecchio 
     e il nuovo elemento dell'array ora puntano allo stesso contenitore 
     zval il cui refcount è <literal>2</literal>. Nonostante l'output di 
     Xdebug mostri due contenitori zval con il valore <literal>'life'</literal>, 
     essi sono la stessa cosa. La funzione <function>xdebug_debug_zval</function> 
     questo non lo mostra ma è possibile vederlo mostrando il puntatore 
     della memoria. 
    </para>
    <para>
     Rimuovendo un elemento dall'array è come se rimuovessimo un simbolo 
     da uno scopo. Facendo questo il refcount di un container a cui punta 
     quell'elemento viene decrementato. Ancora una volta, qundo "refcount" 
     raggiunge il valore di zero, il contenitore delle variabili viene 
     rimosso dalla memoria. Ancora un esempio per mostrare questo 
     comportamento: 
    </para>
    <para>
     <example>
      <title>Rimuovere un elemento da un array</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
unset( $a['meaning'], $a['number'] );
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'life' => (refcount=1, is_ref=0)='life'
)
]]>
      </screen>
     </example>
    </para>
    <para>
    Ora le cose diventano interessanti: se aggiugngiamo l'array stesso 
     come un elemento dell'array, lo facciamo nel prossimo esempio in cui 
     anche lo inseriamo in un operatore di referenze, vediamo che PHP ne 
     creerà una copia: 
    </para>
    <para>
     <example>
      <title>Aggiungere un array come elemento di se stesso</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'one' );
$a[] =& $a;
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=2, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=2, is_ref=1)=...
)
]]>
      </screen>
      <para>O graficamente</para>
      <mediaobject>
       <alt>Zvals per un array con una referenza circolare</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/loop-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     Si può vedere che la variabile array (<varname>a</varname>) come il secondo elemento 
     (<varname>1</varname>) ora punta a un contenitore di variabili che ha un refcount di <literal>2</literal>. 
     I tre puntini "..." nella visualizzazione precedente mostrano che c'è una ricorsione in corso, che, 
     naturalmente, in questo caso significa che i "..." puntano indietro all'array originale. 
    </para>
    <para>
     Proprio come prima dereferenziare una variabile rimuove il suo nome 
     e il reference count del contenitore delle variabili a cui la variabile 
     puntava viene decrementato di uno. Così, se noi dereferenziamo la variabile 
     <varname>$a</varname> dopo aver eseguito il codice precedente il reference 
     count del contenitore delle variabili a cui puntano la variabile 
     <varname>$a</varname> e l'elemento "1", viene decrementato di uno, 
     da "2" a "1". Questo può essere rappresentato così: 
    </para>
    <para>
     <example>
      <title>Unsetting <varname>$a</varname></title>
      <screen>
<![CDATA[
(refcount=1, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=1, is_ref=1)=...
)
]]>
      </screen>
      <para>O graficamente</para>
      <mediaobject>
       <alt>Zval dopo la rimozione di array con una referenza circolare dimostrano la perdita in memoria</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/leak-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
   </sect2>

   <sect2 xml:id="features.gc.cleanup-problems">
    <title>Problemi di pulizia</title>
    <para>
     Sebbene no ci sia più alcun simbolo in alcuno scopo che punti a 
     questa struttura, non può comunque essere distrutta perché l'array 
     elemento "1" ancora punta a questo stesso array. benché non ci siano 
     simboli esterni che puntano ad esso, non c'è modo per un utente di 
     ripulire questa struttura; così si involve in una perdita di memoria 
     disponibile. Fortunatamente PHP pulirà queste strutture di dati alla 
     fine della richiesta, ma prima di allora, questo porterà via dello 
     spazio di memoria utilizzabile altrimenti. Questa situazione potrebbe 
     verificarsi abbastanza spesso se si implementano algoritmi di confronto 
     o altre cose dove un elemento figlio punta indietro verso un elemento padre. 
     La stessa situazione può anche verificarsi, ovviamente, con gli oggetti, 
     dove questo è anche più frequente che si verifichi siccome gli oggetti 
     sono implicitamente usati per referenza. 
    </para>
    <para>
     Questo potrebbe anche non essere un problema se succede solo un paio di 
     volte, ma se si verificano migliaia o milioni di queste perdite di memoria, 
     questo ovviamente diventa un problema. Specialmente in script di lunga 
     durata, come i daemon, dove le richieste di base sono di tipo infinito, 
     oppure in grossi ambiti di unità di prova. L'ultimo problema si è 
     verificato nellesecuzione di un test su un unità per i componenti temporanei 
     dei componenti della libreria eZ. In alcuni casi potevano venir richiesti 
     oltre 2 GB di memoria, che il server del test non poteva assolutamente 
     avere. 
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="features.gc.collecting-cycles">
   <title>Raccolta di cicli</title>
   <para>
    Tradizionalemnte i meccanismi di conteggio delle referenze, così 
    come usati prima da PHP, fallivano nell'indirizzamento di referenze 
    circolari in perdite della memoria; comunque, a partire da PHP 5.3.0, 
    viene implementato l'algoritmo sincrono della 
    <link xlink:href="&url.gc-paper;">Concurrent Cycle Collection in Reference Counted Systems</link>
    che reindirizza a questo problema. 
   </para>
   <para>
    Una spiegazione completa di come lavora l'algoritmo va oltre gli scopi 
    di questa sezione, ma le basi sono spiegate qui: prima di tutto, dobbiamo 
    stabilire alcune regole fondamentali. Se un refcount è incrementato, esso 
    è ancora in uso e quindi non garbage (distruttibile). Se il refcount è 
    decrementato e raggiunge lo zero, lo zval può essere liberato. Questo 
    significa che i cicli di garbage possono essere creati solo quando un 
    argomento refcount è decrementato ad un valore che non sia zero. Secondo, 
    in un ciclo di garbage, è possibile scoprire quali parti sono distruttibili 
    controllando quando è possibile decrementare il loro refcount di una unità 
    e quindi, controllare quali contenitori zval hanno un refcount pari a zero. 
   </para>
   <para>
     <mediaobject>
      <alt>Algoritmo di Garbage collection(raccolta della spazzatura)</alt>
      <imageobject>
       <imagedata fileref="en/features/figures/gc-algorithm.png" format="PNG"/>
      </imageobject>
     </mediaobject>
   </para>
   <para>
    Per evitare di dover chiamare il controllo dei cicli di garbage ogni 
    volta che si decrementa un refcount, l'algoritmo anziché mettere tutte 
    le possibili radici (zval) nel buffer delle radici (marcandole come viola 
    "purple"). Questo comunque rende certi che ogni possibile garbage root 
    finisca nel buffer una sola volta. Solo quando il buffer delle radici è 
    pieno il meccanismo di garbage collection si avvia per tutti i contenitori 
    zval che ci sono all'interno. Vedi il passaggio A nella figura sotto. 
   </para>
   <para>
    Nel passaggio B, l'algoritmo esegue una prima ricerca in profondità su 
    tutte le possibili radici per decrementare di uno il refcount di ogni zval 
    che trova, per assicurarsi di non decrementare lo stesso refcount di uno 
    zval due volte di seguito, li marca come "grey" (grigi). Nel passaggio 
    C, l'algoritmo rifà una prima ricerca profonda per ogni nodo di radice, 
    per verificare di nuovo il refcount di ogni zval. Se trova che un refcount 
    è zero, il contenitore zval è marcato "whitw"(bianco, blu nella figura). 
    Se è maggiore di zero, annulla il decremento del refcount di uno  con una 
    prima ricerca profonda da quel punto in avanti e vengono marcati nuovamente 
    in nero. Nell'ultimo passaggio: (D), l'algoritmo attraversa il buffer delle 
    radici rimuovendo le radici zval da esso, e nel frattempo, controlla quali 
    zval ha marcato in bianco nel passaggio precedente. Ogni zval marcato in 
    bianco viene eliminato. 
   </para>
   <para>
    Ora che abbiamo una comprensione di base di come lavora l'algoritmo, vediamo 
    come esso si integra in PHP. Per impostazione predefinita, il garbage 
    collector di PHP è attivato. C'è comunque un impostazione &php.ini; che 
    ci permette di cambiare questa impostazione: 
    <link linkend="ini.zend.enable-gc">zend.enable_gc</link>.
   </para>
   <para>
    Quando il garbage collector è attivato, il ciclo di ricerca dell'algoritmo, 
    come descritto in precedenza, viene eseguito ogni volta che il buffer 
    principale si riempie. Questo buffer ha una dimensione impostatta di 
    10.000 radici possibli (comunque è possibile modificare questo valore cambiando 
    la costante <literal>GC_ROOT_BUFFER_MAX_ENTRIES</literal> in 
    <literal>Zend/zend_gc.c</literal> nel codice di PHP, e ricompilandolo). 
    Quando il garbage collector è disattivato, il ciclo di ricerca dell'algoritmo 
    non viene mai eseguito. Comunque le possibili radici verranno registrate 
    nel buffer delle radici in qualunque modo sia configurato il comportamento 
    del garbage collector. 
   </para>
   <para>
    Se il buffer principale si riempie di eventuali radici mentre il meccanismo 
    di pulizia (garbage collectrion) è spento, ulteriori radici non verrebbero 
    semplicemente aggiunte. Queste possibili radici che non sono registrate 
    non saranno mai analizzate dall'algoritmo. Se sono parte di un ciclo di 
    referenze circoare, non sarebbero mai ripulite e potrebbero generare un 
    collasso della memoria. 
   </para>
   <para>
    La ragione per cui possibili radici vengono registrate anche se il meccanismo 
    del garbage collector è stato disabilitato è perché è più veloce registrare 
    le radici eventuali che doverle controllare tutte accendendo il meccanismo 
    ogni volta che un eventuale radice può essere trovata. l'avvio del meccanismo 
    di pulizia della memoria (garbage collection), l'analisi che esso compie, 
    comunque possono richiedere un dispendio ti tempo non trascurabile. 
   </para>
   <para>
    Oltre a modificare la configurazione delle impostazioni con 
    <link linkend="ini.zend.enable-gc">zend.enable_gc</link>, è possibile 
    accendere e spegnere il meccanismo di garbage collection (pulizia della 
    memoria chiamando <function>gc_enable</function> o<function>gc_disable</function> 
    rispettivamente. Chimare queste funzioni ha lo stesso effetto di accendere 
    e spegnere il meccanismo con la configurazione delle impostazioni. E' anche 
    possibile forzare la esecuzione dei cicli quando il buffer delle radici 
    possibili non è ancora pieno. Per questo è possibile usare la funzione 
    <function>gc_collect_cycles</function>, la quale restituisce il numero di 
    cicli che l'algoritmo ha trovato. 
   </para>
   <para>
    Il raziocinio che sta dietro la possibilità di spegnere, interrompendolo, 
    il meccanismo e avviare un ciclo di pulizia da parte dell'utente, è quello 
    per cui, alcune parti di un'applicazione potrebbero essere fortemente 
    condizionate dal tempo di esecuzione. In questi casi, si potrebbe non 
    desiderare che il meccanismo di garbage collection subentri nell'esecuzione 
    del codice. Naturalmente disattivando il meccanismo di garbage in alcune 
    parti delle proprie applicazioni si corre il rischio di generare collassi 
    della memoria perchè alcune possibili radici potrebbero non trovare spazio 
    entro il limite del buffer delle radici. Ad ogni modo potrebbe essere saggio 
    chiamare <function>gc_collect_cycles</function> appena prima di chiamare 
    <function>gc_disable</function> per liberare la memoria che potrebbe essere 
    persa attraverso eventuali radici già registrate nel buffer delle radici. 
    Questa copia di chiamate lascia libero il buffer in modo che ci sia più 
    spazio per archiviare possibili radici mentre il meccanismo di pulizia dei 
    cicli è spento. 
   </para>
  </sect1>

  <sect1 xml:id="features.gc.performance-considerations">
   <title>Considerazioni sulle performance</title>
   <para>
    Abbiamo già menzionato nella sezione precedente che la semplice collezione 
    di eventuali radici ha un impatto veramente basso sulle performance del 
    sistema, ma questa è la constatazione che si può fare confrontando PHP 5.2 
    con PHP 5.3. Sebbene la registrazione di possibili radici confrontata con 
    l'assenza totale di registrazioni, come accade in PHP 5.2, è più lenta. Altri 
    accorgimenti presi sul tempo di esecuzione di PHP in PHP 5.3 prevengono 
    questa particolare perdita di prestazioni da ogni contesto. 
   </para>
   <para>
    Ci sono due aree, in particolare, affette da questo calo. La prima area  
    interessa la riduzione dell'uso della memoria e la seconda è il ritardo del 
    tempo di esecuzione quando il meccanismo di garbage collection esegue la 
    pulizia della memoria. Osserveremo entrambi questi problemi. 
   </para>

   <sect2 xml:id="features.gc.performance-considerations.reduced-mem">
    <title>Riduzione dell'uso di Memoria</title>
    <para>
     Prima di tutto, la ragione profonda che ha fatto implementare il meccanismo 
     di garbage collection è stata la necessità di ridurre l'uso di memoria 
     ripulendo le referenze circolari delle variabili appena vengono riempiti 
     i buffer delle radici, oppure quando viene chaiamata la funzione 
     <function>gc_collect_cycles</function>. Nel grafico sotto, mostriamo l'uso 
     di memoria dello script sottostante, in entrambi PHP 5.2 and PHP 5.3, 
     escludendo la memoria di base usata da PHP per avviarsi. 
    </para>
    <para>
     <example>
      <title>Esempi di uso della memoria</title>
      <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public $var = '3.14159265359';
}

$baseMemory = memory_get_usage();

for ( $i = 0; $i <= 100000; $i++ )
{
    $a = new Foo;
    $a->self = $a;
    if ( $i % 500 === 0 )
    {
        echo sprintf( '%8d: ', $i ), memory_get_usage() - $baseMemory, "\n";
    }
}
?>
]]>
      </programlisting>
      <mediaobject>
       <alt>Confronto di uso della memoria tra PHP 5.2 e PHP 5.3</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/gc-benchmark.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     in questo esempio accademico abbiamo creato un oggetto in cui una sua 
     proprietà è impostata per puntare verso l'oggetto stesso. Quando la variabile 
     <varname>$a</varname>, nello script, viene riassegnata nella successiva 
     iterazione del ciclo, tipicamente si verifica una perdita di memoria. In 
     questo caso, due contenitori zval vanno persi (l'oggetto zval, e la proprietà
     zval), ma viene trovata solo un ardice possibile: la variabile che non era 
     ancora staata impostata. Quando il buffer delle radici è pieno, dopo 10.000 
     iterazioni (con un totale di 10.000 radici possibili) il meccanismo di 
     garbage collection inserisce e libera la memoria associata a queste possibilil 
     radici Questo è evidente osservando il grafico dell'uso della memoria per 
     PHP 5.3. Dopo ogni 10.000 iterazioni il meccanismo inserisce e libera la 
     memoria associata alle variabili con una referenza circolare. Il meccanismo 
     per se stesso, in questo esempio, non deve fare un grosso lavoro in profondità, 
     perchè la struttura che va persa, cancellata, è estremamente semplice. Dal 
     diagramma è possibile osservare che l'uso di memoria massimo in PHP 5.3 
     è di circa 9 Mb, mentre in PHP 5.2 l'uso della memoria aumenta in continuazione. 
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.slowdowns">
    <title>Rallentamenti dell'esecuzione</title>
    <para>
     La seconda area in cui il meccanismo di garbage collection influenza 
     maggiormante le prestazioni è il tempo preso dal meccanismo per inserire, 
     per liberare la memoria persa. Per poter osservare a quanto ammonta questo 
     tempo, abbiamo leggermente modificato lo script precedente per consentire 
     l'esecuzione di un più ampio numero di iterazioni e la rimozione delle 
     figure intermedie di uso della memoria. Il secondo script è il seguente: 
    </para>
    <para>
     <example>
      <title>Influenza del GC sulle prestazioni</title>
      <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public $var = '3.14159265359';
}

for ( $i = 0; $i <= 1000000; $i++ )
{
    $a = new Foo;
    $a->self = $a;
}

echo memory_get_peak_usage(), "\n";
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Abbiamo eseguito lo script due volte, una con l'impostazione 
     <link linkend="ini.zend.enable-gc">zend.enable_gc</link> accesa, e una 
     con la stessa impostazione spenta. 
    </para>
    <para>
     <example>
      <title>Esecuzione dello script precedente</title>
      <programlisting role="shell">
<![CDATA[
time php -dzend.enable_gc=0 -dmemory_limit=-1 -n example2.php
# and
time php -dzend.enable_gc=1 -dmemory_limit=-1 -n example2.php
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Sulla mia macchina, il primo comando sembra decisamnete prendere circa 10,7
     secondi, mentre l'esecuzione del secondo comando prende circa 11,4 secondi. 
     Questo significa un rallentamento di circa il 7%. Tuttavia, l'ammontare 
     massimo della memoria utilizzata dallo script si è ridotto del 98%, da 913Mb 
     a 10Mb. Questo test non è proprio scientifico, ne rappresentativo per applicazioni 
     realizzate per la produzione, ma dimostra i benefici che produce il 
     meccanismo di garbage collection. La cosa buona è che il rallentamento è 
     sempre lo stesso, 7%, per questo script in particolare, mentre il potenziale 
     di preservazione della memoria aumenta all'aumentare delle referenze 
     circolari trovate durante l'esecuzione dello script. 
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.internal-stats">
    <title>Statistiche interne a PHP per il GC</title>
    <para>
     E' possibile ottenere alcune ulteriori informazioni su come il meccanismo 
     di garbage collection viene eseguito all'interno di PHP. Ma prima di fare 
     questo, è necessario ricompilare PHP per consentire la prova e l'esecuzione 
     del codice pe la raccolta dei dati. E' necessario impostare la variabile 
     d'ambiente <literal>CFLAGS</literal> a <literal>-DGC_BENCH=1</literal> prima di 
     eseguire <literal>./configure</literal> con le opzioni desiderate. La sequenza 
     che segue fa questo: 
    </para>
    <para>
     <example>
      <title>Ricompilare PHP abilitando i test su GC</title>
      <programlisting role="shell">
<![CDATA[
export CFLAGS=-DGC_BENCH=1
./config.nice
make clean
make
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Eseguendo di nuovo il codice dell'esempio precedente con la nuova compilazione 
     di PHP, vedremo le seguenti informazioni alla fine dell'esecuzione del codice: 
    </para>
    <para>
     <example>
      <title>Statistiche GC</title>
      <programlisting role="shell">
<![CDATA[
GC Statistics
-------------
Runs:               110
Collected:          2072204
Root buffer length: 0
Root buffer peak:   10000

      Possible            Remove from  Marked
        Root    Buffered     buffer     grey
      --------  --------  -----------  ------
ZVAL   7175487   1491291    1241690   3611871
ZOBJ  28506264   1527980     677581   1025731
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Le statìstiche più significative sono mostrate nel primo blocco. Si può 
     osservare che il meccanismo di garbage collection viene eseguito 110 volte, 
     inoltre, in totale vengono liberate oltre 2 milioni di allocazioni di memoria 
     nel corso di queste 110 esecuzioni. Così come il meccanismo di garbage 
     collection che viene eseguito almeno una volta mantiene il picco di riempimento 
     del buffer delle radici sempre a 10.000. 
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.conclusion">
    <title>Conclusioni</title>
    <para>
     In generale, il garbage collector in PHP causa rallenyamenti solo durante 
     l'esecuzione dell'algoritmo del ciclo di raccolta in atto, normalmente, negli 
     script di piccole dimensioni non ci sono assolutamente riduzioni delle 
     prestazioni deovute all'esecuzione del garbage collector. 
    </para>
    <para>
     Comunque nel caso in cui il meccanismo di raccolta dei cicli venga eseguito 
     per script di dimensioni normali, la riduzione dell'uso della memoria 
     renderà possibile l'esecuzione concorrente di molti di questi script su un 
     server, finchè verrà utilizzata così poca memoria in totale. 
    </para>
    <para>
     I benefici sono molto più evidenti negli script di lunga durata, come 
     nei programmi di verifica molto lunghi o per gli script daemon. Anche per 
     le applicazioni <link xlink:href="&url.php.gtk;">PHP-GTK</link> che tendono 
     ad avere tempi di esecuzione molto lunghi, perché scritte per il web, il 
     meccanismo permette di avere una certa differenza riguardo alle dispersioni 
     di memoria striscianti che si verificano nel corso del tempo. 
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
