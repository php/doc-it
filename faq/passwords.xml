<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: f012b2761819e0ab25ff8cf4bac6655cfbc6fcff Maintainer: lacatoire Status: ready -->
 <chapter xml:id="faq.passwords" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Hashing delle password in modo sicuro</title>
  <titleabbrev>Hashing delle Password</titleabbrev>

  <simpara>
   Questa sezione spiega le ragioni per cui usare le funzioni di hashing
   per proteggere le password, e come farlo in modo efficace.
  </simpara>

  <qandaset>
   <qandaentry xml:id="faq.passwords.hashing">
    <question>
     <simpara>
      Perché dovrei applicare l'hash alle password fornite dagli utenti?
     </simpara>
    </question>
    <answer>
     <simpara>
      L'hashing delle password è una delle considerazioni di sicurezza più basilari che
      devono essere fatte quando si progetta qualsiasi applicazione o servizio che accetta password
      dagli utenti. Senza hashing, qualsiasi password memorizzata
      può essere rubata se l'archivio dati viene compromesso, e
      poi usata immediatamente per compromettere non solo l'applicazione o il servizio, ma anche
      gli account degli utenti su altri servizi, se non usano
      password uniche.
     </simpara>
     <simpara>
      Applicando un algoritmo di hashing alle password degli utenti prima di memorizzarle,
      diventa implausibile per qualsiasi attaccante
      determinare la password originale, pur essendo ancora in grado di confrontare
      l'hash risultante con la password originale in futuro.
     </simpara>
     <simpara>
      È importante notare, tuttavia, che l'hashing delle password le protegge solo
      dall'essere compromesse nell'archivio dati, ma non le protegge necessariamente
      dall'essere intercettate da codice malevolo iniettato nell'applicazione
      o nel servizio stesso.
     </simpara>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.passwords.fasthash">
    <question>
     <simpara>
      Perché le funzioni di hashing comuni come <function>md5</function> e
      <function>sha1</function> non sono adatte per le password?
     </simpara>
    </question>
    <answer>
     <simpara>
      Gli algoritmi di hashing come MD5, SHA1 e SHA256 sono progettati per essere
      molto veloci ed efficienti. Con le tecniche moderne e l'equipaggiamento informatico,
      è diventato banale fare <quote>brute force</quote> sull'output di questi algoritmi,
      per determinare l'input originale.
     </simpara>
     <simpara>
      A causa della rapidità con cui un computer moderno può <quote>invertire</quote> questi algoritmi
      di hashing, molti professionisti della sicurezza sconsigliano fortemente
      il loro uso per l'hashing delle password.
     </simpara>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.passwords.bestpractice">
    <question>
     <simpara>
      Come dovrebbero essere hashate le password, se le funzioni di hash comuni non sono
      adatte?
     </simpara>
    </question>
    <answer>
     <simpara>
      Quando si hashano le password, le due considerazioni più importanti sono il
      costo computazionale e il salt. Più è computazionalmente costoso
      l'algoritmo di hashing, più tempo ci vorrà per fare brute force sul suo
      output.
     </simpara>
     <simpara>
      PHP fornisce
      <link linkend="book.password">un'API nativa per l'hashing delle password</link> che
      gestisce in modo sicuro sia l'<link linkend="function.password-hash">hashing</link>
      che la <link linkend="function.password-verify">verifica delle password</link>
      in modo sicuro.
     </simpara>
     <simpara>
      L'algoritmo suggerito da usare per l'hashing delle password è Blowfish, che
      è anche il default usato dall'API di hashing delle password, poiché è
      significativamente più costoso computazionalmente rispetto a MD5 o SHA1, pur
      rimanendo scalabile.
     </simpara>
     <simpara>
      La funzione <function>crypt</function> è anche disponibile per l'hashing
      delle password, ma è raccomandata solo per l'interoperabilità con altri
      sistemi.
      Invece, è fortemente incoraggiato l'uso dell'
      <link linkend="book.password">API nativa per l'hashing delle password</link>
      quando possibile.
     </simpara>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.passwords.salt">
    <question>
     <simpara>
      Cos'è un salt?
     </simpara>
    </question>
    <answer>
     <simpara>
      Un salt crittografico è un dato che viene applicato durante il processo di hashing
      per eliminare la possibilità che l'output venga cercato
      in una lista di coppie pre-calcolate di hash e relativi input, nota come
      rainbow table.
     </simpara>
     <simpara>
      In termini più semplici, un salt è un po' di dati aggiuntivi che rende
      gli hash significativamente più difficili da craccare. Ci sono diversi
      servizi online che forniscono liste estese di hash pre-calcolati, così
      come l'input originale per quegli hash. L'uso di un salt rende
      implausibile o impossibile trovare l'hash risultante in una di queste
      liste.
     </simpara>
     <simpara>
      <function>password_hash</function> creerà un salt casuale se non ne viene
      fornito uno, e questo è generalmente l'approccio più semplice e
      sicuro.
     </simpara>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.password.storing-salts">
    <question>
     <simpara>
      Come vengono memorizzati i salt?
     </simpara>
    </question>
    <answer>
     <simpara>
      Quando si usa <function>password_hash</function> o
      <function>crypt</function>, il valore restituito include il salt come parte
      dell'hash generato. Questo valore dovrebbe essere memorizzato così com'è nel
      database, poiché include informazioni sulla funzione hash che è stata
      usata e può quindi essere passato direttamente a
      <function>password_verify</function> quando si verificano le password.
     </simpara>
     <warning>
      <simpara>
       <function>password_verify</function> dovrebbe sempre essere usato invece
       di ri-hashare e confrontare il risultato con un hash memorizzato per
       evitare attacchi di timing.
      </simpara>
     </warning>
     <simpara>
      Il seguente diagramma mostra il formato di un valore restituito da
      <function>crypt</function> o <function>password_hash</function>. Come si può
      vedere, sono auto-contenuti, con tutte le informazioni sull'algoritmo
      e sul salt necessarie per la futura verifica della password.
     </simpara>
     <para>
      <mediaobject>
       <alt>
        I componenti del valore restituito da password_hash e crypt: in
        ordine, l'algoritmo scelto, le opzioni dell'algoritmo, il salt usato,
        e la password hashata.
       </alt>
       <imageobject>
        <imagedata fileref="en/faq/figures/crypt-text-rendered.svg" width="690" depth="192" format="SVG" />
       </imageobject>
      </mediaobject>
     </para>
    </answer>
   </qandaentry>
  </qandaset>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
