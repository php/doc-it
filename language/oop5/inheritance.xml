<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: f94d903985119d3ac00f4528551df947f57b667f Maintainer: lacatoire Status: ready -->
 <sect1 xml:id="language.oop5.inheritance" xmlns="http://docbook.org/ns/docbook">
  <title>Ereditarietà degli oggetti</title>
  <para>
   L'ereditarietà è un principio di programmazione ben consolidato, e PHP fa uso
   di questo principio nel suo modello a oggetti. Questo principio influenza il modo
   in cui molte classi e oggetti si relazionano tra loro.
  </para>
  <para>
   Ad esempio, quando si estende una classe, la sottoclasse eredita tutti i metodi,
   le proprietà e le costanti pubbliche e protette dalla classe genitore.
   A meno che una classe non sovrascriva
   quei metodi, essi manterranno la loro funzionalità originale.
  </para>
  <para>
   Questo è utile per definire e astrarre funzionalità, e permette
   l'implementazione di funzionalità aggiuntive in oggetti simili senza la
   necessità di reimplementare tutte le funzionalità condivise.
  </para>
  <para>
   I metodi privati di una classe genitore non sono accessibili a una classe figlia. Di conseguenza,
   le classi figlie possono reimplementare un metodo privato senza riguardo per le normali
   regole di ereditarietà. Prima di PHP 8.0.0, tuttavia, le restrizioni <literal>final</literal> e <literal>static</literal>
   venivano applicate ai metodi privati. A partire da PHP 8.0.0, l'unica restrizione sui metodi privati
   applicata è <literal>private final</literal> per i costruttori, poiché questo
   è un modo comune per "disabilitare" il costruttore quando si usano metodi factory statici.
  </para>
 <para>
  La <link linkend="language.oop5.visibility">visibilità</link>
  dei metodi, delle proprietà e delle costanti può essere rilassata, ad es. un
  metodo <literal>protected</literal> può essere marcato come
  <literal>public</literal>, ma non possono essere ristrette, ad es.
  marcare una proprietà <literal>public</literal> come <literal>private</literal>.
  Un'eccezione sono i costruttori, la cui visibilità può essere ristretta, ad es.
  un costruttore <literal>public</literal> può essere marcato come <literal>private</literal>
  in una classe figlia.
 </para>

  <note>
   <para>
    A meno che non si usi l'autoloading, le classi devono essere definite prima di essere
    utilizzate. Se una classe estende un'altra, allora la classe genitore deve essere dichiarata
    prima della struttura della classe figlia. Questa regola si applica alle classi che ereditano
    da altre classi e interfacce.
   </para>
  </note>
  <note>
   <para>
    Non è consentito sovrascrivere una proprietà in lettura-scrittura con una <link linkend="language.oop5.properties.readonly-properties">proprietà readonly</link> o viceversa.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

class A {
    public int $prop;
}
class B extends A {
    // Non consentito: lettura-scrittura -> readonly
    public readonly int $prop;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>

 <example>
  <title>Esempio di ereditarietà</title>
  <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    public function printItem($string)
    {
        echo 'Foo: ' . $string . PHP_EOL;
    }

    public function printPHP()
    {
        echo 'PHP is great.' . PHP_EOL;
    }
}

class Bar extends Foo
{
    public function printItem($string)
    {
        echo 'Bar: ' . $string . PHP_EOL;
    }
}

$foo = new Foo();
$bar = new Bar();
$foo->printItem('baz'); // Output: 'Foo: baz'
$foo->printPHP();       // Output: 'PHP is great'
$bar->printItem('baz'); // Output: 'Bar: baz'
$bar->printPHP();       // Output: 'PHP is great'

?>
]]>
  </programlisting>
 </example>

  <sect2 xml:id="language.oop5.inheritance.internal-classes">
   <title>Compatibilità del tipo di ritorno con le classi interne</title>

   <para>
    Prima di PHP 8.1, la maggior parte delle classi o dei metodi interni non dichiarava i loro tipi di ritorno,
    e qualsiasi tipo di ritorno era consentito quando li si estendeva.
   </para>

   <para>
    A partire da PHP 8.1.0, la maggior parte dei metodi interni ha iniziato a dichiarare "tentativamente" il loro tipo di ritorno,
    in tal caso il tipo di ritorno dei metodi deve essere compatibile con il genitore esteso;
    altrimenti, viene emesso un avviso di deprecazione.
    L'assenza di una dichiarazione di ritorno esplicita è anch'essa considerata una mancata corrispondenza della firma,
    e genera quindi l'avviso di deprecazione.
   </para>

   <para>
    Se il tipo di ritorno non può essere dichiarato per un metodo che sovrascrive a causa di problemi di compatibilità tra versioni di PHP,
    è possibile aggiungere un attributo <classname>ReturnTypeWillChange</classname> per silenziare l'avviso di deprecazione.
   </para>

   <example>
    <title>Il metodo che sovrascrive non dichiara alcun tipo di ritorno</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyDateTime extends DateTime
{
    public function modify(string $modifier) { return false; }
}

// "Deprecated: Return type of MyDateTime::modify(string $modifier) should either be compatible with DateTime::modify(string $modifier): DateTime|false, or the #[\ReturnTypeWillChange] attribute should be used to temporarily suppress the notice" a partire da PHP 8.1.0
?>
]]>
    </programlisting>
   </example>

   <example>
    <title>Il metodo che sovrascrive dichiara un tipo di ritorno errato</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyDateTime extends DateTime
{
    public function modify(string $modifier): ?DateTime { return null; }
}

// "Deprecated: Return type of MyDateTime::modify(string $modifier): ?DateTime should either be compatible with DateTime::modify(string $modifier): DateTime|false, or the #[\ReturnTypeWillChange] attribute should be used to temporarily suppress the notice" a partire da PHP 8.1.0
?>
]]>
    </programlisting>
   </example>

   <example>
    <title>Il metodo che sovrascrive dichiara un tipo di ritorno errato senza avviso di deprecazione</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyDateTime extends DateTime
{
    /**
     * @return DateTime|false
     */
    #[\ReturnTypeWillChange]
    public function modify(string $modifier) { return false; }
}

// Nessun avviso viene generato
?>
]]>
    </programlisting>
   </example>

  </sect2>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
