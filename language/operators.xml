<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 9c098f1e964f310c423844fafb1f8fb4399e4064 Maintainer: pastore Status: ready -->
<!-- CREDITS: cucinato -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Operatori</title>
  <simpara>
   Un operatore è un qualcosa che si posiziona tra uno o più valori (od espressioni,
   in gergo tecnico) e produce un'altro valore (in modo tale che la costruzione
   stessa diventi a sua volta un'espressione). i
  </simpara>
  <para>
   Gli operatori possono essere raggruppati a seconda del numero di valori che trattano. Gli
   operatori unari quali richiedono un solo valore, ad esempio <literal>!</literal>i
   (l'<link linkend="language.operators.logical">operatore logico noti</link>) oppure
   <literal>++</literal> 
   (l'<link linkend="language.operators.increment">operatore di autoincremento</link>).
   Gli operatori binari accettano due valor, come i familiari
   <link linkend="language.operators.arithmetic">operatori aritmetici</link>
   <literal>+</literal> (più) e <literal>-</literal> (meno), e la
   maggior parte degli operatori disponibili in PHP ricadono in questa categoria. Infine, esiste un
   solo <link linkend="language.operators.comparison.ternary">operatore
   ternario</link>, <literal>? :</literal>, che accetta tre valori; viene
   normalmente chiamato "l'operatore ternario" (anche se potrebbe
   forse essere chiamato più precisamente operatore condizionale).
  </para>
  <para>
   Una lista completa degli operatore è fornita nella sezione
   <link linkend="language.operators.precedence">Precedenza degli operatori</link>.
   Questa sezione spiega anche la precedenza degli operatori e l'associatività, che stabiliscono
   esattamente come le espressioni contenenti differenti operatori sono
   valutate ed eseguite.
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>Precedenza degli operatori</title>
   <para>
    La precedenza di un operatore specifica come esso tenga legate assieme "strettamente" due
    espressioni. Per esempio, nell'espressione <literal>1 +
    5 * 3</literal>, la risposta è <literal>16</literal> e non
    <literal>18</literal> perché l'operatore di moltiplicazione ("*")
    ha una precedenza più alta rispetto all'operatore di addizione ("+").
    Le parentesi possono essere usate per forzare la precedenza, se necessario. Per
    esempio: <literal>(1 + 5) * 3</literal> viene valutata
    <literal>18</literal>.
   </para>
   <para>
    Quando gli operatori hanno precedenza identica, la loro associatività decide
    come gli operatori sono raggruppati. Per esempio "-" è associativo a sinistra, quindi
    <literal>1 - 2 - 3</literal> è raggruppato come <literal>(1 - 2) - 3</literal>
    e valutato come <literal>-4</literal>. D'altra parte "=" è
    associativo a destra, quindi <literal>$a = $b = $c</literal> è raggruppato come
    <literal>$a = ($b = $c)</literal>.
   </para>
   <para>
    Operatori di uguale precedenza che non sono associativi non possono essere usati
    vicini l'uno all'altro, per esempio <literal>1 &lt; 2 &gt; 1</literal> è
    illegale in PHP. D'altra parte l'espressione <literal>1 &lt;= 1 == 1</literal>
    è legale, perchè l'operatore <literal>==</literal> ha meno
    precedenza dell'operatore <literal>&lt;=</literal>.
   </para>
   <para>
    L'uso delle parentesi, anche quando non strettamente necessario, può spesso aumentare
    la leggibilità del codice rendendo il raggruppamento esplicito piuttosto che fare affidamento
    sulla precedenza e sull'associatività implicite degli operatori.
   </para>
   <para>
    La seguente tabella fornisce una lista della precedenza degli operatori con gli
    operatori a più alta precedenza elencati prima. Gli operatori presenti nella medesima linea
    hanno uguale precedenza, in questi casi la loro associativià decide il raggruppamento.
    <table>
     <title>Precedenza degli operatori</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associatività</entry>
        <entry>Operatori</entry>
        <entry>Informazioni aggiuntive</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>(n/a)</entry>
        <entry>
         <literal>clone</literal>
         <literal>new</literal>
        </entry>
        <entry><link linkend="language.oop5.cloning">clone</link> e <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry><literal>**</literal></entry>
        <entry><link linkend="language.operators.arithmetic">operatori aritmetici</link></entry>
       </row>
       <row>
        <entry>(n/a)</entry>
        <entry>
         <literal>++</literal> 
         <literal>--</literal> 
         <literal>~</literal> 
         <literal>(int)</literal> 
         <literal>(float)</literal> 
         <literal>(string)</literal> 
         <literal>(array)</literal>
         <literal>(object)</literal> 
         <literal>(bool)</literal> 
         <literal>@</literal>
        </entry>
        <entry>
         <link linkend="language.types">types</link> and <link linkend="language.operators.increment">increment/decrement</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>instanceof</literal></entry>
        <entry>
         <link linkend="language.types">tipi</link>
        </entry>
       </row>
       <row>
        <entry>(n/a)</entry>
        <entry><literal>!</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         <literal>*</literal>
         <literal>/</literal>
         <literal>%</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">operatori aritmetici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         <literal>+</literal> 
         <literal>-</literal> 
         <literal>.</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">operatori aritmetici</link>&listendand;
         <link linkend="language.operators.string">operatori su stringhe</link></entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         <literal>&lt;&lt;</literal> 
         <literal>&gt;&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>
         <literal>&lt;</literal> 
         <literal>&lt;=</literal> 
         <literal>&gt;</literal> 
         <literal>&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">operatori di confronto</link>
        </entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>
         <literal>==</literal>
         <literal>!=</literal> 
         <literal>===</literal> 
         <literal>!==</literal> 
         <literal>&lt;&gt;</literal>
         <literal>&lt;=&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">operatori di confronto</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>&listendand;
         <link linkend="language.references">riferimenti</link></entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>^</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>|</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>&amp;&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>||</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry><literal>??</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.coalesce">null coalescing</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>? :</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">Operatore ternario</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         <literal>=</literal> 
         <literal>+=</literal> 
         <literal>-=</literal> 
         <literal>*=</literal> 
         <literal>**=</literal> 
         <literal>/=</literal> 
         <literal>.=</literal> 
         <literal>%=</literal> 
         <literal>&amp;=</literal> 
         <literal>|=</literal> 
         <literal>^=</literal> 
         <literal>&lt;&lt;=</literal> 
         <literal>&gt;&gt;=</literal>
         <literal>??=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.assignment">operatori di assegnazione</link>
        </entry>
       </row>
       <row>
        <entry>(n/a)</entry>
        <entry><literal>yield from</literal></entry>
        <entry>
         <link linkend="control-structures.yield.from">yield from</link>
        </entry>
       </row>
       <row>
        <entry>(n/a)</entry>
        <entry><literal>yield</literal></entry>
        <entry>
         <link linkend="control-structures.yield">yield</link>
        </entry>
       </row>
       <row>
        <entry>(n/a)</entry>
        <entry><literal>print</literal></entry>
        <entry><function>print</function></entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>and</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>xor</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>or</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    <example>
     <title>Associatività</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// l'associatività dell'operatore ternario differisce da quella di C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
    </para>
   <para>
    La precedenza e l'associatività dell'operatore determinano solo come le espressioni
    sono raggruppate, esse non specificano un ordine di valutazione. PHP non
    specifica (nel caso generale) in quale ordine un'espressione è valutata
    e un codice che presuppone uno specifico ordine di valutazione dovrebbe essere evitato,
    perchè il comportamento può cambiare tra le versioni di PHP o in base al
    codice circostante.
    <example>
     <title>Ordine di valutazione indefinito</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // può stampare 2 o 3

$i = 1;
$array[$i] = $i++; // può impostare l'indice 1 o 2
?>
]]>
     </programlisting>
    </example>
    <example>
     <title><literal>+</literal>, <literal>-</literal> e <literal>.</literal> hanno la stessa precedenza</title>
     <programlisting role="php">
<![CDATA[
<?php
$x = 4;
// questa linea potrebbe causare un risultato inaspettato:
echo "x minus one equals " . $x-1 . ", or so I hope\n";
// perché è valutata come questa linea:
echo (("x minus one equals " . $x) - 1) . ", or so I hope\n";
// la precedenza desiderata può essere forzata usando le parentesi:
echo "x minus one equals " . ($x-1) . ", or so I hope\n";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
-1, or so I hope
-1, or so I hope
x minus one equals 3, or so I hope
]]>
     </screen>
    </example>
   </para>
   <note>
    <para>
     Sebbene <literal>=</literal> abbia una precedenza minore rispetto
     alla maggior parte degli altri operatori, PHP permette comunque espressioni
     simili alla seguente: <literal>if (!$a = foo())</literal>,
     in questo caso l'output di <literal>foo()</literal> viene
     inserito in <varname>$a</varname>.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Operatori aritmetici</title>
   <simpara>
    Ricordate l'aritmetica di base dalla scuola? Questi operatori funzionano esattamente
    nello stesso modo.
   </simpara>
   <table>
    <title>Operatori aritmetici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>+$a</entry>
       <entry>Identità</entry>
       <entry>
        Conversione di <varname>$a</varname> in <type>int</type> o
        <type>float</type> in modo appropriato.
       </entry>
      </row>
      <row>
       <entry>-$a</entry>
       <entry>Negazione</entry>
       <entry>Opposto di <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Addizione</entry>
       <entry>La somma di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Sottrazione</entry>
       <entry>La differenza di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Moltiplicazione</entry>
       <entry>il prodotto di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Divisione</entry>
       <entry>Quoziente di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Modulo</entry>
       <entry>Il resto di <varname>$a</varname> diviso da <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a ** $b</entry>
       <entry>Elevamento a potenza</entry>
       <entry>Risultato di elevazione <varname>$a</varname> alla <varname>$b</varname>esima potenza.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    L'operatore di divisione ("/") restituisce un valore float a meno che i due operandi
    siano interi (oppure stringhe che vengono convertite in interi) e i numeri
    siano divisibili, nel qual caso viene restituito un valore intero. Per le
    divisioni di interi, vedere <function>intdiv</function>.
   </simpara>
   <simpara>
    Gli operandi del modulo sono convertiti a interi (rimuovendo la parte decimale)
    prima dell'operazione. Per il modulo di numeri a virgola mobile, vedere
    <function>fmod</function>.
   </simpara>
   <para>
    Il risultato dell'operatore modulo <literal>%</literal> ha lo stesso segno
    del dividendo - ovvero, il risultato di <literal>$a % $b</literal>
    avrà lo stesso segno di <varname>$a</varname>. Per esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // prints 2
echo (5 % -3)."\n";          // prints 2
echo (-5 % 3)."\n";          // prints -2
echo (-5 % -3)."\n";         // prints -2

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.math">Funzioni matematiche</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Operatori di assegnazione</title>
   <simpara>
    L'operatore di base dell'assegnazione è "=". Il primo impulso può
    essere quello di pensare che corrisponda a "uguale a". Invece questo operatore significa che
    l'operando a sinistra assume il valore dell'espressione a
    destra (cioè, "assegna il valore a").
   </simpara>
   <para>
    Il valore di un'espressione di assegnazione è il valore assegnato. Ovvero
    il valore di "$a = 3" è 3. Questo permette di fare qualche
    trucchetto:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a è uguale a 9 ora, e $b è stato impostato a 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    In aggiunta all'operatore di base dell'assegnazione, ci sono gli "operatori
    combinati" per tutta <link linkend="language.operators">l'aritmetica binaria</link>
    e gli operatori di stringa
    che consentono di usare un valore in un'espressione e poi impostare il suo
    valore al risultato di quell'espressione. Per esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // imposta $a a 8, corrispondente a: $a = $a + 5;
$b = "Ciao ";
$b .= "come va?"; // imposta $b a "Ciao come va?", proprio come $b = $b . "come va?";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Si noti che l'assegnazione copia la variabile originale nella nuova
    (assegnazione per valore), così i cambiamenti della prima non si verificheranno nell'
    altra. Ciò può anche avere rilevanza se si ha bisogno di copiare
    un grande array in un ciclo molto stretto. 
   </para>
   <para>
    Un'eccezione al comportamento standard dell'assegnazione per valore avviene
    con gli<type>object</type>, che sono assegnati per riferimento.
    Gli oggetti possono essere copiati esplicitamente attraverso la keyword <link
    linkend="language.oop5.cloning">clone</link>.
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>Assegnazione per referimento</title>
    <para>
     L'assegnazione per riferimento è pure supportato, usando la sintassi
     "<computeroutput>$var = &amp;$othervar;</computeroutput>.
     'Assegnazione per riferimento' significa che entrambe le variabili finiscono con il puntare agli
     stessi dati, e nulla è copiato.
    </para>
    <para>
     <example>
      <title>Assegnare per riferimento</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b è un riferimento ad $a

print "$a\n"; // stampa 3
print "$b\n"; // stampa 3

$a = 4; // modifica $a

print "$a\n"; // stampa 4
print "$b\n"; // stampa ugualmente 4, dal momento che $b è un riferimento ad $a, che è
              // stata modificata
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     L'operatore <link linkend="language.oop5.basic.new">new</link>
     restituisce automaticamente un riferimento, quindi assegnare il risultato di
     <link linkend="language.oop5.basic.new">new</link> per riferimento è un errore.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

$o = &new C;
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Parse error: syntax error, unexpected 'new' (T_NEW) in …
]]>
      </screen>
     </informalexample>
    </para>
    <para>
     Ulteriori informazioni sui riferimenti e sul loro uso possono essere trovati
     nella sezione del manuale
     <link linkend="language.references">Spiegazioni sui riferimenti</link>.
    </para>
   </sect2>

   <sect2 xml:id="language.operators.assignment.arithmetic">
    <title>Operatori di Assegnamento Aritmetici</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Esempio</entry>
        <entry>Equivalente</entry>
        <entry>Operazione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a += $b</entry>
        <entry>$a = $a + b</entry>
        <entry>Addizione</entry>
       </row>
       <row>
        <entry>$a -= $b</entry>
        <entry>$a = $a - $b</entry>
        <entry>Sottrazione</entry>
       </row>
       <row>
        <entry>$a *= $b</entry>
        <entry>$a = $a * $b</entry>
        <entry>Moltiplicazione</entry>
       </row>
       <row>
        <entry>$a /= $b</entry>
        <entry>$a = $a / $b</entry>
        <entry>Divisione</entry>
       </row>
       <row>
        <entry>$a %= $b</entry>
        <entry>$a = $a % $b</entry>
        <entry>Modulo</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.bitwise">
    <title>Operatori di Assegnazione Bit A Bit</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Esempio</entry>
        <entry>Equivalente</entry>
        <entry>Operazione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a &amp;= $b</entry>
        <entry>$a = $a &amp; $b</entry>
        <entry>And Bit a Bit</entry>
       </row>
       <row>
        <entry>$a |= $b</entry>
        <entry>$a = $a | $b</entry>
        <entry>Or Bit a Bit</entry>
       </row>
       <row>
        <entry>$a ^= $b</entry>
        <entry>$a = $a ^ $b</entry>
        <entry>Xor Bit a Bit</entry>
       </row>
       <row>
        <entry>$a &lt;&lt;= $b</entry>
        <entry>$a = $a &lt;&lt; $b</entry>
        <entry>Shift a Sinistra</entry>
       </row>
       <row>
        <entry>$a &gt;&gt;= $b</entry>
        <entry>$a = $a &gt;&gt; $b</entry>
        <entry>Shift a Destra</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.other">
    <title>Altri Operatori di Assegnamento</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Esempio</entry>
        <entry>Equivalente</entry>
        <entry>Operazione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a .= $b</entry>
        <entry>$a = $a . $b</entry>
        <entry>Concatenazione di stringhe</entry>
       </row>
       <row>
        <entry>$a ??= $b</entry>
        <entry>$a = $a ?? $b</entry>
        <entry>Null Coalesce</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 role="seealso" xml:id="language.operators.assignment.see-also">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.operators.arithmetic">operatori aritmetici</link></member>
      <member><link linkend="language.operators.bitwise">operatori bit a bit</link></member>
      <member><link linkend="language.operators.comparison.coalesce">operatori null coalescing</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Operatori sui bit</title>
   <simpara>
    Gli operatori sui bit permettono la valutazione e manipolazione di specifici
    bit in un valore intero.
   </simpara>
   <table>
    <title>Operatori sui bit</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>And</entry>
       <entry>Vengono accesi i bit che sono accesi sia in <varname>$a</varname> che in <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Or (inclusive or)</entry>
       <entry>Vengono accesi i bit che sono accesi o in <varname>$a</varname> oppure in <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Xor (exclusive or)</entry>
       <entry>
 Vengono accesi i bit che sono accesi in <varname>$a</varname> o in <varname>$b</varname>, ma non quelli accesi in entrambe le variabili.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Not</entry>
       <entry>
 Vengono accesi i bit che sono spenti in <varname>$a</varname>, e viceversa
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Shift left</entry>
       <entry>
 Sposta verso sinistra i bit di <varname>$a</varname> per <varname>$b</varname> volte (ogni passo significa
 "moltiplica per due")
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Shift right</entry>
       <entry>
 Sposta verso destra i bit di <varname>$a</varname> per <varname>$b</varname> volte (ogni passo significa
 "dividi per due")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Lo spostamento di bit in PHP è aritmetico.
    I bit spostati al di fuori delle estremità sono scartati.
    Gli spostamenti a sinistra inseriscono zeri a destra mentre il bit
    di segno è scartato sulla sinistra, quindi il segno di un operando
    non è conservato.
    Gli spostamenti a destra copiano il bit di segno sulla sinistra,
    quindi il segno di un operando è conservato.
   </para>
   <para>
    Utilizzare le parentesi per assicurare la
    <link linkend="language.operators.precedence">precedenza</link> desiderata.
    Per esempio, <literal>$a &amp; $b == true</literal> valuta
    l'equivalenza e poi l'operatore and; mentre
    <literal>($a &amp; $b) == true</literal> valuta l'operatore and e
    poi l'equivalenza.
   </para>
   <para>
    Se entrambi gli operandi per il operatori <literal>&amp;</literal>, <literal>|</literal>
    e <literal>^</literal> sono stringhe, allora l'operazione verrà
    eseguita sui valori ASCII dei caratteri che compongono le stringhe e
    il risultato sarà una stringa. In tutti gli altri casi, entrambi gli operandi saranno
    <link linkend="language.types.integer.casting">convertiti in interi</link>
    e il risultato sarà un intero.
   </para>
   <para>
    Se l'operando per l'operatore <literal>~</literal> è una stringa,
    l'operazione verrà eseguita sui valori ASCII dei caratteri che compongono
    la stringa e il risultato sarà una stringa, altrimenti l'operando e il
    risultato saranno trattati come interi.
   </para>
   <para>
    Sia gli operandi che il risultato per gli operatori <literal>&lt;&lt;</literal>
    e <literal>&gt;&gt;</literal> sono sempre trattati come interi.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
L'opzione ini error_reporting di PHP usa valori imappati sui bit,
fornendo quindi una dimostrazione reale dello spegnimento 
dei bit. Per mostrare tutti gli errori, eccettuati gli avvisi,
le istruzioni del file php.ini dicono di usare:
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Si prende il valore di E_ALL:
<computeroutput>00000000000000000111011111111111</computeroutput>
Quindi quello di E_NOTICE...
<computeroutput>00000000000000000000000000001000</computeroutput>
... e lo si inverte con <literal>~</literal>:
<computeroutput>11111111111111111111111111110111</computeroutput>
infine, si usa AND (&amp;) pre trovare i bit che sono accesi
in entrambi i valori:
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Un altro metodo per ottenere questo risultato è usare XOR (<literal>^</literal>)
per trovare i bit che sono accesi solo in uno dei due operandi:
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting può essere usata anche per dimostrare come accendere i bit.
Il modo per mostrare solo gli errori e gli errori recuperabili è:
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Questo processo combina E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
e
<computeroutput>00000000000000000001000000000000</computeroutput>
usando l'operatore OR (<literal>|</literal>)
per recuperare i bit accesi in entrambi i valori:
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>Operazioni AND, OR e XOR su interi</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Ignorare la sezione iniziale,
 * server solo a formattare per rendere più leggibile il risultato.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 risultato     valore     op test
 ---------     ---------  -- ---------
EOH;


/*
 * Ecco gli esempi.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitwise AND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitwise Inclusive OR \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitwise Exclusive OR (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 risultato     valore     op test
 ---------     ---------  -- ---------
 Bitwise AND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitwise Inclusive OR
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitwise Exclusive OR (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>Operazioni XOR su stringhe</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Ritorna '5'

echo "12" ^ "9"; // Ritorna il carattere Backspace (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Ritorna i valori ascii #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Ritorna 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Ritorna 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Spostamento di bit su interi</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Ecco gli esempi.
 */

echo "\n--- SPOSTAMENTO A DESTRA SU INTERI POSITIVI ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copia del bit di segno inserito a sinistra');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'i bit escono dal lato destro');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'come sopra; non c'è spostamento oltre lo 0');


echo "\n--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copia del bit di segno inserito a sinistra');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'i bit escono dal lato destro');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'come sopra; non c'è spostamento oltre il -1');


echo "\n--- SPOSTAMENTO A SINISTRA SU INTERI POSITIVI ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeri inseriti a destra');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'i bit di segno sono spostati');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'i bit escono dal lato sinistro');


echo "\n--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeri inseriti a destra');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'i bit escono dal lato sinistro, incluso il bit di segno');


/*
 * Ignorare questa sezione finale,
 * server solo a formattare per rendere più leggibile il risultato.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Espressione: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Decimale:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binario:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " NOTA: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- SPOSTAMENTO A DESTRA SU INTERI POSITIVI ---
Espressione: 2 = 4 >> 1
 Decimale:
  val=4
  res=2
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTA: copia del bit di segno inserito a sinistra

Espressione: 1 = 4 >> 2
 Decimale:
  val=4
  res=1
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Espressione: 0 = 4 >> 3
 Decimale:
  val=4
  res=0
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: i bit escono dal lato destro

Espressione: 0 = 4 >> 4
 Decimale:
  val=4
  res=0
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: come sopra; non c'è spostamento oltre lo 0


--- SPOSTAMENTO A DESTRA SU INTERI NEGATIVI ---
Espressione: -2 = -4 >> 1
 Decimale:
  val=-4
  res=-2
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTA: copia del bit di segno inserito a sinistra

Espressione: -1 = -4 >> 2
 Decimale:
  val=-4
  res=-1
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTA: i bit escono dal lato destro

Espressione: -1 = -4 >> 3
 Decimale:
  val=-4
  res=-1
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTA: come sopra; non c'è spostamento oltre il -1


--- SPOSTAMENTO A SINISTRA SU INTERI POSITIVI ---
Espressione: 8 = 4 << 1
 Decimale:
  val=4
  res=8
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTA: zeri inseriti a destra

Espressione: 1073741824 = 4 << 28
 Decimale:
  val=4
  res=1073741824
 Binario:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Espressione: -2147483648 = 4 << 29
 Decimale:
  val=4
  res=-2147483648
 Binario:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTA:i bit di segno sono spostati

Espressione: 0 = 4 << 30
 Decimale:
  val=4
  res=0
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro


--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---
Espressione: -8 = -4 << 1
 Decimale:
  val=-4
  res=-8
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTA: zeri inseriti a destra

Espressione: -2147483648 = -4 << 29
 Decimale:
  val=-4
  res=-2147483648
 Binario:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Espressione: 0 = -4 << 30
 Decimale:
  val=-4
  res=0
 Binario:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro, incluso il bit di segno
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- SPOSTAMENTO A DESTRA SU INTERI POSITIVI ---
Espressione: 2 = 4 >> 1
 Decimale:
  val=4
  res=2
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTA: copia del bit di segno inserito a sinistra

Espressione: 1 = 4 >> 2
 Decimale:
  val=4
  res=1
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Espressione: 0 = 4 >> 3
 Decimale:
  val=4
  res=0
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit escono dal lato destro

Espressione: 0 = 4 >> 4
 Decimale:
  val=4
  res=0
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: come sopra; non c'è spostamento oltre lo 0


--- SPOSTAMENTO A DESTRA SU INTERI NEGATIVI ---
Espressione: -2 = -4 >> 1
 Decimale:
  val=-4
  res=-2
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTA: copia del bit di segno inserito a sinistra

Espressione: -1 = -4 >> 2
 Decimale:
  val=-4
  res=-1
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTA: i bit escono dal lato destro

Espressione: -1 = -4 >> 3
 Decimale:
  val=-4
  res=-1
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTA: come sopra; non c'è spostamento oltre il -1


--- SPOSTAMENTO A SINISTRA SU INTERI POSITIVI ---
Espressione: 8 = 4 << 1
 Decimale:
  val=4
  res=8
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTA: zeri inseriti a destra

Espressione: 4611686018427387904 = 4 << 60
 Decimale:
  val=4
  res=4611686018427387904
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Espressione: -9223372036854775808 = 4 << 61
 Decimale:
  val=4
  res=-9223372036854775808
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit di segno sono spostati

Espressione: 0 = 4 << 62
 Decimale:
  val=4
  res=0
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro


--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---
Espressione: -8 = -4 << 1
 Decimale:
  val=-4
  res=-8
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTA: zeri inseriti a destra

Espressione: -9223372036854775808 = -4 << 61
 Decimale:
  val=-4
  res=-9223372036854775808
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Espressione: 0 = -4 << 62
 Decimale:
  val=-4
  res=0
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro, incluso il bit di segno
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     Utilizzare le funzioni dell'estensione <link linkend="book.gmp">gmp</link> per
     manipolazioni bit a bit su numeri che vanno oltre il valore di <literal>PHP_INT_MAX</literal>.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
<!-- <link linkend="language.oop5.basic.class.class">::class</link> -->
      <member><function>pack</function></member>
      <member><function>unpack</function></member>
      <member><function>gmp_and</function></member>
      <member><function>gmp_or</function></member>
      <member><function>gmp_xor</function></member>
      <member><function>gmp_testbit</function></member>
      <member><function>gmp_clrbit</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Operatori di confronto</title>
   <simpara>
    Gli operatori di confronto, come suggerisce il loro nome, permettono di confrontare
    due valori. Può essere interessante vedere la
    <link linkend="types.comparisons">tabella di raffronto dei tipi</link>,
    dato che mostra esempi di vari confronti tra i tipi di variabili.
   </simpara>
   <table>
    <title>Operatori di confronto</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Uguale</entry>
       <entry>&true; se <varname>$a</varname> è uguale a <varname>$b</varname> dopo la manipolazione dei tipi.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identico</entry>
       <entry>
        &true; se <varname>$a</varname> è uguale a <varname>$b</varname>, ed sono dello stesso
        tipo.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Diversi</entry>
       <entry>&true; se <varname>$a</varname> è diverso da <varname>$b</varname> dopo la manipolazione dei tipi.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Diversi</entry>
       <entry>&true; se <varname>$a</varname> è diverso da <varname>$b</varname> dopo la manipolazione dei tipi.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Non identici</entry>
       <entry>
        &true; se <varname>$a</varname> è diverso da <varname>$b</varname>, o se non sono dello stesso
        tipo.
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Minore</entry>
       <entry>&true; se <varname>$a</varname> è strettamente minore di <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Maggiore</entry>
       <entry>&true; se <varname>$a</varname> è strettamente maggiore di <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Minore o uguale</entry>
       <entry>&true; se <varname>$a</varname> è minore o uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Maggiore o uguale</entry>
       <entry>&true; se <varname>$a</varname> è maggiore o uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;=&gt; $b</entry>
       <entry>Spaceship</entry>
       <entry>
        Un <type>int</type> minore di, uguale a, o maggiore di zero quando
        <varname>$a</varname> è minore di, uguale a, o maggiore di
        <varname>$b</varname>.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Se entrambi gli operandi sono
    <link linkend="language.types.numeric-strings">stringhe numeriche</link>
    o un operando è un numero e l'altro è una
    <link linkend="language.types.numeric-strings">stringa numerica</link>,
    quindi il confronto viene eseguito numericamente.
    Queste regole si applicano anche all'
    istruzione <link linkend="control-structures.switch">switch</link>.
    La conversione del tipo non ha luogo quando il confronto è
    <literal>===</literal> o <literal>!==</literal> poiché implica
    il confronto del tipo e del valore.
   </para>
   
   <warning>
    <para>
     Prima di PHP 8.0.0, se una <type>stringa</type> veniva confrontata con un numero
     o una stringa numerica, la <type>stringa</type> veniva convertita in un
     numero prima di eseguire il confronto. Questo può portare a risultati
     sorprendenti, come si può vedere con il seguente esempio:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // mai raggiunta perché "a" è già riconosciuta come 0
    echo "a";
    break;
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php  
// Interi
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
 
// Numeri float
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// Stringhe
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
 
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1
 
// Array
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1
 
// Oggetti
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 0
 
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "c"]; 
echo $a <=> $b; // -1
 
$a = (object) ["a" => "c"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 1
 
// non vengono confrontati solo i valori; le chiavi devono corrispondere
$a = (object) ["a" => "b"]; 
$b = (object) ["b" => "b"]; 
echo $a <=> $b; // 1

?>
]]>
      
     </programlisting>
    </informalexample>
   </para>

   <para>
    Se i tipi di operandi utilizzati differiscono, il confronto viene svolto
    nell'ordine indicato della seguente tabella.
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Confronti con differenti tipi</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Tipo dell'operando 1</entry>
       <entry>Tipo dell'operando 2</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> oppure <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>Si converte &null; in "", confronto numerico o lessicale</entry>
      </row>
      <row>
       <entry><type>bool</type> oppure <type>null</type></entry>
       <entry>qualsiasi</entry>
       <entry>Converte entrambi i lati in <type>bool</type>, &false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>Le classi predefinite possono avere la propria funzione di confronto, classi differenti
        non sono confrontabili, per la stessa classe vedere <link
        linkend="language.oop5.object-comparison">Confronto di Oggetti</link>.
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type>, <type>int</type> oppure <type>float</type></entry>
       <entry><type>string</type>, <type>resource</type>, <type>int</type> oppure <type>float</type></entry>
       <entry>Stringhe e risorse sono converti in numeri, confronto matematico</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>La matrice con meno membri è più piccola, se la chiave dell'operando 1 non si
        trova nell'operando 2 allora le matrici non si possono confrontare, in altri casi
        il confronto avviene valore per valore (vedere l'esempio seguente)</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>qualsiasi</entry>
       <entry><type>object</type> è sempre più grande</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>qualsiasi</entry>
       <entry><type>array</type> è sempre più grande</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
   <para>
    <example>
     <title>Confronto Boolean/null</title>
     <programlisting role="php">
<![CDATA[
<?php
// Bool e null sono confrontati sempre come bool
var_dump(1 == TRUE);  // TRUE - uguale a (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - uguale a (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - uguale a (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - uguale a (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 è FALSE < TRUE
?>
]]>
     </programlisting>
    </example>
   </para>


   <para>
    <example>
     <title>Trascrizione del confronto standard tra matrici</title>
     <programlisting role="php">
<![CDATA[
<?php
// Le matrici vengono confrontate come illustrato in questa funzione
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // uncomparable
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <warning>
    <title>Confronto di numeri in virgola mobile</title>

    <para>
     A causa del modo in cui i <type>float</type> sono rappresentati internamente al PHP, non
     si dovrebbe esaminare l'eguaglianza di due <type>float</type>.
    </para>

    <para>
     Per maggior informazioni, fare riferimento alla documentazione del tipo <type>float</type>.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>strcasecmp</function></member>
      <member><function>strcmp</function></member>
      <member><link linkend="language.operators.array">Operatori degli array</link></member>
      <member><link linkend="language.types">Tipi</link></member>
     </simplelist>
    </para>
   </sect2>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Operatore ternario</title>
    <para>
     Un altro operatore condizionale è l'operatore ternario "?:".
     <example>
      <title>Assegnazione di un valore di default</title>
      <programlisting role="php">
<![CDATA[
<?php
// Esempio di utilizzo dell'operatore ternario
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// La riga precedente è simile a
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example>
     L'espressione <literal>(espressione1) ? (espressione2) : (espressione3)</literal>
     vale <replaceable>espressione2</replaceable> se
     <replaceable>espressione1</replaceable> è &true;, e
     <replaceable>espressione3</replaceable> se
     <replaceable>espressione1</replaceable> è &false;.
    </para>
    <para>
     È possibile tralasciare l'elemento centrale dell'operatore ternario.
     L'espressione <literal>espressione1 ?: espressione3</literal> restituisce
     <replaceable>espressione1</replaceable> se <replaceable>espressione1</replaceable>
     è &true;, e <replaceable>espressione3</replaceable> in caso contrario.
    </para>
    <note>
     <simpara>
      Si noti che l'operatore ternario è un'espressione, e non viene valutato
      come variabile, ma come risultato di un'espressione. Questo
      è importante da sapere nel caso si desideri restituire una variabile per riferimento.
      La riga <literal>return $var == 42 ? $a : $b;</literal> in una funzione
      che restituisce per riferimento non funzionerà e genererà un
      avvertimento.
     </simpara>
    </note>
    <note>
     <para>
      Si raccomanda di evitare di "sovrapporre" espressioni ternarie.
      Il comportamento di PHP quando si utilizza più di un operatore ternario all'interno di una singola
      istruzione non è ovvio rispetto ad altri linguaggi.
      Infatti prima di PHP 8.0.0, le espressioni ternarie venivano valutate da sinistra a
      destra, invece che da destra a sinistra come la maggior parte degli altri linguaggi di programmazione.
      <example>
       <title>Comportamento ternario non ovvio</title>
       <programlisting role="php">
<![CDATA[
<?php
// a prima vista, questa istruzione dovrebbe restituire 'true'
echo (true?'true':false?'t':'f');

// invece, l'output effettivo di quanto sopra è 't' prima di PHP 8.0.0
// perché le espressioni ternarie sono valutate da sinistra a destra

// quanti segue è una versione più chiara dello stesso codice
echo ((true ? 'true' : false) ? 't' : 'f');

// qui, si può notare che la prima espressione viene valutata come "true", che
// a sua volta diventa (bool)true, e quindi restituisce il ramo true della
// seconda espressione ternaria.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>
   
   <sect2 xml:id="language.operators.comparison.coalesce">
    <title>L'operatore Null Coalescing</title>
    <para>
     Inoltre esiste l'operatore "??" (o null coalescing).
     <example>
      <title>Assegnazione di un valore predefinito</title>
      <programlisting role="php">
<![CDATA[
<?php
// Esempio di utilizzo per: Operatore Null Coalesce
$action = $_POST['action'] ?? 'default';

// Quello sopra è identico a questa istruzione if/else
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';
}

?>
]]>
      </programlisting>
     </example>
     L'espressione <literal>(expr1) ?? (expr2)</literal> viene valutata a
     <replaceable>expr2</replaceable> se <replaceable>expr1</replaceable> è
     &null;, e <replaceable>expr1</replaceable> in caso contrario.
    </para>
    <para>
     In particolare, questo operatore non emette un avviso o un avvertimento se il valore del lato
     sinistro non esiste, proprio come <function>isset</function>. Questo è particolarmente
     utile sulle chiavi degli array.
    </para>
    <note>
     <simpara>
      Si prega di notare che l'operatore null coalescing è un'espressione, e che essa
      non viene valutata ad una variabile, ma al risultato di un'espressione. Questo
      è importante da sapere nel caso in cui si volesse restituire una variabile per riferimento.
      L'istruzione <literal>return $foo ?? $bar;</literal> in una funzione
      che restituisce un riferimento quindi non funzionerà e verrà emesso un
      avviso.
     </simpara>
    </note>
    <note>
     <para>
      Si prega di notare che l'operatore null coalescing permette semplici nidificazioni:
      <example>
       <title>Operatore null coalescing nidificato</title>
       <programlisting role="php">
<![CDATA[
<?php

$foo = null;
$bar = null;
$baz = 1;
$qux = 2;

echo $foo ?? $bar ?? $baz ?? $qux; // stampa 1

?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2> 
  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Operatori di controllo errori</title>
   <simpara>
    PHP supporta un operatore di controllo dell'errore: il carattere at (@). Quando
    prefisso ad una espressione in PHP, qualunque messaggio di errore che possa
    essere generato da quella espressione sarà ignorato.
   </simpara>
   <simpara>
    Se è stata assegnata una funzione personalizzata di gestione degli errori con
    <function>set_error_handler</function> questa verrà comunque
    chiamata, ma questa funzione può (e dovrebbe) chiamare <function>error_reporting</function>
    che restituirà 0 quando la chiamata che ha attivato l'errore era preceduta da un @.
   </simpara>
   <simpara>
    Qualsiasi messaggio di errore generato dall'espressione è disponibile nell'elemento
    <literal>"message"</literal> dell'array restituito da <function>error_get_last</function>.
    Il risultato di quella funzione cambierà ad ogni errore, quindi deve essere controllato in anticipo.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Errore di file intenzionale */
$my_file = @file ('file_inesistente') or
    die ("Apertura del file fallita: l'errore è stato '" . error_get_last()['message'] . "'");

// questo funziona per qualsiasi espressione, non solo funzioni:
$value = @$cache[$key];
// non verrà generata una notifica se l'indice $key non esiste.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     L'operatore @ funziona solo sulle 
     <link linkend="language.expressions">espressioni</link>. Una semplice regola
     è: se si può ottenere il valore di qualcosa, allora si può anteporre ad esso
     l'operatore @. Per esempio, si può anteporre a variabili,
     funzioni e chiamate ad <function>include</function>, costanti, e
     così via. non si può anteporre a definizioni di funzioni o classi,
     o strutture condizionali come <literal>if</literal> e
     <literal>foreach</literal>, e così via.
    </simpara>
   </note>
   <warning>
    <para>
     In effetti, il prefisso operatore di controllo dell'errore "@" disabiliterà
     la restituzione di errori per errori critici che interrompono l'esecuzione
     dello script. Tra le altre cose, questo significa che se si usa "@"
     per sopprimere errori da una certa funzione ed essa non è disponibile
     oppure è stata scritta male, lo script terminerà
     senza dare indicazioni sul motivo.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>error_reporting</function></member>
      <member><link linkend="ref.errorfunc">Funzioni di Gestione degli Errori e Logging</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Operatori di esecuzione</title>
   <para>
    PHP supporta un operatore di esecuzione: backticks (``). Si noti che
    non sono apostrofi o apici! PHP cercherà di eseguire
    il contenuto dei backticks come comando di shell; sarà restituito l'output
    (ovvero, non sarà semplicemente inviato all'output, ma potrà
    essere assegnato ad una variabile). L'uso dell'operatore backtick è identico
    alla funzione <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     L'operatore backtick è disabilitato quando
     è disabilitata <function>shell_exec</function>.
    </para>
   </note>
   <note>
    <para>
     Diversamente da altri linguaggi, i backtick non hanno un significato speciale
     all'interno di stringhe delimitate da doppi apici.
    </para>
   </note>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.exec">Funzioni per l'Esecuzione di Programmi</link></member>
      <member><function>popen</function></member>
      <member><function>proc_open</function></member>
      <member><link linkend="features.commandline">Utilizzo di PHP da linea di comando</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Operatori di incremento/decremento</title>
   <para>
    PHP supporta lo stile C degli operatori di pre- e post-incremento
    e decremento.
   </para>
   <note>
    <simpara>
     Gli operatori di incremento e decremento agiscono solo su numeri e stringhe.
     Array, oggetti, booleani e risorse non ne sono interessati.
     Anche decrementare il valore &null; non ha effetti, ma incrementarlo
     darà come risultato <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Operatori di incremento/decremento</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Effetto</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pre-incremento</entry>
       <entry>Incrementa <varname>$a</varname> di una unità, quindi restituisce <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-incremento</entry>
       <entry>Restituisce <varname>$a</varname>, quindi incrementa <varname>$a</varname> di una unità.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pre-decremento</entry>
       <entry>Decrementa <varname>$a</varname> di una unità, quindi restituisce <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-decremento</entry>
       <entry>Restituisce <varname>$a</varname>, quindi decrementa <varname>$a</varname> di una unità.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Un semplice script di esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Dovrebbe essere 5: " . $a++ . "<br />\n";
echo "Dovrebbe essere 6: " . $a . "<br />\n";

echo "<h3>Pre-incremento</h3>";
$a = 5;
echo "Dovrebbe essere 6: " . ++$a . "<br />\n";
echo "Dovrebbe essere 6: " . $a . "<br />\n";

echo "<h3>Post-decremento</h3>";
$a = 5;
echo "Dovrebbe essere 5: " . $a-- . "<br />\n";
echo "Dovrebbe essere 4: " . $a . "<br />\n";

echo "<h3>Pre-decremento</h3>";
$a = 5;
echo "Dovrebbe essere 4: " . --$a . "<br />\n";
echo "Dovrebbe essere 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Il PHP segue le convenzioni di Perl e non del C quando tratta le operazioni matematiche
    sui caratteri. Ad esempio, in PHP e Perl
    <literal>$a = 'Z'; $a++;</literal> modifica <literal>$a</literal> in <literal>'AA'</literal>, mentre in C
    <literal>a = 'Z'; a++;</literal> modifica <literal>a</literal> in <literal>'['</literal>
    (il valore ASCII di <literal>'Z'</literal> è 90, quello di <literal>'['</literal> è 91).
    Si noti che le variabili carattere possono essere incrementate ma non decrementate e
    anche in questo caso solo i caratteri e i numeri ASCII (a-z, A-Z e 0-9) sono supportati.
    Incrementare/decrementare altre variabili di carattere non ha effetto, la
    stringa originale non viene modificata.
    <example>
     <title>Operazioni aritmetiche su variabili carattere</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '== Alphabets ==' . PHP_EOL;
$s = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// I caratteri numerici si comportano diversamente
echo '== Digits ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
== Characters ==
X
Y
Z
AA
AB
AC
== Digits ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
     </screen>
    </example>
   </para>
   <para>
    Incrementare o decrementare valori booleani non ha effetto.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>Operatori logici</title>

   <table>
    <title>Operatori logici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>And</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> sono entrambe &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Or</entry>
       <entry>&true; se <varname>$a</varname> o <varname>$b</varname> è &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Xor</entry>
       <entry>&true; se <varname>$a</varname> o <varname>$b</varname> è &true;, ma non entrambe.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Not</entry>
       <entry>&true; se <varname>$a</varname> non è &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>And</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> sono entrambe &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Or</entry>
       <entry>&true; se <varname>$a</varname> o <varname>$b</varname> è &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    La ragione per le due differenti variazioni degli operatori "and" e "or"
    è che operano con differenti precedenze. (Vedere
    <link linkend="language.operators.precedence">Precedenza degli
    operatori</link>.)
   </simpara>
   <example>
    <title>Dimostrazione degli operatori logici</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() non viene mai chiamata in quanto gli operatori sono in corto-circuito

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" ha una precedenza maggiore rispetto a "or"

// Il risultato dell'espressione (false || true) è assegnato a $e
// Funziona come: ($e = (false || true))
$e = false || true;

// La costante false è assegnata a $f prima che l'operazione "or" avvenga
// Funziona come: (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" ha una precesenza maggiore rispetto a "and"

// Il risultato dell'espressione (true && false) è assegnato a $g
// Funziona come: ($g = (true && false))
$g = true && false;

// La costante true è assegnata a $h prima che l'operazione "and" avvenga
// Funziona come: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Operatori di stringa</title>
   <simpara>
    Ci sono due operatori di <type>stringa</type>. Il primo è l'operatore di
    concatenazione ('.'), che restituisce la concatenazione dei suoi argomenti di destra e
    di sinistra. Il secondo è l'operatore di
    assegnazione concatenato ('.='), che accoda l'argomento sul lato destro all'argomento sul lato
    sinistro. Vedere <link
    linkend="language.operators.assignment">Operatori di
    assegnazione</link> per maggiori informazioni.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Ciao ";
$b = $a . "Mondo!"; // ora $b contiene "Ciao Mondo!"

$a = "Ciao ";
$a .= "Mondo!";     // ora $a contiene "Ciao Mondo!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.string">Il tipo Stringa</link></member>
      <member><link linkend="ref.strings">Funzioni per le stringhe</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Operatori per matrici</title>
   <table>
    <title>Operatori per matrici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Unione</entry>
       <entry>Unione di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Uguaglianza</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> hanno le stesse coppie di chiavi/valori.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identità</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> hanno le stesse coppie di chiavi/valori nel
        medesimo ordine e dl medesimo tipo.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Disuguaglianza</entry>
       <entry>&true; se <varname>$a</varname> non è uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Disuguaglianza</entry>
       <entry>&true; se <varname>$a</varname> non è uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Non-identità</entry>
       <entry>&true; se <varname>$a</varname> non è identico a <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    L'operatore <literal>+</literal> restituisce la matrice di destra aggiunta
    a quella di sinistra; per le chiavi esistenti in entrambe le matrici, vengono usati gli elementi
    della matrice di sinistra, e gli elementi duplicati in quella
    di destra sono ignorati.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Unione di $a e $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Unione di $b e $a
echo "Union of \$b and \$a: \n";
var_dump($c);

$a += $b; // Unione di $a += $b è $a e $b
echo "Union of \$a += \$b: \n";
var_dump($a);
?>
]]>
     </programlisting>
    </informalexample>
    Una volta eseguito, lo script visualizzerà:
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
Union of $a += $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    Gli elementi di una matrice sono uguali nel confronto se hanno le
    stesse chiavi e gli stessi valori.
   </para>
   <para>
    <example>
     <title>Confrontare le matrici</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.array">Il tipo Array</link></member>
      <member><link linkend="ref.array">Funzioni per gli array</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.type">
   <title>Operatori di tipi</title>
   <para>
    <literal>instanceof</literal> è utilizzato per determinare se una variabile PHP
    è un oggetto istanza di una certa
    <link linkend="language.oop5.basic.class">classe</link>:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con le classi</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> può essere usato anche per determinare se una variabile
    è un oggetto istanziato da una classe che eredita da una classe parente:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con le classi ereditate</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Al fine di controllare se un oggetto <emphasis>non</emphasis> è un instanceof di una classe, si
    può usare l'<link linkend="language.operators.logical">operatore logico <literal>not</literal>
    </link>.
    <example>
     <title>Utilizzo di <literal>instanceof</literal> per controllare se un oggetto <emphasis>non</emphasis> è
     un'instanceof di una classe</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Infine, <literal>instanceof</literal> può essere usato anche per deretmnare se
    una variable è un oggetto istanziato da una classe che implementa una
    <link linkend="language.oop5.interfaces">interfaccia</link>:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con interfacce</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Anche se <literal>instanceof</literal> è normalmente usata con un nome di classe letterale,
    può essere usata con un altro oggetto o con una variabile stringa:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con altre variabili</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b è un oggetto di classe MyClass
var_dump($a instanceof $c); // $c è la stringa 'MyClass'
var_dump($a instanceof $d); // $d è la stringa 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    instanceof non genera errori se la variabile che viene controllata non è
    un oggetto, ma ritorna semplicemente &false;. Le costanti non erano comunque ammesse
    prima di PHP 7.3.0.
    <example>
     <title>Utilizzo di <literal>instanceof</literal> per controllare altre variabili</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a è un integer
var_dump($b instanceof stdClass); // $b è NULL
var_dump($c instanceof stdClass); // $c è una risorsa
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
     </screen>
    </example>
   </para>
   <para>
    A partire da PHP 7.3.0, le costanti sono permesse sul lato sinistro
    dell'operatore <literal>instanceof</literal>.
    <example>
     <title>Utilizzo di <literal>instanceof</literal> per testare le costanti</title>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    L'operatore <literal>instanceof</literal> ha una variante funzionale
    con la funzione <function>is_a</function>.
   </simpara>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>get_class</function></member>
      <member><function>is_a</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
