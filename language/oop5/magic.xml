<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 5e15a6c3e4d5819102361ae78e73c90a06238c8a Maintainer: lacatoire Status: ready -->
 <sect1 xml:id="language.oop5.magic" xmlns="http://docbook.org/ns/docbook">
  <title>Metodi magici</title>
  <para>
   I metodi magici sono metodi speciali che sovrascrivono l'azione predefinita
   di PHP quando vengono eseguite determinate azioni su un oggetto.
  </para>
  <caution>
   <simpara>
    Tutti i nomi di metodi che iniziano con <literal>__</literal> sono riservati
    da PHP. Pertanto, non è consigliato usare tali nomi di metodi a meno che
    non si voglia sovrascrivere il comportamento di PHP.
   </simpara>
  </caution>
  <para>
   I seguenti nomi di metodi sono considerati magici:
   <!-- Should be an itemized list ? -->
   <link linkend="object.construct">__construct()</link>,
   <link linkend="object.destruct">__destruct()</link>,
   <link linkend="object.call">__call()</link>,
   <link linkend="object.callstatic">__callStatic()</link>,
   <link linkend="object.get">__get()</link>,
   <link linkend="object.set">__set()</link>,
   <link linkend="object.isset">__isset()</link>,
   <link linkend="object.unset">__unset()</link>,
   <link linkend="object.sleep">__sleep()</link>,
   <link linkend="object.wakeup">__wakeup()</link>,
   <link linkend="object.serialize">__serialize()</link>,
   <link linkend="object.unserialize">__unserialize()</link>,
   <link linkend="object.tostring">__toString()</link>,
   <link linkend="object.invoke">__invoke()</link>,
   <link linkend="object.set-state">__set_state()</link>,
   <link linkend="object.clone">__clone()</link> e
   <link linkend="object.debuginfo">__debugInfo()</link>.
  </para>

  <warning>
   <!-- See for a code example of this behaviour: https://3v4l.org/Bov34 -->
   <simpara>
    Tutti i metodi magici, ad eccezione di
    <link linkend="object.construct">__construct()</link>,
    <link linkend="object.destruct">__destruct()</link> e
    <link linkend="object.clone">__clone()</link>,
    <emphasis>devono</emphasis> essere dichiarati come <literal>public</literal>,
    altrimenti viene emesso un <constant>E_WARNING</constant>.
    Prima di PHP 8.0.0, non veniva emessa alcuna diagnostica per i metodi magici
    <link linkend="object.sleep">__sleep()</link>,
    <link linkend="object.wakeup">__wakeup()</link>,
    <link linkend="object.serialize">__serialize()</link>,
    <link linkend="object.unserialize">__unserialize()</link> e
    <link linkend="object.set-state">__set_state()</link>.
   </simpara>
  </warning>
  <warning>
   <para>
    Se vengono usate dichiarazioni di tipo nella definizione di un metodo
    magico, queste devono essere identiche alla firma descritta in questo
    documento. Altrimenti, viene emesso un errore fatale.
    Prima di PHP 8.0.0, non veniva emessa alcuna diagnostica.
    Tuttavia, <link linkend="object.construct">__construct()</link> e
    <link linkend="object.destruct">__destruct()</link> non devono dichiarare
    un tipo di ritorno; altrimenti viene emesso un errore fatale.
   </para>
  </warning>

  <sect2 xml:id="language.oop5.magic.sleep">
   <title>
    <link linkend="object.sleep">__sleep()</link> e
    <link linkend="object.wakeup">__wakeup()</link>
   </title>

   <methodsynopsis xml:id="object.sleep">
    <modifier>public</modifier> <type>array</type><methodname>__sleep</methodname>
    <void/>
   </methodsynopsis>
   <methodsynopsis xml:id="object.wakeup">
    <modifier>public</modifier> <type>void</type><methodname>__wakeup</methodname>
    <void/>
   </methodsynopsis>

   <para>
    <function>serialize</function> verifica se la classe ha una funzione con
    il nome magico <link linkend="object.sleep">__sleep()</link>. In tal caso,
    quella funzione viene eseguita prima di qualsiasi serializzazione. Può
    ripulire l'oggetto e deve restituire un array con i nomi di tutte le
    variabili di quell'oggetto che devono essere serializzate.
    Se il metodo non restituisce nulla, viene serializzato &null; e viene
    emesso un <constant>E_NOTICE</constant>.
   </para>
   <note>
    <para>
     Non è possibile per <link linkend="object.sleep">__sleep()</link>
     restituire nomi di proprietà private nelle classi genitore. Farlo
     produrrà un errore di livello <constant>E_NOTICE</constant>.
     Usare <link linkend="object.serialize">__serialize()</link> al suo posto.
    </para>
   </note>
   <note>
    <para>
     A partire da PHP 8.0.0, la restituzione di un valore che non è un array
     da <link linkend="object.sleep">__sleep()</link> genera un avviso.
     In precedenza, generava una notifica.
    </para>
   </note>
   <para>
    L'uso previsto di <link linkend="object.sleep">__sleep()</link> è quello di
    salvare i dati in sospeso o eseguire operazioni di pulizia simili. Inoltre,
    la funzione è utile se un oggetto molto grande non ha bisogno di essere
    salvato completamente.
   </para>
   <para>
    Al contrario, <function>unserialize</function> verifica la presenza di una
    funzione con il nome magico
    <link linkend="object.wakeup">__wakeup()</link>. Se presente, questa
    funzione può ricostruire qualsiasi risorsa che l'oggetto potrebbe avere.
   </para>
   <para>
    L'uso previsto di <link linkend="object.wakeup">__wakeup()</link> è quello
    di ristabilire qualsiasi connessione al database che potrebbe essere stata
    persa durante la serializzazione e di eseguire altre operazioni di
    reinizializzazione.
   </para>
   <example>
    <title>Sleep e wakeup</title>
    <programlisting role="php">
<![CDATA[
<?php
class Connection
{
    protected $link;
    private $dsn, $username, $password;

    public function __construct($dsn, $username, $password)
    {
        $this->dsn = $dsn;
        $this->username = $username;
        $this->password = $password;
        $this->connect();
    }

    private function connect()
    {
        $this->link = new PDO($this->dsn, $this->username, $this->password);
    }

    public function __sleep()
    {
        return array('dsn', 'username', 'password');
    }

    public function __wakeup()
    {
        $this->connect();
    }
}?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.serialize">
   <title>
    <link linkend="object.serialize">__serialize()</link> e
    <link linkend="object.unserialize">__unserialize()</link>
   </title>

   <methodsynopsis xml:id="object.serialize">
    <modifier>public</modifier> <type>array</type><methodname>__serialize</methodname>
    <void/>
   </methodsynopsis>
   <methodsynopsis xml:id="object.unserialize">
    <modifier>public</modifier> <type>void</type><methodname>__unserialize</methodname>
    <methodparam><type>array</type><parameter>data</parameter></methodparam>
   </methodsynopsis>

   <para>
    <function>serialize</function> verifica se la classe ha una funzione con
    il nome magico <link linkend="object.serialize">__serialize()</link>. In
    tal caso, quella funzione viene eseguita prima di qualsiasi
    serializzazione. Deve costruire e restituire un array associativo di coppie
    chiave/valore che rappresentano la forma serializzata dell'oggetto. Se non
    viene restituito alcun array, verrà lanciato un
    <classname>TypeError</classname>.
   </para>
   <note>
    <para>
     Se sia <link linkend="object.serialize">__serialize()</link> che
     <link linkend="object.sleep">__sleep()</link> sono definiti nello stesso
     oggetto, solo <link linkend="object.serialize">__serialize()</link> verrà
     chiamato. <link linkend="object.sleep">__sleep()</link> verrà ignorato. Se
     l'oggetto implementa l'interfaccia
     <link linkend="class.serializable">Serializable</link>, il metodo
     <literal>serialize()</literal> dell'interfaccia verrà ignorato e verrà
     usato <link linkend="object.serialize">__serialize()</link> al suo posto.
    </para>
   </note>
   <para>
    L'uso previsto di <link linkend="object.serialize">__serialize()</link> è
    quello di definire una rappresentazione arbitraria dell'oggetto adatta alla
    serializzazione. Gli elementi dell'array possono corrispondere alle
    proprietà dell'oggetto, ma non è obbligatorio.
   </para>
   <para>
    Al contrario, <function>unserialize</function> verifica la presenza di una
    funzione con il nome magico
    <link linkend="object.unserialize">__unserialize()</link>. Se presente,
    a questa funzione verrà passato l'array ripristinato che era stato
    restituito da <link linkend="object.serialize">__serialize()</link>. Potrà
    quindi ripristinare le proprietà dell'oggetto da quell'array come
    appropriato.
   </para>
   <note>
    <para>
     Se sia <link linkend="object.unserialize">__unserialize()</link> che
     <link linkend="object.wakeup">__wakeup()</link> sono definiti nello stesso
     oggetto, solo <link linkend="object.unserialize">__unserialize()</link>
     verrà chiamato. <link linkend="object.wakeup">__wakeup()</link> verrà
     ignorato.
    </para>
   </note>
   <note>
    <para>
     Questa funzionalità è disponibile a partire da PHP 7.4.0.
    </para>
   </note>
   <example>
    <title>Serialize e unserialize</title>
    <programlisting role="php">
<![CDATA[
<?php
class Connection
{
    protected $link;
    private $dsn, $username, $password;

    public function __construct($dsn, $username, $password)
    {
        $this->dsn = $dsn;
        $this->username = $username;
        $this->password = $password;
        $this->connect();
    }

    private function connect()
    {
        $this->link = new PDO($this->dsn, $this->username, $this->password);
    }

    public function __serialize(): array
    {
        return [
          'dsn' => $this->dsn,
          'user' => $this->username,
          'pass' => $this->password,
        ];
    }

    public function __unserialize(array $data): void
    {
        $this->dsn = $data['dsn'];
        $this->username = $data['user'];
        $this->password = $data['pass'];

        $this->connect();
    }
}?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.tostring">
   <title><link linkend="object.tostring">__toString()</link></title>
   <methodsynopsis xml:id="object.tostring">
    <modifier>public</modifier> <type>string</type><methodname>__toString</methodname>
    <void/>
   </methodsynopsis>
   <para>
    Il metodo <link linkend="object.tostring">__toString()</link> permette a
    una classe di decidere come comportarsi quando viene trattata come una
    stringa. Ad esempio, cosa stamperà <literal>echo $obj;</literal>.
   </para>
   <warning>
    <para>
     A partire da PHP 8.0.0, il valore di ritorno segue la semantica standard
     dei tipi PHP, il che significa che verrà convertito in una
     <type>string</type> se possibile e se la
     <link linkend="language.types.declarations.strict">tipizzazione stretta</link>
     è disabilitata.
    </para>
    <para>
     Un oggetto <interfacename>Stringable</interfacename>
     <emphasis>non</emphasis> sarà accettato da una dichiarazione di tipo
     <type>string</type> se la
     <link linkend="language.types.declarations.strict">tipizzazione stretta</link>
     è abilitata. Se si desidera questo comportamento, la dichiarazione di tipo
     deve accettare <interfacename>Stringable</interfacename> e
     <type>string</type> tramite un tipo unione.
    </para>
    <para>
     A partire da PHP 8.0.0, qualsiasi classe che contiene un metodo
     <link linkend="object.tostring">__toString()</link> implementerà anche
     implicitamente l'interfaccia <interfacename>Stringable</interfacename>, e
     quindi supererà i controlli di tipo per quell'interfaccia. Si raccomanda
     comunque di implementare esplicitamente l'interfaccia.
    </para>
    <para>
     In PHP 7.4, il valore restituito <emphasis>deve</emphasis> essere una
     <type>string</type>, altrimenti viene lanciato un
     <classname>Error</classname>.
    </para>
    <para>
     Prima di PHP 7.4.0, il valore restituito <emphasis>deve</emphasis> essere
     una <type>string</type>, altrimenti viene emesso un errore fatale
     <constant>E_RECOVERABLE_ERROR</constant>.
    </para>
   </warning>
   <warning>
    <simpara>
     Non era possibile lanciare un'eccezione dall'interno di un metodo
     <link linkend="object.tostring">__toString()</link>
     prima di PHP 7.4.0. Farlo causava un errore fatale.
    </simpara>
   </warning>
   <example>
    <title>Esempio semplice</title>
    <programlisting role="php">
<![CDATA[
<?php
// Dichiara una classe semplice
class TestClass
{
    public $foo;

    public function __construct($foo)
    {
        $this->foo = $foo;
    }

    public function __toString()
    {
        return $this->foo;
    }
}

$class = new TestClass('Hello');
echo $class;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Hello
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.invoke">
   <title><link linkend="object.invoke">__invoke()</link></title>
   <methodsynopsis xml:id="object.invoke">
    <type>mixed</type><methodname>__invoke</methodname>
    <methodparam rep="repeat"><parameter>values</parameter></methodparam>
   </methodsynopsis>
   <para>
    Il metodo <link linkend="object.invoke">__invoke()</link> viene chiamato
    quando uno script tenta di chiamare un oggetto come una funzione.
   </para>
   <example>
    <title>Utilizzo di <link linkend="object.invoke">__invoke()</link></title>
    <programlisting role="php">
<![CDATA[
<?php
class CallableClass
{
    public function __invoke($x)
    {
        var_dump($x);
    }
}
$obj = new CallableClass;
$obj(5);
var_dump(is_callable($obj));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
int(5)
bool(true)
]]>
    </screen>
   </example>
   <example>
    <title>Utilizzo di <link linkend="object.invoke">__invoke()</link></title>
    <programlisting role="php">
<![CDATA[
<?php
class Sort
{
    private $key;

    public function __construct(string $key)
    {
        $this->key = $key;
    }

    public function __invoke(array $a, array $b): int
    {
        return $a[$this->key] <=> $b[$this->key];
    }
}

$customers = [
    ['id' => 1, 'first_name' => 'John', 'last_name' => 'Do'],
    ['id' => 3, 'first_name' => 'Alice', 'last_name' => 'Gustav'],
    ['id' => 2, 'first_name' => 'Bob', 'last_name' => 'Filipe']
];

// ordina i clienti per nome
usort($customers, new Sort('first_name'));
print_r($customers);

// ordina i clienti per cognome
usort($customers, new Sort('last_name'));
print_r($customers);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
    [0] => Array
        (
            [id] => 3
            [first_name] => Alice
            [last_name] => Gustav
        )

    [1] => Array
        (
            [id] => 2
            [first_name] => Bob
            [last_name] => Filipe
        )

    [2] => Array
        (
            [id] => 1
            [first_name] => John
            [last_name] => Do
        )

)
Array
(
    [0] => Array
        (
            [id] => 1
            [first_name] => John
            [last_name] => Do
        )

    [1] => Array
        (
            [id] => 2
            [first_name] => Bob
            [last_name] => Filipe
        )

    [2] => Array
        (
            [id] => 3
            [first_name] => Alice
            [last_name] => Gustav
        )

)
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.set-state">
   <title><link linkend="object.set-state">__set_state()</link></title>
   <methodsynopsis xml:id="object.set-state">
    <modifier>static</modifier> <type>object</type><methodname>__set_state</methodname>
    <methodparam><type>array</type><parameter>properties</parameter></methodparam>
   </methodsynopsis>
   <para>
    Questo metodo <link linkend="language.oop5.static">statico</link> viene
    chiamato per le classi esportate da <function>var_export</function>.
   </para>
   <para>
    L'unico parametro di questo metodo è un array contenente le proprietà
    esportate nella forma <literal>['property' => value, ...]</literal>.
   </para>
   <example>
    <title>Utilizzo di <link linkend="object.set-state">__set_state()</link></title>
    <programlisting role="php">
<![CDATA[
<?php

class A
{
    public $var1;
    public $var2;

    public static function __set_state($an_array)
    {
        $obj = new A;
        $obj->var1 = $an_array['var1'];
        $obj->var2 = $an_array['var2'];
        return $obj;
    }
}

$a = new A;
$a->var1 = 5;
$a->var2 = 'foo';

$b = var_export($a, true);
var_dump($b);
eval('$c = ' . $b . ';');
var_dump($c);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
string(60) "A::__set_state(array(
   'var1' => 5,
   'var2' => 'foo',
))"
object(A)#2 (2) {
  ["var1"]=>
  int(5)
  ["var2"]=>
  string(3) "foo"
}
]]>
    </screen>
   </example>
   <note>
    <simpara>
     Quando si esporta un oggetto, <function>var_export</function> non verifica
     se <link linkend="object.set-state">__set_state()</link> è implementato
     dalla classe dell'oggetto, quindi la reimportazione di oggetti risulterà
     in un'eccezione <classname>Error</classname>, se __set_state() non è
     implementato. In particolare, questo riguarda alcune classi interne.
    </simpara>
    <simpara>
     È responsabilità del programmatore verificare che vengano reimportati solo
     oggetti la cui classe implementa __set_state().
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="language.oop5.magic.debuginfo">
   <title><link linkend="object.debuginfo">__debugInfo()</link></title>
   <methodsynopsis xml:id="object.debuginfo">
    <type>array</type><methodname>__debugInfo</methodname>
    <void/>
   </methodsynopsis>
   <para>
    Questo metodo viene chiamato da <function>var_dump</function> durante il
    dump di un oggetto per ottenere le proprietà che devono essere mostrate. Se
    il metodo non è definito su un oggetto, verranno mostrate tutte le
    proprietà pubbliche, protette e private.
   </para>
   <example>
    <title>Utilizzo di <link linkend="object.debuginfo">__debugInfo()</link></title>
    <programlisting role="php">
<![CDATA[
<?php
class C {
    private $prop;

    public function __construct($val) {
        $this->prop = $val;
    }

    public function __debugInfo() {
        return [
            'propSquared' => $this->prop ** 2,
        ];
    }
}

var_dump(new C(42));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(C)#1 (1) {
  ["propSquared"]=>
  int(1764)
}
]]>
    </screen>
   </example>
  </sect2>
 </sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
