<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: Maintainer: lucalzetta Status: ready -->
<!-- $Revision$ -->
<appendix xml:id="filters" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Elenco dei filtri disponibili</title>
 <para>
  Quello che segue è un elenco di alcuni stream filters del linguaggio da usare con    
  <function>stream_filter_append</function>.
  La tua versione di PHP potrebbe avere un numero diverso di filtri di
  quelli elencati qui.
 </para>

 <para>
  C'è una piccola differenza di comportamento tra 
  <function>stream_filter_append</function>
  e <function>stream_filter_prepend</function>.  
  Ogni stream di PHP contiene un piccolo <emphasis>read buffer</emphasis>
  dove archivia i blocchi di dati ricevuti dal
  filesystem o altre risorse in modo tale di processare i dati
  nel modo più efficiente possibile. così come i dati sono inseriti
  dalla risorsa nel buffer interno allo stream, essi
  vengono immediatamente processati attraverso i filtri attaccati
  indipendentemente dal fatto che PHP sia pronto per ricevere
  altri dati oppure no.
  Se i dati si trovano nel read buffer quando un filtro è
  <emphasis>appended</emphasis>, questi dati vengono immediatamente
  processati attraverso questo filtro facendo si che il fatto
  che fossero nel buffer sia trasparente. Diversamente, se i dati
  si trovano nel read buffer quando un filtro è
  <emphasis>prepended</emphasis>, questi dati <emphasis>NON</emphasis>
  saranno processati dal filtro. Resteranno in attesa
  che il successivo blocco di dati sia disponibile prima di essere processati.
 </para>

 <para>
  Per ottenere una lista dei filtri installati sul tuo sistema
  è possibile usare la funzione <function>stream_get_filters</function>.
 </para>

 <section xml:id="filters.string">
  <title>String Filters</title>

  <simpara>
   Ognuno di questi filtri fa precisamente ciò che implica il suo nome e
   corrisponde al comportamento di una funzione di php per maneggiare le stringhe.
   Per ulteriori informazioni riguardo un filtro, far riferimento alla pagina del
   manuale della funzione corrispondente.
  </simpara>

  <section xml:id="filters.string.rot13">
   <title>string.rot13</title>
   <simpara>
    L'uso di questo filtro è equivalente a processare i dati dello stream
    attraverso la funzione <function>str_rot13</function>.
   </simpara>
   <example>
    <title>string.rot13</title>
    <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.rot13');
fwrite($fp, "This is a test.\n");
/* Outputs:  Guvf vf n grfg.   */
?>
]]>
    </programlisting>
   </example>
  </section>

  <section xml:id="filters.string.toupper">
   <title>string.toupper</title>
   <simpara>
    L'uso di questo filtro è equivalente a processare i dati dello stream
    attraverso la funzione <function>strtoupper</function>.
   </simpara>
   <example>
    <title>string.toupper</title>
    <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.toupper');
fwrite($fp, "This is a test.\n");
/* Outputs:  THIS IS A TEST.   */
?>
]]>
    </programlisting>
   </example>
  </section>

  <section xml:id="filters.string.tolower">
   <title>string.tolower</title>
   <simpara>
    L'uso di questo filtro è equivalente a processare i dati dello stream
    attraverso la funzione <function>strtolower</function>.
   </simpara>
   <example>
    <title>string.tolower</title>
    <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.tolower');
fwrite($fp, "This is a test.\n");
/* Outputs:  this is a test.   */
?>
]]>
    </programlisting>
   </example>
  </section>

  <section xml:id="filters.string.strip_tags">
   <title>string.strip_tags</title>
   <simpara>
    L'uso di questo filtro è equivalente a processare i dati dello stream
    attraverso la funzione <function>strip_tags</function>.
    Accetta uno o due parametri in due forme diverse:
    O come una stringa contenente una lista di tags simili al secondo parametro
    della funzione <function>strip_tags</function>,
    o come un array di nomi di tags.
   </simpara>
   <para>
    &warn.deprecated.feature-7-3-0;
   </para>
   <example>
    <title>string.strip_tags</title>
    <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, "<b><i><u>");
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, array('b','i','u'));
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */
?>
]]>
    </programlisting>
   </example>
  </section>
 </section>

 <section xml:id="filters.convert">
  <title>Conversion Filters</title>

  <simpara>
   Così come gli string.* filters, i convert.* filters eseguono azioni
   simili ai loro nomi.
   Per ulteriori informazioni riguardo un filtro, far riferimento alla pagina del
   manuale della funzione corrispondente.
  </simpara>

  <section xml:id="filters.convert.base64">
   <title>convert.base64-encode and convert.base64-decode</title>
   <simpara>
    L'uso di questo filtro è equivalente a processare i dati dello stream
    attraverso le funzioni <function>base64_encode</function> e <function>base64_decode</function>
    rispettivamente.
    <literal>convert.base64-encode</literal> supporta parametri passati come
    un array associativo. Se <parameter>line-length</parameter> è dato, l'output
    di base64 verrà suddiviso nel numero di caratteri di <parameter>line-length</parameter>.
    Se <parameter>line-break-chars</parameter> è dato, ogni
    elemento verrà delimitato dal acarattere del parametro. 
    Questi parametri generano lo stesso effetto dell'uso
    di <function>base64_encode</function> con <function>chunk_split</function>.
   </simpara>
   <example>
    <title>
     convert.base64-encode &amp;
     convert.base64-decode
    </title>
    <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode');
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBpcyBhIHRlc3QuCg==  */

$param = array('line-length' => 8, 'line-break-chars' => "\r\n");
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode', STREAM_FILTER_WRITE, $param);
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBp
          :  cyBhIHRl
          :  c3QuCg==  */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-decode');
fwrite($fp, "VGhpcyBpcyBhIHRlc3QuCg==");
fclose($fp);
/* Outputs:  This is a test.  */
?>
]]>
    </programlisting>
   </example>
  </section>

  <section xml:id="filters.covert.quoted-printable">
   <title>convert.quoted-printable-encode e convert.quoted-printable-decode</title>
   <simpara>
    L'uso della versione decode di questo filtro è equivalente a processare
    i dati dell stream attraverso la funzione <function>quoted_printable_decode</function>.
    Non ci sono funzioni equivalenti per <literal>convert.quoted-printable-encode</literal>.
    <literal>convert.quoted-printable-encode</literal> supporta parametri passati
    come un array associativo. Oltre ai parametri supportati da
    <literal>convert.base64-encode</literal>, <literal>convert.quoted-printable-encode</literal>
    supporta anche argomenti booleani: <parameter>binary</parameter> e
    <parameter>force-encode-first</parameter>.
    <literal>convert.base64-decode</literal> supporta solo 
    <parameter>line-break-chars</parameter> come parametro
    per suddividere l'input codificato.
   </simpara>
   <example>
    <title>
     convert.quoted-printable-encode &amp;
     convert.quoted-printable-decode
    </title>
    <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.quoted-printable-encode');
fwrite($fp, "This is a test.\n");
/* Outputs:  =This is a test.=0A  */
?>
]]>
    </programlisting>
   </example>
  </section>

  <section xml:id="filters.convert.iconv">
   <title>convert.iconv.*</title>
   <simpara>
    I filtri <literal>convert.iconv.*</literal> sono disponibili se
    il supporto <link linkend="book.iconv">iconv</link> è abilitato, e il 
    loro uso è equivalente a processare tutti i dati dello stream con <function>iconv</function>.
    Questi filtri non supportano parametri, ma si aspettano che la codifica dell'input
    e dell'outputoutput siano passate come una parte del nome del filtro, ad esempio 
    entrambi come 
    <literal>convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt;</literal> o 
    <literal>convert.iconv.&lt;input-encoding&gt;/&lt;output-encoding&gt;</literal>
    (entrambe le annotazioni sono semanticamente equivalenti).
   </simpara>

   <example>
    <title>convert.iconv.*</title>
    <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.iconv.utf-16le.utf-8');
fwrite($fp, "T\0h\0i\0s\0 \0i\0s\0 \0a\0 \0t\0e\0s\0t\0.\0\n\0");
fclose($fp);
/* Outputs: This is a test. */
?>
]]>
    </programlisting>
   </example>
  </section>
 </section>

 <section xml:id="filters.compression">
  <title>Compression Filters</title>

  <simpara>
   Mentre i <link linkend="wrappers.compression">Compression Wrappers</link>
   fanno in modo di generare files 
   gzip e bz2 compatibili con il filesystem locale, non permettono 
   una generica decompressione sui network streams, e non permettono neppure, 
   a partire da uno stream non compresso, di passare a uno compresso.  
   Per questo uso un compression filter può essere applicato ad ogni stream ogni volta che si vuole.
  </simpara>

  <note>
   <simpara>
    I compression filters <emphasis>not</emphasis> generano headers e chiusure
    usate da utilità a riga di comando come <literal>gzip</literal>. Esclusivamente
    comprimono e decomprimono le porzioni caricate dei dati dello stream.
   </simpara>
  </note>

  <section xml:id="filters.compression.zlib">
   <title>zlib.deflate and zlib.inflate</title>
   <simpara>
    <literal>zlib.deflate</literal> (compressione) e
    <literal>zlib.inflate</literal> (decompressione) sono implementazioni
    dei metodi di  compressione decritti in <link xlink:href="&url.rfc;1951">RFC 1951</link>.
    Il filtro <literal>deflate</literal> parte da tre parametri passati come
    un array associativo.  

    <parameter>level</parameter> l'intensità della compressione
    in una scala da 1 a 9. I numeri più alti generano pacchetti più piccoli
    al costo di un più lungo processo di elaborazione. Esistono due
    livelli speciali di compressione: 0 (per non eseguire nessuna compressione), 
    e -1 (valore interno di default per zlib), 6 è un valore predefinito.

    <parameter>window</parameter> è il logaritmo in base -2 del ciclo di compressione della finestra?.
    I valori più alti (da 15 a 32768 bytes) ottengono una maggiore 
    compressione usando più memoria di calcolo,
    mentre i valori più bassi (da 9 -- 512 bytes) ottengono una minore compressione 
    con meno dispendio di memoria di calcolo.
    Il valore di default di <parameter>window</parameter> è attualmente <constant>15</constant>.

    <parameter>memory</parameter> è una scala che indica quanta memoria dovrà essere allocata
    per la compressione (o decompressione).
    I valori validi vanno da 1 (minima allocazione) a 9 (massima allocazione).
    Allocare più o meno memoria impatta sulla velocità del processo e non
    sulle dimensioni dei pacchetti generati.
   </simpara>

   <note>
    <simpara>
     Siccome il livello di compressione è il parametro di uso
     più comune, può essere passato come unico valore (piuttosto che come elemento di un array).
    </simpara>
   </note>

   <simpara>
    i filtri di compressione zlib.* sono disponibili se il
    supporto a <link linkend="ref.zlib">zlib</link> è abilitato.
   </simpara>

   <example>
    <title>
     <literal>zlib.deflate</literal> e
     <literal>zlib.inflate</literal>
    </title>
    <programlisting role="php">
<![CDATA[
<?php
$params = array('level' => 6, 'window' => 15, 'memory' => 9);

$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, $params);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";
echo "The original text was:\n";
/* Use readfile and zlib.inflate to decompress on the fly */
readfile('php://filter/zlib.inflate/resource=test.deflated');

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.
The original text was:
This is a test.
This is only a test.
This is not an important string.

 */
?>
]]>
    </programlisting>
   </example>

   <example>
    <title>
     <literal>zlib.deflate</literal> simple
    </title>
    <programlisting role="php">
<![CDATA[
<?php
$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
/* Here "6" indicates compression level 6 */
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, 6);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.

 */
?>
]]>
    </programlisting>
   </example>
  </section>

  <section xml:id="filters.compression.bzip2">
   <title>bzip2.compress e bzip2.decompress</title>
   <simpara>
    <literal>bzip2.compress</literal> e
    <literal>bzip2.decompress</literal>
    lavorano allo stesso modo dei filtri zlib descritti prima.

    Il fitro <literal>bzip2.compress</literal> accetta due parametri
    passati come elementi di un array associativo: 

    <parameter>blocks</parameter> è un valore intero
    da 1 a 9 che specifica il numero di blocchi da 100kbyte di memoria
    da allocare per il processo. 

    <parameter>work</parameter> è anch'esso un valore intero compreso tra
    0 e 250 che indica quante risorse usare per portare a termine il lavoro
    con un rapporto di compressione normale prima di recedere ad uno minore 
    ma più sostenibile per il sistema. La modifica di questo parametro
    ha effetti solo sulla velocità del processo. Ne la dimensione dell'output
    ne l'uso di memoria sono condizionati da questo parametro.
    Un fattore di work di 0 fa usare alla libreria bzip il valore di default
    per il sistema in uso.   

    Il filtro <literal>bzip2.decompress</literal> accetta solo un parametro,
    che può essere passato o come un valore booleano, o come 
    <parameter>small</parameter> elemento di un array associativo.

    <parameter>small</parameter>, quando è impostato a &true; istruisce 
    la libreria bzip di eseguire la decompressione col minimo dispendio
    di memoria a discapito della velocità.
   </simpara>

   <simpara>
     I filtri bzip2.* sono disponibili se il supporto
     <link linkend="ref.bzip2">bz2</link> è abilitato.
   </simpara>

   <example>
    <title>
     <literal>bzip2.compress</literal> e
     <literal>bzip2.decompress</literal>
    </title>
    <programlisting role="php">
<![CDATA[
<?php
$param = array('blocks' => 9, 'work' => 0);

echo "The original file is " . filesize('LICENSE') . " bytes long.\n";

$fp = fopen('LICENSE.compressed', 'w');
stream_filter_append($fp, 'bzip2.compress', STREAM_FILTER_WRITE, $param);
fwrite($fp, file_get_contents('LICENSE'));
fclose($fp);

echo "The compressed file is " . filesize('LICENSE.compressed') . " bytes long.\n";

/* Generates output:

The original text is 3288 characters long.
The compressed file is 1488 bytes long.

 */
?>
]]>
    </programlisting>
   </example>
  </section>
  </section>

 <section xml:id="filters.encryption">
  <title>Encryption Filters</title>

  <para>
    I filtri Encryption hanno un uso familiare per la crittografia di file o stream.
  </para>

  <section xml:id="filters.encryption.mcrypt">
   <title>mcrypt.* e mdecrypt.*</title>
   <para>
     &warn.deprecated.feature-7-1-0;
   </para>

   <simpara>
    <literal>mcrypt.*</literal> e <literal>mdecrypt.*</literal>
    Eseguono una criptazione e decriptazione simmetrica usando libmcrypt.
    Entrambi questi set di filtri supportano gli stessi algoritmi
    disponibili a <link linkend="ref.mcrypt">mcrypt extension</link> nella forma di
    <literal>mcrypt.ciphername</literal> dove <parameter>ciphername</parameter>
    è il nome della cifratura come deve essere passato a 
    <function>mcrypt_module_open</function>.
    I seguenti cinque parametri per i filtri sono disponibili:
   </simpara>

   <para>
    <table>
     <title>mcrypt filter parameters</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Parameter</entry>
        <entry>Required?</entry>
        <entry>Default</entry>
        <entry>Sample Values</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>mode</entry>
        <entry>Optional</entry>
        <entry>cbc</entry>
        <entry>cbc, cfb, ecb, nofb, ofb, stream</entry>
       </row>
       <row>
        <entry>algorithms_dir</entry>
        <entry>Optional</entry>
        <entry>ini_get('mcrypt.algorithms_dir')</entry>
        <entry>Location of algorithms modules</entry>
       </row>
       <row>
        <entry>modes_dir</entry>
        <entry>Optional</entry>
        <entry>ini_get('mcrypt.modes_dir')</entry>
        <entry>Location of modes modules</entry>
       </row>
       <row>
        <entry>iv</entry>
        <entry>Required</entry>
        <entry>N/A</entry>
        <entry>Typically 8, 16, or 32 bytes of binary data.  Depends on cipher</entry>
       </row>
       <row>
        <entry>key</entry>
        <entry>Required</entry>
        <entry>N/A</entry>
        <entry>Typically 8, 16, or 32 bytes of binary data.  Depends on cipher</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>

   <example>
    <title>Criptazione/decriptazione con Blowfish</title>
    <programlisting role="php">
<![CDATA[
<?php
//$key si assume sia stata generata precedentemente
$iv_size = mcrypt_get_iv_size(MCRYPT_BLOWFISH, MCRYPT_MODE_CBC);
$iv = mcrypt_create_iv($iv_size, MCRYPT_DEV_URANDOM);
$fp = fopen('encrypted-file.enc', 'wb');
fwrite($fp, $iv);
$opts = array('mode'=>'cbc','iv'=>$iv, 'key'=>$key);
stream_filter_append($fp, 'mcrypt.blowfish', STREAM_FILTER_WRITE, $opts);
fwrite($fp, 'message to encrypt');
fclose($fp);

//decriptazione...
$fp = fopen('encrypted-file.enc', 'rb');
$iv = fread($fp, $iv_size = mcrypt_get_iv_size(MCRYPT_BLOWFISH, MCRYPT_MODE_CBC));
$opts = array('mode'=>'cbc','iv'=>$iv, 'key'=>$key)
stream_filter_append($fp, 'mdecrypt.blowfish', STREAM_FILTER_READ, $opts);
$data = rtrim(stream_get_contents($fp));//trims off null padding
fclose($fp);
echo $data;
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Criptare un file usando AES-128 CBC with SHA256 HMAC</title>
    <programlisting role="php">
<![CDATA[
<?php
AES_CBC::encryptFile($password, "plaintext.txt", "encrypted.enc");
AES_CBC::decryptFile($password, "encrypted.enc", "decrypted.txt");

class AES_CBC
{
   protected static $KEY_SIZES = array('AES-128'=>16,'AES-192'=>24,'AES-256'=>32);
   protected static function key_size() { return self::$KEY_SIZES['AES-128']; } //default AES-128
   public static function encryptFile($password, $input_stream, $aes_filename){
      $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
      $fin = fopen($input_stream, "rb");
      $fc = fopen($aes_filename, "wb+");
      if (!empty($fin) && !empty($fc)) {
         fwrite($fc, str_repeat("_", 32) );//il segnaposto, SHA256 HMAC andrà qui più tardi
         fwrite($fc, $hmac_salt = mcrypt_create_iv($iv_size, MCRYPT_DEV_URANDOM));
         fwrite($fc, $esalt = mcrypt_create_iv($iv_size, MCRYPT_DEV_URANDOM));
         fwrite($fc, $iv = mcrypt_create_iv($iv_size, MCRYPT_DEV_URANDOM));
         $ekey = hash_pbkdf2("sha256", $password, $esalt, $it=1000, self::key_size(), $raw=true);
         $opts = array('mode'=>'cbc', 'iv'=>$iv, 'key'=>$ekey);
         stream_filter_append($fc, 'mcrypt.rijndael-128', STREAM_FILTER_WRITE, $opts);
         $infilesize = 0;
         while (!feof($fin)) {
            $block = fread($fin, 8192);
            $infilesize+=strlen($block);
            fwrite($fc, $block);
         }
         $block_size = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
         $padding = $block_size - ($infilesize % $block_size);//$padding è un numero da 1-16
         fwrite($fc, str_repeat(chr($padding), $padding) );//esegue il riempimento di PKCS7 
         fclose($fin);
         fclose($fc);
         $hmac_raw = self::calculate_hmac_after_32bytes($password, $hmac_salt, $aes_filename);
         $fc = fopen($aes_filename, "rb+");
         fwrite($fc, $hmac_raw);//overwrite placeholder
         fclose($fc);
      }
   }
   public static function decryptFile($password, $aes_filename, $out_stream) {
      $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
      $hmac_raw = file_get_contents($aes_filename, false, NULL,  0, 32);
      $hmac_salt = file_get_contents($aes_filename, false, NULL, 32, $iv_size);
      $hmac_calc = self::calculate_hmac_after_32bytes($password, $hmac_salt, $aes_filename);
      $fc = fopen($aes_filename, "rb");
      $fout = fopen($out_stream, 'wb');
      if (!empty($fout) && !empty($fc) && self::hash_equals($hmac_raw,$hmac_calc)) {
         fread($fc, 32+$iv_size);//skip sha256 hmac and salt
         $esalt = fread($fc, $iv_size);
         $iv    = fread($fc, $iv_size);
         $ekey = hash_pbkdf2("sha256", $password, $esalt, $it=1000, self::key_size(), $raw=true);
         $opts = array('mode'=>'cbc', 'iv'=>$iv, 'key'=>$ekey);
         stream_filter_append($fc, 'mdecrypt.rijndael-128', STREAM_FILTER_READ, $opts);
         while (!feof($fc)) {
            $block = fread($fc, 8192);
            if (feof($fc)) {
               $padding = ord($block[strlen($block) - 1]);//assume PKCS7 padding
               $block = substr($block, 0, 0-$padding);
            }
            fwrite($fout, $block);
         }
         fclose($fout);
         fclose($fc);
      }
   }
   private static function hash_equals($str1, $str2) {
      if(strlen($str1) == strlen($str2)) {
         $res = $str1 ^ $str2;
         for($ret=0,$i = strlen($res) - 1; $i >= 0; $i--) $ret |= ord($res[$i]);
         return !$ret;
      }
      return false;
   }
   private static function calculate_hmac_after_32bytes($password, $hsalt, $filename) {
      static $init=0;
      $init or $init = stream_filter_register("user-filter.skipfirst32bytes", "FileSkip32Bytes");
      $stream = 'php://filter/read=user-filter.skipfirst32bytes/resource=' . $filename;
      $hkey = hash_pbkdf2("sha256", $password, $hsalt, $iterations=1000, 24, $raw=true);
      return hash_hmac_file('sha256', $stream, $hkey, $raw=true);
   }
}
class FileSkip32Bytes extends php_user_filter
{
   private $skipped=0;
   function filter($in, $out, &$consumed, $closing)  {
      while ($bucket = stream_bucket_make_writeable($in)) {
         $outlen = $bucket->datalen;
         if ($this->skipped<32){
            $outlen = min($bucket->datalen,32-$this->skipped);
            $bucket->data = substr($bucket->data, $outlen);
            $bucket->datalen = $bucket->datalen-$outlen;
            $this->skipped+=$outlen;
         }
         $consumed += $outlen;
         stream_bucket_append($out, $bucket);
      }
      return PSFS_PASS_ON;
   }
}
class AES_128_CBC extends AES_CBC {
   protected static function key_size() { return self::$KEY_SIZES['AES-128']; }
}
class AES_192_CBC extends AES_CBC {
   protected static function key_size() { return self::$KEY_SIZES['AES-192']; }
}
class AES_256_CBC extends AES_CBC {
   protected static function key_size() { return self::$KEY_SIZES['AES-256']; }
}
]]>
    </programlisting>
   </example>
  </section>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
