<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 70f392045a26b176f206013f00fa14b86440efd1 Maintainer: lacatoire Status: ready -->
 <sect1 xml:id="language.oop5.serialization" xmlns="http://docbook.org/ns/docbook">
  <title>Serializzazione degli oggetti - oggetti nelle sessioni</title>
  <titleabbrev>Serializzazione degli oggetti</titleabbrev>

  <para>
   <function>serialize</function> restituisce una stringa contenente una
   rappresentazione in flusso di byte di qualsiasi valore che può essere memorizzato in
   PHP. <function>unserialize</function> può utilizzare questa stringa per
   ricreare i valori originali delle variabili. Utilizzando serialize per
   salvare un oggetto si salveranno tutte le variabili nell'oggetto. I
   metodi nell'oggetto non verranno salvati, solo il nome della
   classe.
  </para>

  <para>
   Per poter deserializzare un oggetto con <function>unserialize</function>,
   la classe di quell'oggetto deve essere definita. Ovvero, se si ha un oggetto
   della classe A e lo si serializza, si otterrà
   una stringa che fa riferimento alla classe A e contiene tutti i valori delle variabili
   contenute in essa. Per poter deserializzare
   questo in un altro file, un oggetto della classe A, la
   definizione della classe A deve essere presente in quel file.
   Questo può essere fatto, ad esempio, memorizzando la definizione della classe A
   in un file di inclusione e includendo questo file o utilizzando la
   funzione <function>spl_autoload_register</function>.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// A.php:

  class A {
      public $one = 1;

      public function show_one() {
          echo $this->one;
      }
  }

// page1.php:

  include "A.php";

  $a = new A;
  $s = serialize($a);
  // memorizza $s dove page2.php può trovarlo.
  file_put_contents('store', $s);

// page2.php:

  // questo è necessario perché unserialize funzioni correttamente.
  include "A.php";

  $s = file_get_contents('store');
  $a = unserialize($s);

  // ora usa la funzione show_one() dell'oggetto $a.
  $a->show_one();
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Se un'applicazione serializza oggetti per un uso successivo, si raccomanda
   vivamente di includere la definizione della classe per quell'oggetto
   in tutta l'applicazione. Non farlo potrebbe risultare in un oggetto
   deserializzato senza una definizione di classe, il che porterà PHP ad
   assegnare all'oggetto la classe <classname>__PHP_Incomplete_Class_Name</classname>,
   che non ha metodi e renderebbe l'oggetto inutilizzabile.
  </para>

  <para>
   Quindi, se nell'esempio precedente <varname>$a</varname> diventasse parte di una sessione
   aggiungendo una nuova chiave all'array superglobale <varname>$_SESSION</varname>, è necessario includere il
   file <literal>A.php</literal> in tutte le pagine, non solo in <filename>page1.php</filename>
   e <filename>page2.php</filename>.
  </para>

  <para>
   Oltre al consiglio precedente, si noti che è possibile anche agganciarsi agli eventi di serializzazione
   e deserializzazione su un oggetto utilizzando i metodi
   <link linkend="object.sleep">__sleep()</link> e
   <link linkend="object.wakeup">__wakeup()</link>. L'utilizzo di
   <link linkend="object.sleep">__sleep()</link> permette anche di serializzare solo
   un sottoinsieme delle proprietà dell'oggetto.
  </para>
 </sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
