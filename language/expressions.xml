<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: f4f96ef8b2a95283c92ea2183fe1dedf06f3ad22 Maintainer: lacatoire Status: ready -->
 <chapter xml:id="language.expressions" xmlns="http://docbook.org/ns/docbook">
   <title>Espressioni</title>
   <simpara>
    Le espressioni sono i blocchi costruttivi più importanti di PHP. In PHP,
    quasi tutto ciò che si scrive è un'espressione. Il modo più semplice e al
    tempo stesso più accurato per definire un'espressione è "tutto ciò che ha un
    valore".
   </simpara>
   <simpara>
    Le forme più basilari di espressioni sono le costanti e le variabili.
    Quando si scrive <code>$a = 5</code>, si assegna <code>5</code> a
    <varname>$a</varname>. <code>5</code>, ovviamente,
    ha il valore 5, o in altre parole <code>5</code> è un'espressione con il
    valore 5 (in questo caso, <code>5</code> è una costante intera).
   </simpara>
   <simpara>
    Dopo questa assegnazione, ci si aspetta che il valore di <varname>$a</varname> sia 5,
    quindi scrivendo <code>$b = $a</code>, ci si aspetta che si comporti come
    se si fosse scritto <code>$b = 5</code>. In altre parole, <varname>$a</varname> è un'espressione con il
    valore 5 anch'essa. Se tutto funziona correttamente, è esattamente
    ciò che accadrà.
   </simpara>
   <para>
    Esempi leggermente più complessi di espressioni sono le funzioni. Per
    esempio, si consideri la seguente funzione:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo ()
{
    return 5;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Presupponendo familiarità con il concetto di funzioni (in caso contrario,
    si consulti il capitolo sulle <link
    linkend="language.functions">funzioni</link>), si presume
    che scrivere <code>$c = foo()</code> sia essenzialmente come
    scrivere <code>$c = 5</code>, e questo è corretto. Le funzioni
    sono espressioni con il valore del loro valore di ritorno. Poiché <code>foo()</code>
    restituisce 5, il valore dell'espressione '<code>foo()</code>' è 5. Di solito
    le funzioni non restituiscono semplicemente un valore statico ma calcolano qualcosa.
   </simpara>
   <simpara>
    Naturalmente, i valori in PHP non devono necessariamente essere interi, e molto spesso
    non lo sono. PHP supporta quattro tipi di valori scalari: valori <type>int</type>,
    valori a virgola mobile (<type>float</type>), valori <type>string</type>
    e valori <type>bool</type> (i valori scalari sono valori che non possono
    essere "suddivisi" in parti più piccole, a differenza degli array, per esempio). PHP supporta anche
    due tipi compositi (non scalari): array e oggetti. Ciascuno di
    questi tipi di valore può essere assegnato a variabili o restituito da funzioni.
   </simpara>
   <simpara>
    PHP porta le espressioni molto oltre, nello stesso modo in cui lo fanno molti altri linguaggi.
    PHP è un linguaggio orientato alle espressioni, nel
    senso che quasi tutto è un'espressione. Si consideri
    l'esempio già trattato, <code>$a = 5</code>. È facile vedere che
    ci sono due valori coinvolti, il valore della costante
    intera <code>5</code> e il valore di <varname>$a</varname> che viene aggiornato a 5
    anch'esso. Ma la verità è che c'è un valore aggiuntivo coinvolto,
    ed è il valore dell'assegnazione stessa. L'assegnazione
    stessa restituisce il valore assegnato, in questo caso 5.
    In pratica, significa che <code>$a = 5</code>, indipendentemente da ciò che fa,
    è un'espressione con il valore 5. Pertanto, scrivere qualcosa come
    <code>$b = ($a = 5)</code> è come scrivere
    <code>$a = 5; $b = 5;</code> (un punto e virgola
    segna la fine di un'istruzione). Poiché le assegnazioni sono analizzate da
    destra a sinistra, è anche possibile scrivere <code>$b = $a = 5</code>.
   </simpara>
   <simpara>
    Un altro buon esempio di orientamento alle espressioni è il pre- e
    post-incremento e decremento. Gli utenti di PHP e di molti altri
    linguaggi possono avere familiarità con la notazione <code>variable++</code> e
    <code>variable--</code>. Questi sono gli <link linkend="language.operators.increment">
    operatori di incremento e decremento</link>. In PHP, come in C, ci
    sono due tipi di incremento - il pre-incremento e il post-incremento.
    Sia il pre-incremento che il post-incremento incrementano essenzialmente la
    variabile, e l'effetto sulla variabile è identico. La
    differenza sta nel valore dell'espressione di incremento.
    Il pre-incremento, che si scrive <code>++$variable</code>, restituisce il
    valore incrementato (PHP incrementa la variabile prima di leggerne il
    valore, da cui il nome 'pre-incremento'). Il post-incremento, che si
    scrive <code>$variable++</code>, restituisce il valore originale di
    <varname>$variable</varname>, prima che venga incrementato (PHP incrementa la variabile
    dopo averne letto il valore, da cui il nome 'post-incremento').
   </simpara>
   <simpara>
    Un tipo molto comune di espressioni sono le espressioni di <link
    linkend="language.operators.comparison">confronto</link>.
    Queste espressioni restituiscono &false; o &true;. PHP
    supporta &gt; (maggiore di), &gt;= (maggiore o uguale a), == (uguale),
    != (diverso), &lt; (minore di) e &lt;= (minore o uguale a).
    Il linguaggio supporta anche un insieme di operatori di equivalenza stretta: ===
    (uguale a e dello stesso tipo) e !== (diverso da o non dello stesso tipo).
    Queste espressioni sono più comunemente utilizzate all'interno dell'esecuzione condizionale,
    come le istruzioni <code>if</code>.
   </simpara>
   <simpara>
    L'ultimo esempio di espressioni qui trattato riguarda le espressioni combinate
    operatore-assegnazione. È già noto che per
    incrementare <varname>$a</varname> di 1, è sufficiente scrivere
    <code>$a++</code> o <code>++$a</code>.
    Ma cosa fare per aggiungere più di uno, per esempio 3?
    Si potrebbe scrivere <code>$a++</code> più volte, ma questo
    non è ovviamente un modo molto efficiente o comodo. Una pratica molto più
    comune è scrivere <code>$a =
    $a + 3</code>. <code>$a + 3</code> restituisce
    il valore di <varname>$a</varname> più 3, e viene riassegnato
    a <varname>$a</varname>, il che comporta l'incremento di <varname>$a</varname>
    di 3. In PHP, come in diversi altri linguaggi come il C, è possibile scriverlo
    in modo più breve, che con il tempo diventerà più chiaro e rapido da
    comprendere. Aggiungere 3 al valore corrente di <varname>$a</varname>
    può essere scritto <code>$a += 3</code>. Questo significa esattamente
    "prendi il valore di <varname>$a</varname>, aggiungi 3, e riassegnalo
    a <varname>$a</varname>". Oltre ad essere più breve e
    più chiaro, questo produce anche un'esecuzione più veloce. Il valore di
    <code>$a += 3</code>, come il valore di un'assegnazione normale, è
    il valore assegnato. Da notare che NON è 3, ma il valore combinato
    di <varname>$a</varname> più 3 (questo è il valore che viene
    assegnato a <varname>$a</varname>). Qualsiasi operatore binario può essere usato
    in questa modalità operatore-assegnazione, per esempio <code>$a -= 5</code>
    (sottrae 5 dal valore di <varname>$a</varname>), <code>$b *= 7</code>
    (moltiplica il valore di <varname>$b</varname> per 7), ecc.
   </simpara>
   <para>
    C'è un'altra espressione che può sembrare strana se non è stata incontrata
    in altri linguaggi, l'operatore condizionale ternario:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$first ? $second : $third
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Se il valore della prima sottoespressione è &true; (diverso da zero), allora
    la seconda sottoespressione viene valutata, e quello è il risultato
    dell'espressione condizionale. Altrimenti, la terza sottoespressione viene
    valutata, e quello è il valore.
   </para>
   <para>
    Il seguente esempio dovrebbe aiutare a comprendere meglio il pre- e
    post-incremento e le espressioni in generale:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function double($i)
{
    return $i*2;
}
$b = $a = 5;        /* assegna il valore cinque alle variabili $a e $b */
$c = $a++;          /* post-incremento, assegna il valore originale di $a
                       (5) a $c */
$e = $d = ++$b;     /* pre-incremento, assegna il valore incrementato di
                       $b (6) a $d e $e */

/* a questo punto, sia $d che $e sono uguali a 6 */

$f = double($d++);  /* assegna il doppio del valore di $d prima
                       dell'incremento, 2*6 = 12 a $f */
$g = double(++$e);  /* assegna il doppio del valore di $e dopo
                       l'incremento, 2*7 = 14 a $g */
$h = $g += 10;      /* prima, $g viene incrementato di 10 e raggiunge il
                       valore di 24. il valore dell'assegnazione (24) viene
                       poi assegnato a $h, e $h raggiunge il valore
                       di 24 anch'esso. */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Alcune espressioni possono essere considerate come istruzioni. In
    questo caso, un'istruzione ha la forma '<code>expr ;</code>' cioè, un'espressione
    seguita da un punto e virgola. In <code>$b = $a = 5;</code>,
    <code>$a = 5</code> è un'espressione valida, ma non è un'istruzione
    di per sé. <code>$b = $a = 5;</code>, invece, è un'istruzione valida.
   </simpara>
   <simpara>
    Un'ultima cosa degna di nota è il valore di verità delle espressioni.
    In molte situazioni, principalmente nell'esecuzione condizionale e nei cicli, non
    interessa il valore specifico dell'espressione, ma solo
    se significa &true; o &false;.

    <!-- (PHP doesn't have a
    dedicated boolean type) : WRONG, PHP does. -->

    Le costanti &true; e &false; (senza distinzione tra maiuscole e minuscole) sono i due
    possibili valori booleani. Quando necessario, un'espressione viene
    automaticamente convertita in booleano. Si consulti la
    <link linkend="language.types.typecasting">sezione sul
    type-casting</link> per i dettagli.
   </simpara>
   <simpara>
    PHP fornisce un'implementazione completa e potente delle espressioni, e
    documentarla interamente va oltre lo scopo di questo manuale. Gli
    esempi precedenti dovrebbero dare una buona idea di cosa sono le espressioni
    e di come costruire espressioni utili. Nel resto di questo manuale si scriverà
    <varname>expr</varname> per indicare qualsiasi espressione PHP valida.
   </simpara>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
