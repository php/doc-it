<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: d6f54016d62904cfd8200604aadd5e3f0d9bad97 Maintainer: lacatoire Status: ready -->
<sect1 xml:id="language.oop5.anonymous" xmlns="http://docbook.org/ns/docbook">
 <title>Classi anonime</title>

 <para>
  Le classi anonime sono utili quando è necessario creare oggetti semplici e utilizzati una sola volta.
 </para>

 <informalexample>
  <programlisting role="php">
<![CDATA[
<?php

// Utilizzo di una classe esplicita
class Logger
{
    public function log($msg)
    {
        echo $msg;
    }
}

$util->setLogger(new Logger());

// Utilizzo di una classe anonima
$util->setLogger(new class {
    public function log($msg)
    {
        echo $msg;
    }
});
]]>
  </programlisting>
 </informalexample>

 <para>
  Possono passare argomenti ai loro costruttori, estendere altre classi,
  implementare interfacce e usare trait proprio come una classe normale:
 </para>

 <informalexample>
  <programlisting role="php">
<![CDATA[
<?php

class SomeClass {}
interface SomeInterface {}
trait SomeTrait {}

var_dump(new class(10) extends SomeClass implements SomeInterface {
    private $num;

    public function __construct($num)
    {
        $this->num = $num;
    }

    use SomeTrait;
});
]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
object(class@anonymous)#1 (1) {
  ["Command line code0x104c5b612":"class@anonymous":private]=>
  int(10)
}
]]>
  </screen>
 </informalexample>

 <para>
  Annidare una classe anonima all'interno di un'altra classe non le dà accesso
  ai metodi o alle proprietà private o protette di quella classe esterna. Per
  utilizzare le proprietà o i metodi protetti della classe esterna, la classe anonima
  può estendere la classe esterna. Per utilizzare le proprietà private della
  classe esterna nella classe anonima, devono essere passate attraverso il suo
  costruttore:
 </para>

 <informalexample>
  <programlisting role="php">
<![CDATA[
<?php

class Outer
{
    private $prop = 1;
    protected $prop2 = 2;

    protected function func1()
    {
        return 3;
    }

    public function func2()
    {
        return new class($this->prop) extends Outer {
            private $prop3;

            public function __construct($prop)
            {
                $this->prop3 = $prop;
            }

            public function func3()
            {
                return $this->prop2 + $this->prop3 + $this->func1();
            }
        };
    }
}

echo (new Outer)->func2()->func3();
]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
6
]]>
  </screen>
 </informalexample>

 <para>
  Tutti gli oggetti creati dalla stessa dichiarazione di classe anonima sono istanze
  di quella stessa classe.
 </para>

 <informalexample>
  <programlisting role="php">
<![CDATA[
<?php
function anonymous_class()
{
    return new class {};
}

if (get_class(anonymous_class()) === get_class(anonymous_class())) {
    echo 'same class';
} else {
    echo 'different class';
}]]>
 </programlisting>
 &example.outputs;
 <screen>
<![CDATA[
same class
]]>
  </screen>
 </informalexample>

 <note>
  <para>
   Le classi anonime ricevono un nome assegnato dal motore, come
   dimostrato nell'esempio seguente. Questo nome deve essere considerato un
   dettaglio implementativo, su cui non si dovrebbe fare affidamento.
  </para>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo get_class(new class {});
]]>
   </programlisting>
  &example.outputs.similar;
  <screen>
<![CDATA[
class@anonymous/in/oNi1A0x7f8636ad2021
]]>
   </screen>
  </informalexample>
 </note>

 <sect2 xml:id="language.oop5.anonymous.readonly">
  <title>Classi anonime readonly</title>
  <simpara>
   A partire da PHP 8.3.0, il modificatore <literal>readonly</literal> può
   essere applicato alle classi anonime.
  </simpara>
  <example xml:id="language.oop5.anonymous.readonly.example">
   <title>Definizione di una classe anonima readonly</title>
   <programlisting role="php">
    <![CDATA[
<?php
// Utilizzo di una classe anonima
var_dump(new readonly class('[DEBUG]') {
    public function __construct(private string $prefix)
    {
    }

    public function log($msg)
    {
        echo $this->prefix . ' ' . $msg;
    }
});
]]>
   </programlisting>
  </example>
 </sect2>
</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
