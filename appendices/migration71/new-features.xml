<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 459c0e1de40c71062731abb431ec1c9f74b2aaf2 Maintainer: lucalzetta Status: ready -->
<!-- $Revision$ -->

<sect1 xml:id="migration71.new-features" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Nuove caratteristiche</title>

 <sect2 xml:id="migration71.new-features.nullable-types">
  <title>Nullable types</title>

  <para>
   Dichiarazioni di tipi per parametri e valori di ritorno
   ora possono essere marcati come nullable anteponendo al
   loro nome un punto di domanda. Questo significa che il tipo
   &null; può essere passato come argomento o ritornato come
   valore rispettivamente.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

function testReturn(): ?string
{
    return 'elePHPant';
}

var_dump(testReturn());

function testReturn(): ?string
{
    return null;
}

var_dump(testReturn());

function test(?string $name)
{
    var_dump($name);
}

test('elePHPant');
test(null);
test();
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
string(10) "elePHPant"
NULL
string(10) "elePHPant"
NULL
Uncaught Error: Too few arguments to function test(), 0 passed in...
]]>
   </screen>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration71.new-features.void-functions">
  <title>Void functions</title>

  <para>
   E' stato introdotto il ritorno di un tipo <type>void</type>.
   Le funzioni dichiarate con un tipo di ritorno <type>void</type>
   devono in ogni caso omettere lo statement return o usare
   uno statement return vuoto. &null; non è un ritorno valido
   per una funzione void.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function swap(&$left, &$right): void
{
    if ($left === $right) {
        return;
    }

    $tmp = $left;
    $left = $right;
    $right = $tmp;
}

$a = 1;
$b = 2;
var_dump(swap($a, $b), $a, $b);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
null
int(2)
int(1)
]]>
   </screen>
  </informalexample>

  <para>
   Il tentativo di usare una funzione con un valore di
   ritorno void verrà semplicemente valutato come &null;,
   senza l'emissione di allarmi. La ragione di ciò è che
   l'emissione di un warning implica l'uso di funzioni generiche 
   di ordine superiore.
  </para>
 </sect2>

 <sect2 xml:id="migration71.new-features.symmetric-array-destructuring">
  <title>Destrutturazione simmetrica degli array</title>

  <para>
   La notazione semplificata per gli array (<literal>[]</literal>) 
   ora può essere usata per destrutturare array per assegnamento
   (includendo anche <literal>foreach</literal>), 
   come alternativa all'elenco della sintassi esistente
   che è ancora supportata.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$data = [
    [1, 'Tom'],
    [2, 'Fred'],
];

// list() style
list($id1, $name1) = $data[0];

// [] style
[$id1, $name1] = $data[0];

// list() style
foreach ($data as list($id, $name)) {
    // logic here with $id and $name
}

// [] style
foreach ($data as [$id, $name]) {
    // logic here with $id and $name
}
]]>
   </programlisting>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration71.new-features.class-constant-visibility">
  <title>Visibilità delle costanti di classe</title>

  <para>
   E' stato aggiunto il supporto per specificare la visibilità delle costanti di classe.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class ConstDemo
{
    const PUBLIC_CONST_A = 1;
    public const PUBLIC_CONST_B = 2;
    protected const PROTECTED_CONST = 3;
    private const PRIVATE_CONST = 4;
}
]]>
   </programlisting>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration71.new-features.iterable-pseudo-type">
  <title><type>iterable</type> pseudo-type</title>

  <para>
   Un nuovo pseudo tipo (simile a <type>callable</type>) chiamato
   <type>iterable</type> è stato introdotto. Può essere usato
   con i tipi parametro e i tipi di ritorno, accetta sia array
   che oggetti che implementano l'interfaccia <classname>Traversable</classname>.
   
   
   interface. With respect to subtyping,
   parameter types of child classes may broaden a parent's declaration of <type>array</type> 
   or <classname>Traversable</classname> to <type>iterable</type>. With return types,
   child classes may narrow a parent's return type of <type>iterable</type> to
   <type>array</type> or an object that implements <classname>Traversable</classname>.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function iterator(iterable $iter)
{
    foreach ($iter as $val) {
        //
    }
}
]]>
   </programlisting>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration71.new-features.mulit-catch-exception-handling">
  <title>Elaborazione di eccezioni multiple</title>

  <para>
   Possono essere specificate eccezioni multiple per 
   ogni blocco catch usando il carattere pipe 
   (<literal>|</literal>). Questo è utile quando
   da diverse gerarchie di classi può essere necessario
   elaborare eccezioni di tipo diverso.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
try {
    // some code
} catch (FirstException | SecondException $e) {
    // handle first and second exceptions
}
]]>
   </programlisting>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration71.new-features.support-for-keys-in-list">
  <title>Supporto per le chiavi in <function>list</function></title>

  <para>
   Ora è possibile specificare le chiavi in una <function>list</function>,
   o nella sua forma sintattica abbreviata <literal>[]</literal>. 
   Questo permette la destrutturazione di array con
   chiavi non sequenziali o costituite da non-integer.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$data = [
    ["id" => 1, "name" => 'Tom'],
    ["id" => 2, "name" => 'Fred'],
];

// list() style
list("id" => $id1, "name" => $name1) = $data[0];

// [] style
["id" => $id1, "name" => $name1] = $data[0];

// list() style
foreach ($data as list("id" => $id, "name" => $name)) {
    // logic here with $id and $name
}

// [] style
foreach ($data as ["id" => $id, "name" => $name]) {
    // logic here with $id and $name
}
]]>
   </programlisting>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration71.new-features.support-for-negative-string-offsets">
  <title>Supporto per l'offset negativo delle stringhe</title>

  <para>
   Il supporto per l'offset negativo delle stringhe è stato 
   aggiunto alle funzioni di <link linkend="book.strings">manipolazione delle stringhe</link>
   accetta offsets così come 
   <link linkend="language.types.string.substr">l'indicizzazione delle stringhe</link> con
   <literal>[]</literal> o <literal>{}</literal>. In ogni caso un offset
   negativo è interpretato come un offset a partire dalla fine della stringa.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
var_dump("abcdef"[-2]);
var_dump(strpos("aabbcc", "b", -3));
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
string (1) "e"
int(3)
]]>
   </screen>
  </informalexample>

  <para>
   Offset negativi di stringhe e array ora sono supportati 
   nella sintassi del parsing delle stringhe.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$string = 'bar';
echo "The last character of '$string' is '$string[-1]'.\n";
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
The last character of 'bar' is 'r'.
]]>
   </screen>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration71.new-features.support-for-aead-in-ext-openssl">
  <title>Supporto per AEAD in ext/openssl</title>

  <para>
   Il supporto per AEAD (modes GCM e CCM) è stato 
   aggiunto per estendere le funzioni <function>openssl_encrypt</function> 
   e <function>openssl_decrypt</function> con parametri aggiuntivi.
  </para>
 </sect2>

 <sect2 xml:id="migration71.new-features.convert-callables-to-closures">
  <title>Conversione di callables a <classname>Closure</classname>s con <methodname>Closure::fromCallable</methodname></title>

  <para>
   Un nuovo metodo statico è stato introdotto alla classe 
   <classname>Closure</classname> per permettere ai
   <type>callable</type>di essere facilmente convertiti
   in oggetti <classname>Closure</classname>.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class Test
{
    public function exposeFunction()
    {
        return Closure::fromCallable([$this, 'privateFunction']);
    }

    private function privateFunction($param)
    {
        var_dump($param);
    }
}

$privFunc = (new Test)->exposeFunction();
$privFunc('some value');
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
string(10) "some value"
]]>
   </screen>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration71.new-features.asynchronous-signal-handling">
  <title>Elaborazione di segnali asincroni</title>

  <para>
   Una nuova funzione chiamata
   <function>pcntl_async_signals</function> è stata introodotta
   per abilitare l'elaborazione del segnale senza l'uso di 
   trucchi (che introduconon molti overhead).
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
pcntl_async_signals(true); // turn on async signals

pcntl_signal(SIGHUP,  function($sig) {
    echo "SIGHUP\n";
});

posix_kill(posix_getpid(), SIGHUP);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
SIGHUP
]]>
   </screen>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration71.new-features.http2-server-push-support-in-ext-curl">
  <title>HTTP/2 server push support in ext/curl</title>

  <para>
   Il supporto per il push da parte del server è stato
   aggiunto all'estensione CURL (richiede la versione 7.46 o superiore)
   Questo può far leva attraverso la funzione 
   <function>curl_multi_setopt</function> con
   la nuova costante <constant>CURLMOPT_PUSHFUNCTION</constant>.
   La costante <constant>CURL_PUSH_OK</constant> e <constant>CURL_PUSH_DENY</constant>
   sono già state aggiunte così che l'esecuzione della chiamata 
   di push dal server possa sia essere approvata che negata.
  </para>
 </sect2>

 <sect2 xml:id="migration71.new-features.stream-context-options">
  <title>Stream Context Options</title>

  <para>
   La <link linkend="context.socket.tcp_nodelay">tcp_nodelay</link> stream
   context option è stata aggiunta.
  </para>
 </sect2>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
