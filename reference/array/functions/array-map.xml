<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 33968dfebb9b847733d02ee221b3b8054a101b41c Maintainer: Manuel dG Status: ready -->
<!-- CREDITS: cucinato -->
<refentry xmlns="http://docbook.org/ns/docbook" xml:id="function.array-map">
 <refnamediv>
  <refname>array_map</refname>
  <refpurpose>Applica la callback a tutti gli elementi dell'array in input</refpurpose>
 </refnamediv>
 
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>array</type><methodname>array_map</methodname>
   <methodparam><type class="union"><type>callable</type><type>null</type></type><parameter>callback</parameter></methodparam>
   <methodparam><type>array</type><parameter>array</parameter></methodparam>
   <methodparam rep="repeat"><type>array</type><parameter>arrays</parameter></methodparam>
  </methodsynopsis>
  <para>
   <function>array_map</function> restituisce un &array; che contiene
   i risultati della <parameter>callback</parameter>
   all'indice corrispondente dell'elemento dell'<parameter>array</parameter>
   (o <parameter>arrays</parameter> se vengono forniti più array)
   usato/i come argomento per la callback.
   Il numero di parametri che la funzione <parameter>callback</parameter>
   accetta dovrebbe corrispondere al numero di array
   passati a <function>array_map</function>.
   I parametri in eccesso sono ignorati.
   Un <classname>ArgumentCountError</classname>
   viene generato se sarà fornito un numero insufficente di argomenti.   
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>callback</parameter></term>
     <listitem>
      <para>
       Una funzione <type>callable</type> da eseguire per ogni elemento in ogni array.
      </para>
      <para>
       &null; può essere passato come valore alla <parameter>callback</parameter>
       per eseguire un'operazione zip su più array e ritornerà un'array 
       i cui elementi sono ciascuno un sub-array contenente gli elementi degli 
       array di input con lo stesso indice (vedere l'esempio seguente).
       
        Se viene fornito un solo <parameter>array</parameter>,
        <methodname>array_map</methodname> restituirà l'array di input.

     
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>array</parameter></term>
     <listitem>
      <para>
       Un array su cui eseguire la funzione <parameter>callback</parameter>.
       Un array su cui eseguire la funzione <parameter>callback</parameter>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>arrays</parameter></term>
     <listitem>
      <para>
       Array di argomenti supplementari da eseguire nella
       <parameter>callback</parameter>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>  
   Restituisce un array contenente i risultati dell'applicazione della
   <parameter>callback</parameter> all'indice corrispondente di <parameter>array1</parameter>
   (o <parameter>arrays</parameter> se vengono forniti più array)
   usati come argomenti per la callback.
  </para>
  <para>
   L'array restituito conserverà le chiavi del parametro array se e solo
   se viene passato esattamente un array. Se viene passato più di un array, l'array
   restituito avrà chiavi intere sequenziali.
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>&Version;</entry>
      <entry>&Description;</entry>
     </row>
    </thead>
    <tbody>
     &array.changelog.by-ref;
    </tbody>
   </tgroup>
  </informaltable>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Esempio di <function>array_map</function></title>
    <title>Esempio di <function>array_map</function></title>
    <programlisting role="php">
<![CDATA[
<?php
function cube($n)
{
    return ($n * $n * $n);
}

$a = [1, 2, 3, 4, 5];
$b = array_map('cube', $a);
print_r($b);
?>
]]>
    </programlisting>
    <para>
     Questo fa sì che <varname>$b</varname> abbia:
     Questo fa sì che <varname>$b</varname> abbia:
    </para>
    <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 8
    [2] => 27
    [3] => 64
    [4] => 125
)
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title><function>array_map</function> usando una funzione lambda (a partire da PHP 5.3.0)</title>
    <title><function>array_map</function> usando una funzione lambda (a partire da PHP 5.3.0)</title>
    <programlisting role="php">
<![CDATA[
<?php
$func = function(int $value): int {
    return $value * 2;
};

print_r(array_map($func, range(1, 5)));

// O come in PHP 7.4.0:

print_r(array_map(fn($value): int => $value * 2, range(1, 5)));

?>
]]>
    </programlisting>
    <screen>
<![CDATA[
Array
(
    [0] => 2
    [1] => 4
    [2] => 6
    [3] => 8
    [4] => 10
)
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title><function>array_map</function> - usando più array</title>
    <title><function>array_map</function> - usando più array</title>
    <programlisting role="php">
<![CDATA[
<?php
function show_Spanish(int $n, string $m): string
{
    return "Il numero {$n} si dice {$m} in Spagnolo";
}

function map_Spanish(int $n, string $m): array
{
    return [$n => $m];
}

$a = [1, 2, 3, 4, 5];
$b = ['uno', 'dos', 'tres', 'cuatro', 'cinco'];

$c = array_map('show_Spanish', $a, $b);
print_r($c);

$d = array_map('map_Spanish', $a , $b);
print_r($d);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
// stampa di $c
Array
(
    [0] => Il numero 1 è chiamato uno in spagnolo
    [1] => Il numero 2 è chiamato dos in spagnolo
    [2] => Il numero 3 è chiamato tres in spagnolo
    [3] => Il numero 4 è chiamato cuatro in spagnolo
    [4] => Il numero 5 è chiamato cinco in spagnolo
)

// stampa di $d
Array
(
    [0] => Array
        (
            [1] => uno
        )

    [1] => Array
        (
            [2] => dos
        )

    [2] => Array
        (
            [3] => tres
        )

    [3] => Array
        (
            [4] => cuatro
        )

    [4] => Array
        (
            [5] => cinco
        )

)
]]>
    </screen>
   </example>
  </para>
  <para>
   Di solito quando si usano due o più array, questi dovrebbero essere di uguale lunghezza
   in quanto la funzione di callback viene applicata in parallelo agli elementi
   corrispondenti.
   Se gli array sono di lunghezza diversa, quelli più corti verranno estesi con elementi
   vuoti per uguagliare la lunghezza del più lungo.
   Di solito quando si usano due o più array, questi dovrebbero essere di uguale lunghezza
   in quanto la funzione di callback viene applicata in parallelo agli elementi
   corrispondenti.
   Se gli array sono di lunghezza diversa, quelli più corti verranno estesi con elementi
   vuoti per uguagliare la lunghezza del più lungo.
  </para>
  <para>
   Un uso interessante di questa funzione è quello di costruire un array di array,
   cosa che può essere facilmente ottenuta usando &null;
   come nome della funzione callback
   Un uso interessante di questa funzione è quello di costruire un array di array,
   cosa che può essere facilmente ottenuta usando &null;
   come nome della funzione callback
  </para>
  <para>
   <example>
    <title>Esecuzione di un'operazione zip di array</title>
    <title>Esecuzione di un'operazione zip di array</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = [1, 2, 3, 4, 5];
$b = ['one', 'two', 'three', 'four', 'five'];
$c = ['uno', 'dos', 'tres', 'cuatro', 'cinco'];

$d = array_map(null, $a, $b, $c);
print_r($d);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
    [0] => Array
        (
            [0] => 1
            [1] => one
            [2] => uno
        )

    [1] => Array
        (
            [0] => 2
            [1] => two
            [2] => dos
        )

    [2] => Array
        (
            [0] => 3
            [1] => three
            [2] => tres
        )

    [3] => Array
        (
            [0] => 4
            [1] => four
            [2] => cuatro
        )

    [4] => Array
        (
            [0] => 5
            [1] => five
            [2] => cinco
        )

)
]]>
    </screen>
   </example>
  </para>
  
  <para>
   <example>
    <title>
     <parameter>callback</parameter> &null; con solo
     <parameter>array1</parameter>
     <parameter>callback</parameter> &null; con solo
     <parameter>array1</parameter>
    </title>
    <programlisting role="php">
<![CDATA[
<?php
$array = [1, 2, 3];
var_dump(array_map(null, $array));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(3) {
  [0]=>
  int(1)
  [1]=>
  int(2)
  [2]=>
  int(3)
}
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title><function>array_map</function> - con chiavi stringa</title>
    <title><function>array_map</function> - con chiavi stringa</title>
    <programlisting role="php">
<![CDATA[
<?php
$arr = ['stringkey' => 'value'];
function cb1($a) {
    return [$a];
}
function cb2($a, $b) {
    return [$a, $b];
}
var_dump(array_map('cb1', $arr));
var_dump(array_map('cb2', $arr, $arr));
var_dump(array_map(null,  $arr));
var_dump(array_map(null, $arr, $arr));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(1) {
  ["stringkey"]=>
  array(1) {
    [0]=>
    string(5) "value"
  }
}
array(1) {
  [0]=>
  array(2) {
    [0]=>
    string(5) "value"
    [1]=>
    string(5) "value"
  }
}
array(1) {
  ["stringkey"]=>
  string(5) "value"
}
array(1) {
  [0]=>
  array(2) {
    [0]=>
    string(5) "value"
    [1]=>
    string(5) "value"
  }
}
]]>
    </screen>
   </example>
   <example>
    <title><function>array_map</function> - array associativi</title>
    <para>
     Mentre <function>array_map</function> non supporta direttamente
     di arrray associativi come input, questo può essere simulato con <function>array_keys</function>.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$arr = [
    'v1' => 'Prima release',
    'v2' => 'Seconda release',
    'v3' => 'Terza release',
];

// Note: Prima della 7.4.0,invece si usava una versione estesa per le funzioni anonime.
$callback = fn(string $k, string $v): string => "$k was the $v";

$result = array_map($callback, array_keys($arr), array_values($arr));

var_dump($result);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(3) {
  [0]=>
  string(24) "v1 was the First release"
  [1]=>
  string(25) "v2 was the Second release"
  [2]=>
  string(24) "v3 was the Third release"
}
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>array_filter</function></member>
    <member><function>array_reduce</function></member>
    <member><function>array_walk</function></member>
   </simplelist>
  </para>
 </refsect1>
</refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
