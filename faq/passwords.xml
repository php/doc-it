<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: b8e1b1357def73f310c9f7405035b3acc0cb1eaf Maintainer: lucalzetta Status: ready -->
<!-- $Revision$ -->
 <chapter xml:id="faq.passwords" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Crittografia sicura delle Password</title>
  <titleabbrev>Password Hashing</titleabbrev>
  
  <para>
   Questa sezione spiega le ragioni che stanno dietro 
   l'uso delle funzioni di hashing per la sicurezza delle 
   passwords, così come utilizzarle  effettivamente.
  </para>
  
  <qandaset>
   <qandaentry xml:id="faq.passwords.hashing">
    <question>
     <para>
      Perché dovrei crittografare le password fornite 
      dagli utenti della mia applicazione? 
     </para>
    </question>
    <answer>
     <para>
      La crittografia (hashing) delle password è una delle 
      più importanti considerazioni che si devono fare quando 
      si progetta un'applicazione che accetta passwords dai propri 
      utenti. Senza crittografia, ogni password presente sul 
      nostro database può essere rubata se il database viene 
      comromesso da un attacco hacker e quindi venire usata 
      per compromettere non solo la nostra applicazione ma anche 
      gli account del nostro utente su altre applicazioni e servizi 
      nel caso, abbastanza frequente, che non usi più di una 
      password. 
     </para>
     <para>
      Applicando un algoritmo di crittografia alle password 
      dei nostri utenti prima di archiviarle nel nostro 
      database, rendiamo molto difficile per ogni attaccante 
      determinare le password originali, mentre rimane possibile 
      comparare gli hashing risultanti dalle successive sottoscrizioni 
      con quelli delle password archiviate nel database. 
     </para>
     <para>
      Rimane comunque importante ricordare che l'hashing delle 
      password ci protegge solo dai tentativi di lettura dei dati    
      archiviati nel database ma non necessariamente da intercettazioni 
      causate da codice malevolo iniettato nella nostra applicazione. 
     </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.passwords.fasthash">
    <question>
     <para>
      Perché le comuni funzioni di hashing come <function>md5</function> 
      e <function>sha1</function> non sono utilizzabili per le password? 
     </para>
    </question>
    <answer>
     <para>
      Gli algoritmi di hashing come MD5, SHA1 e SHA256 sono 
      pensati per essere molto veloci ed efficienti. Con le 
      moderne tecniche ed equipaggiamenti di computer è diventato 
      banale forzare con la forza bruta l'output di questi algoritmi 
      per determinare l'input originale. 
     </para>
     <para>
      Proprio perché l'enorme velocità dei moderni computer 
      può decodificare facilmente i risultati di questi algoritmi, 
      molti professionisti scoraggiano ardentemente il loro uso 
      per la protezione delle password. 
     </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.passwords.bestpractice">
    <question>
     <para>
      Come posso criptare le mie passord se i comuni algoritmi 
      di hash non sono adeguati? 
     </para>
    </question>
    <answer>
     <para>
      Quando criptiamo una password, le considerazioni più importanti 
      da fare sono il costo computazionale e il salt. Più è importante 
      il tempo necessario a computare la sequenza di hash, tanto più 
      sarà il tempo necessario a forzare la protezione con la forza bruta. 
     </para>
     <para>
      PHP mette a disposizione 
      <link linkend="book.password">un API nativa per l'hashing delle password</link>
      che elabora in sicurezza l'<link linkend="function.password-hash">hashing</link>
      e <link linkend="function.password-verify">la verifica delle passwords</link>. 
     </para>
     <!-- TODO Drop mention of crypt? -->
     <para>
      Un'altra opzione è la funzione <function>crypt</function>, che 
      supporta diversi algoritmi di hashing. Quando usiamo questa funzione 
      siamo sicuri che l'algoritmo selezionato è disponibile perché 
      l'implementazione nativa di PHP contiene gli algoritmi anche se 
      il nostro sistema non li mette a disposizione. 
     </para>
     <para>
      L'algoritmo suggerito per la protezione delle password è 
      Blowfish, che è anche quello usato per impostazione predefinita 
      dall'API di hashing delle password, così com'è il più impegnativo 
      dil punto di vista dell'impiego di potenza di calcolo, molto più 
      di MD5 o SHA1, mentre rimane molto scalabile.
     </para>
     <para>
      Si noti che se si sta usando <function>crypt</function> per 
      verificare le password, si dovrà fare attenzione nella prevenzione 
      di timing attacks usando un tempo di comparazione delle stringhe 
      costante. Ne gli operatori PHP 
      <link linkend="language.operators.comparison">== and ===</link>
      ne <function>strcmp</function> offrono un tempo costante per la 
      comparazione delle stringhe. Mentre 
      <function>password_verify</function> può farlo. E' fortemente 
      consigliato l'uso delle 
      <link linkend="book.password">API native per l'hashing delle password</link> 
      ogni volta che è possibile farlo. 
     </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.passwords.salt">
    <question>
     <para>
      Cos'è un salt? 
     </para>
    </question>
    <answer>
     <para>
      Un salt crittografico sono dei dati che vengono applicati 
      durante il processo di crittografia in modo di eliminare la 
      possibilità che l'output dell'algoritmo possa essere ispezionato 
      tramite una lista di copie di dati cifrati e input che sono 
      state precompilate per il confronto, tali liste sono note 
      con il nome di tabelle arcobaleno. 
     </para>
     <para>
      In termini più semplici, un salt è un bit di dati aggiuntivi 
      che rende la crittografia significativamente più difficile da 
      violare. Ci sono diversi servizi online che offrono vaste liste 
      di crittografie pre compilate, così come l'input originale che 
      ha generato questi valori crittografici. L'uso di un salt rende 
      inverosimile trovare un hash di riscontro per i nostri dati in 
      una di queste liste. 
     </para>
     <para>
      <function>password_hash</function> creerà un salt casuale se 
      non se ne può fornire uno e questo, in genere, è l'approccio 
      più sicuro da mantenere. 
     </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.password.storing-salts">
    <question>
     <para>
      Come posso archiviare i miei salt? 
     </para>
    </question>
    <answer>
     <para>
      Usando <function>password_hash</function> o 
      <function>crypt</function>, il valore di ritorno include un 
      salt come parte dell'ahsh generato. Questo valore può venire 
      archiviato così com'è nel nostro database, esso include 
      informazioni riguardanti la funzioe di hash che è stata usata 
      per generarlo e può essere passato direttamente a 
      <function>password_verify</function> o 
      <function>crypt</function> quando verifichiamo le password. 
     </para>
     <para>
      Il seguente diagramma mostra il formato dei valori di 
      ritorno dalla funzione <function>crypt</function> o 
      <function>password_hash</function>. Come si può vedere, 
      essi sono auto contenuti, con tutte le informazioni che 
      riguardano l'algoritmo e il salt richieste per le future 
      verifiche della password. 
     </para>
     <para>
      <mediaobject>
       <alt>
        I componenti dei valori restituiti da password_hash e 
        crypt: in ordine, l'algoritmo scelto, le opzioni 
        dell'algoritmo, il salt usato e la password criptata. 
       </alt>
       <imageobject>
        <imagedata fileref="en/faq/figures/crypt-text-rendered.svg" width="690" depth="192" format="SVG" />
       </imageobject>
      </mediaobject>
     </para>
    </answer>
   </qandaentry>
  </qandaset>
  
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
