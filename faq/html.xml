<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 8b647de71ab443cb2784a82902bfc87728d587ae Maintainer: lucalzetta Status: ready -->
<!-- $Revision$ -->
 <chapter xml:id="faq.html" xmlns="http://docbook.org/ns/docbook">
  <title>PHP e HTML</title>
  <titleabbrev>PHP e HTML</titleabbrev>

  <para>
   PHP e HTML interagiscono molto: PHP può generare 
   codice HTML e HTML può passare informazioni a PHP. 
   Prima di iniziare a leggere queste FAQs è importante 
   capire come ottenere <link linkend="language.variables.external">
   variabili da fonti esterne</link>. La pagina del manuale 
   che riguarda questo argmoneto include molti utili 
   esempi al riguardo. 
  </para>

  <qandaset>
   <qandaentry xml:id="faq.html.encoding">
    <question>
     <para>
      Di quale codifica/decodifica ho bisogno quando passo un 
      valore attraverso un form/URL?
     </para>
    </question>
    <answer>
     <para>
      Ci sono molte fasi per la quale la codifica è importante. 
      Supponiamo di avere una <type>string</type> <varname>$data</varname>, 
      che contiene la stringa che vogliamo passare in modalità 
      non codificata, questi sono i passi più importanti da fare: 
      <itemizedlist>
       <listitem>
        <para>
         Interpretazione HTML, Volendo specificare una stringa casuale, 
         si <emphasis>deve</emphasis> racchiudere tra doppie virgolette 
          e <function>htmlspecialchars</function> l'intero contenuto. 
        </para>
       </listitem>
       <listitem>
        <para>
         URL: un URL consiste di diverse parti. Se si vuole che i nostri 
         dati vengano interpretati come un valore, si 
         <emphasis>deve</emphasis> codificarli in un 
         <function>urlencode</function>. 
        </para>
       </listitem>
      </itemizedlist>
     </para>
     <para>
      <example>
       <title>Un elemento nascosto di un form HTML</title>
        <programlisting role="php">
<![CDATA[
<?php
    echo '<input type="hidden" value="' . htmlspecialchars($data) . '" />'."\n";
?>
]]>
        </programlisting>
      </example>
      <note>
       <simpara>
        E' sbagliato tentare di <function>urlencode</function>
        <varname>$data</varname>, perché è responsabilità del 
        browser web <function>urlencode</function> i dati. 
        Tutti ibrowser di uso più comune lo fanno correttamente. 
        Si osservi che questo viene fatto indipendentemente dal 
        metodo (cioè GET o POST). Lo si noterà però solo nel caso 
        di una richiesta GET perché le richieste POST vengono 
        normalmente mascherate e rese non disponibili nell'URL. 
       </simpara>
      </note>
      <example>
       <title>Dati che vengono inseriti dall'utente</title>
        <programlisting role="php">
<![CDATA[
<?php
    echo "<textarea name='mydata'>\n";
    echo htmlspecialchars($data)."\n";
    echo "</textarea>";
?>
]]>
        </programlisting>
      </example>
      <note>
       <simpara>
        I dati verranno mostrati nel browser secondo le nostre 
        intenzioni perché il browse interpreterà i TAG HTML. 
       </simpara>
       <simpara>
        Prima di essere trasmessi, sia attraverso un GET che 
        attraverso un POST, i dati verranno codificati in un 
        URL dal browser e direttamente da PHP. In questo modo 
        non sarà necessario preoccuparsi di codificare in un 
        URL i dati da trasmettere perché il tutto verrà elaborato 
        automaticamente. 
       </simpara>
      </note>
      <example>
       <title>In a URL</title>
        <programlisting role="php">
<![CDATA[
<?php
    echo '<a href="' . htmlspecialchars("/nextpage.php?stage=23&data=" .
        urlencode($data)) . '">'."\n";
?>
]]>
        </programlisting>
      </example>
      <note>
       <simpara>
        In questo modo si finge un'HTML GET request, perciò sarà 
        necessario eseguire manualmente un 
        <function>urlencode</function> dei dati. 
       </simpara>
      </note>
      <note>
       <simpara>
        E' necessario passare a <function>htmlspecialchars</function> 
        l'intero URL, perché l'URL si presenta come valore di un 
        attributo HTML. In questo caso il browser prima sottoporrà 
        a <function>htmlspecialchars</function> il valore e poi lo 
        passerà all'URL. PHP, a questo punto, interpreterà 
        correttamente l'URL perché abbiamo 
        <function>urlencode</function>d tutti i dati. 
       </simpara>
       <simpara>
        Si noterà che <literal>&amp;</literal> nell'URL viene 
        sostituito con <literal>&amp;amp;</literal>. Comunque molti 
        browser rimediano queste sviste se ci si dovesse scordare di 
        farlo. Questo, però, non è sempre possibile. Specialmente se 
        il nostro URL non è dinamico, è <emphasis>necessario</emphasis> 
        sottoporlo a <function>htmlspecialchars</function>. 
       </simpara>
      </note>
     </para>
     <!-- TODO: a note about addgpcslashes? -->
    </answer>
   </qandaentry>

   <qandaentry xml:id="faq.html.form-image">
    <question>
     <para>
      Sto cercando di usare un &lt;input type="image"&gt; tag, 
      ma l evariabili <varname>$foo.x</varname> e 
      <varname>$foo.y</varname> non sono disponibili. 
      <varname>$_GET['foo.x']</varname> non è disponibile neppure 
      esso. Dove sono finiti?   
     </para>
    </question>
    <answer>
     <para>
      Quando sottoponiamo un form a invio è possibile usare un 
      immagine anziché il pulsante di invio standard usando un 
      TAG come: 
      <programlisting role="html">
<![CDATA[
<input type="image" src="image.gif" name="foo" />
]]>
      </programlisting>
      Quando l'utente clicca in un punto dell'immagine il form 
      associato verrà trasmesso al server con due variabili 
      addizionali: <varname>foo.x</varname> e <varname>foo.y</varname>. 
     </para>
     <para>
      Perché <varname>foo.x</varname> e <varname>foo.y</varname> 
      sono due nomi di variabili non validi in PHP, esse verranno 
      automaticamente convertite in <varname>foo_x</varname> e 
      <varname>foo_y</varname>. I punti vengono sostituiti da dei 
      trattini di sottolineatura. In questo modo sarà possibile 
      accedere a queste variabili come ad ogni altra come descritto 
      nella sezione <link linkend="language.variables.external">
      ottenere variabili da fonti esterne</link>.  Per esempio:
      <varname>$_GET['foo_x']</varname>.
      <note>
       <para>
         Gli spazi nella richiesta di nomi di variabili sono 
         sostituiti da sottolineature. 
       </para>
      </note>
     </para>
    </answer>
   </qandaentry>

   <qandaentry xml:id="faq.html.arrays">
    <question>
     <para>Come posso creare degli arrays in un HTML &lt;form&gt;?</para>
    </question>
    <answer>
     <para>
      Per ottenere il vostro &lt;form&gt; result spedito come un 
      <link linkend="language.types.array">array</link> dal vostro 
      script PHP, dovrete nominare gli elementi &lt;input&gt;, 
      &lt;select&gt; o &lt;textarea&gt; in questo modo: 
      <programlisting role="html">
<![CDATA[
<input name="MyArray[]" />
<input name="MyArray[]" />
<input name="MyArray[]" />
<input name="MyArray[]" />
]]>
      </programlisting>
      Attenzione alle parentesi quadre dopo il nome della variabile, 
      questo rende una semplice variabile un array. E' possibile 
      raggruppare gli elementi in array diversi assegnando lo stesso 
      nome a elementi differenti: 
      <programlisting role="html">
<![CDATA[
<input name="MyArray[]" />
<input name="MyArray[]" />
<input name="MyOtherArray[]" />
<input name="MyOtherArray[]" />
]]>
      </programlisting>
      QUesto produce due array, MyArray e  MyOtherArray, che verranno 
      passati allo script PHP.  E' anche possibile assegnare chiavi 
      specifiche ai vostri array: 
      <programlisting role="html">
<![CDATA[
<input name="AnotherArray[]" />
<input name="AnotherArray[]" />
<input name="AnotherArray[email]" />
<input name="AnotherArray[phone]" />
]]>
      </programlisting>
      L'array AnotherArray ora conterrà le chiavi 0, 1, 
      email e phone. 
      </para>
      <para>
       <note>
        <para>
         Specificare chiavi di array è opzionale in HTML. Se non 
         vengono specificate l'array verrà riempito nell'ordine in 
         cui si presentano gli elementi nel form. Il nostro primo 
         esempio conterrà le chiavi 0, 1, 2 e 3. 
        </para>
       </note>
      </para>
      <para>
      Vedere anche 
      <link linkend="ref.array">Array Functions</link> e 
      <link linkend="language.variables.external">Variabili da origini 
      esterne</link>.
     </para>
    </answer>
   </qandaentry>

   <qandaentry xml:id="faq.html.select-multiple">
    <question>
     <para>
      Come posso ottenere tutti i risultati dalla selezione 
      di un TAG multiplo? 
     </para>
    </question>
    <answer>
     <para>
      La costruzione di un select multiple tag in HTML permette agli 
      utenti di selezionare più elementi da una lista. Questi elementi 
      sono quindi passati al gestore delle azioni del form. Il problema 
      è che essi vengono passati con lo stesso nome di riferimento, cioè: 
      <programlisting role="html">
<![CDATA[
<select name="var" multiple="yes">
]]>
      </programlisting>
      Ogni opzione selezionata arriverà al gestore delle azioni 
      come: 
      <programlisting>
var=option1
var=option2
var=option3
      </programlisting>
      Dove ogni opzione sovrascriverà il valore della precedente 
      <varname>$var</varname> variabile. La soluzione a questo 
      problema consiste nell'uso di un array da elementi di un 
      form implementata in PHP: 
      <programlisting role="html">
<![CDATA[
<select name="var[]" multiple="yes">
]]>
      </programlisting>
      Questo istruisce PHP di trattare <varname>$var</varname> come 
      un array e ogni assegnamento di un valore a var[] aggiungerà 
      un elemento all'array. Il primo elemento sarà 
      <varname>$var[0]</varname>, il successivo 
      <varname>$var[1]</varname>, etc. La funzione 
      <function>count</function> può essere usata per determinare 
      quante opzioni sono state selezionate. La funzione 
      <function>sort</function> può essere usata per ordinare 
      l'array di opzioni, se necessario. 
     </para>
     <para>
      E' imprtante notare che se si usa JavaScript i caratteri 
      <literal>[]</literal> nel nome dell'elemento possono causare 
      dei problemi quando si tenta di riferirsi all'elemento 
      attraverso il suo nome. Per riferirsi ad esso è meglio usare 
      il suo ID numerico di elemento del form o chiudere il nome 
      della variabile tra apici semplici e usarlo come indice per 
      gli elementi dell'array. Ad es.: 
      <programlisting>
variable = document.forms[0].elements['var[]'];
      </programlisting>
     </para>
    </answer>
   </qandaentry>

   <qandaentry xml:id="faq.html.javascript-variable">
    <question>
     <para>
      Come posso passare una variabile a PHP da Javascript? 
     </para>
    </question>
    <answer>
     <para>
      Finchè Javascript sarà (così com'è) una tecnologia per 
      client e PHP sarà una tecnologia per servers e finché 
      l'HTML sarà un protocollo indipendente, i due linguaggi 
      non potranno condividere direttamente tra loro alcuna 
      variabile. 
     </para>
     <para>
      E' comunque possibile passare variabili tra i due ad 
      esempio generando codice Javascript con PHP e al momento 
      della rigenerazione del browser passare indietro specifiche 
      variabili a PHP. L'esempio seguente mostra precisamente 
      come fare questo; esso fa si che il codice PHP possa catturare 
      l'altezza e la larghezza dello schermo, una cosa che normalmente 
      è possibile fare solo dal lato client. 
     </para>
     <para>
      <example>
       <title>Generazione di codice Javascript con PHP</title>
       <programlisting role="php">
<![CDATA[
<?php
if (isset($_GET['width']) AND isset($_GET['height'])) {
  // output delle variabili altezza e larghezza 
  echo "Screen width is: ". $_GET['width'] ."<br />\n";
  echo "Screen height is: ". $_GET['height'] ."<br />\n";
} else {
  // passaggio delle variabili 
  // (conservando la query originale 
  //   -- le variabili finali andranno elaborate diversamente) 

  echo "<script language='javascript'>\n";
  echo "  location.href=\"${_SERVER['SCRIPT_NAME']}?${_SERVER['QUERY_STRING']}"
            . "&width=\" + screen.width + \"&height=\" + screen.height;\n";
  echo "</script>\n";
  exit();
}
?>
]]>
       </programlisting>
      </example>
     </para>
    </answer>
   </qandaentry>

  </qandaset>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
