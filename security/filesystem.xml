<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 91570644fbbe4d23e79908e1a04c4c4d003fe587 Maintainer: Manuel dG Status: ready -->
<!-- splitted from ./index.xml, last change in rev 1.66 -->
  <chapter xml:id="security.filesystem" xmlns="http://docbook.org/ns/docbook">
   <title>Sicurezza del Filesystem </title>
   <simpara>
    <acronym>PHP</acronym> dipende dalla gestione della sicurezza di molti sistemi server che usano
    i permessi basati su file e directory. Ciò consente
    di controllare quali file nel filesystem possono essere letti. Si dovrebbe prestare attenzione
    a tutti i file che sono pubblici per garantire
    che siano sicuri in lettura da parte degli utenti che hanno accesso a quel
    file system.
   </simpara>
   <simpara>
    Poiché <acronym>PHP</acronym> è stato progettato per consentire l'accesso a livello utente al file system,
    potrebbe essere possibile scrivere uno script <acronym>PHP</acronym> che ti consenta
    di leggere file di sistema come <filename>/etc/passwd</filename>, modificare le connessioni ethernet,
    inviare enormi documenti in stampa, ecc. Questo suggerisce alcune
    ovvie implicazioni, in quanto devi assicurarti che i file
    da cui leggi e su cui scrivi siano quelli appropriati.
   </simpara>
   <simpara>
    Considerate il seguente script, dove l'utente indica che vorrebbe
    eliminare un file nella propria directory home. Ciò presuppone una
    situazione in cui un'interfaccia web <acronym>PHP</acronym> viene regolarmente utilizzata per la
    gestione dei file, quindi all'utente Apache è consentito eliminare i file nelle
    directory home dell'utente.
   </simpara>
   <para>
    <example>
     <title>Un controllo non accurato di una variabile porta a...</title>
     <programlisting role="php">
<![CDATA[
<?php

// Remove a file from the user's home directory
$username = $_POST['user_submitted_name'];
$userfile = $_POST['user_submitted_filename'];
$homedir  = "/home/$username";

unlink("$homedir/$userfile");

echo "The file has been deleted!";

?>
]]>
     </programlisting>
    </example>
     Poiché il nome utente e il nome file possono essere inviati da un form,
     possono inviare un nome utente e un nome file appartenenti a un'altro utente,
     ed eliminarli anche se non dovrebbero essere autorizzati a farlo.
     In questo caso, dovresti usare un'altra forma di autenticazione.
     Considera cosa potrebbe accadere se le variabili inviate fossero
     <literal>"../etc/"</literal> e <literal>"passwd"</literal>.
     Il codice quindi leggerebbe effettivamente:  
    <example>
     <title>... un'attacco al filesystem </title>
     <programlisting role="php">
<![CDATA[
<?php

// Removes a file from anywhere on the hard drive that
// the PHP user has access to. If PHP has root access:
$username = $_POST['user_submitted_name']; // "../etc"
$userfile = $_POST['user_submitted_filename']; // "passwd"
$homedir  = "/home/$username"; // "/home/../etc"

unlink("$homedir/$userfile"); // "/home/../etc/passwd"

echo "The file has been deleted!";

?>
]]>
     </programlisting>
    </example>
     Ci sono due misure importanti che dovresti adottare per prevenire questi problemi.
    <itemizedlist>
     <listitem>
      <simpara>
       Consentire solo autorizzazioni limitate ai file binari da parte dell'utente web <acronym>PHP</acronym>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Controllare tutte le variabili inviate.
      </simpara>
     </listitem>
    </itemizedlist>
    Ecco uno script migliorato:
    <example>
     <title>Controllo più sicuro dei nomi dei file</title>
     <programlisting role="php">
<![CDATA[
<?php

// Removes a file from the hard drive that
// the PHP user has access to.
$username = $_SERVER['REMOTE_USER']; // using an authentication mechanism
$userfile = basename($_POST['user_submitted_filename']);
$homedir  = "/home/$username";

$filepath = "$homedir/$userfile";

if (file_exists($filepath) && unlink($filepath)) {
    $logstring = "Deleted $filepath\n";
} else {
    $logstring = "Failed to delete $filepath\n";
}

$fp = fopen("/home/logging/filedelete.log", "a");
fwrite($fp, $logstring);
fclose($fp);

echo htmlentities($logstring, ENT_QUOTES);

?>
]]>
     </programlisting>
    </example>
     Tuttavia, anche questo non è privo di difetti. Se il tuo sistema di autenticazione
     consentiva agli utenti di creare i propri accessi e un'altro utente
     voleva accedere a <literal>"../etc/"</literal>, il sistema è nuovamente esposto. Per
     questo motivo, potresti preferire scrivere un controllo più personalizzato: 
    <example>
     <title>Controllo più sicuro dei nomi dei file</title>
     <programlisting role="php">
<![CDATA[
<?php

$username     = $_SERVER['REMOTE_USER']; // using an authentication mechanisim
$userfile     = $_POST['user_submitted_filename'];
$homedir      = "/home/$username";

$filepath     = "$homedir/$userfile";

if (!ctype_alnum($username) || !preg_match('/^(?:[a-z0-9_-]|\.(?!\.))+$/iD', $userfile)) {
    die("Bad username/filename");
}

// etc.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    A seconda del sistema operativo, esiste un'ampia varietà di file
    di cui dovresti preoccuparti, tra cui nomi di risorse (<filename>/dev/</filename>
    o <filename>COM1</filename>), file di configurazione (file <filename>/etc/</filename> e
     file <literal>.ini</literal>), cartelle di archiviazione classiche (<filename>/home/</filename>,
    <filename>My Documents</filename>), ecc. Per questo
    motivo, di solito è più facile creare una policy in cui proibisci tutto tranne ciò che consenti esplicitamente.
   </para>
   <sect1 xml:id="security.filesystem.nullbytes">
    <title>Problemi relativi ai valori NULL</title>
    <simpara>
     Poiché <acronym>PHP</acronym> utilizza le funzioni derivate da C per le operazioni correlate
     al file system, potrebbero gestire i valori NULL in un modo del tutto inaspettato.
     Poiché i valori NULL indicano la fine di una stringa in C, le stringhe che li contengono
     non saranno valutate nella loro interezza, ma solo finché non incontreranno un valore NULL.

     Il seguente fa vedere un codice vulnerabile che mostra questo problema:
    </simpara>
    <example>
     <title>Script vulnerabile ai valori NULL</title>
     <programlisting role="php">
<![CDATA[
<?php

$file = $_GET['file']; // "../../etc/passwd\0"

if (file_exists('/home/wwwrun/' . $file . '.php')) {
    // File_exists will return true as the file /home/wwwrun/../../etc/passwd exists
    include '/home/wwwrun/' . $file . '.php';

    // The file /etc/passwd will be included
}

?>
]]>
     </programlisting>
    </example>
    <para>
     Pertanto, qualsiasi stringa contaminata utilizzata in un'operazione sul file system dovrebbe sempre
     essere convalidata correttamente. Ecco una versione migliore dell'esempio precedente:
     </para>
     <example>
     <title>Convalida corretta dell'input</title>
     <programlisting role="php">
<![CDATA[
<?php

$file = $_GET['file']; 

// Whitelisting possible values
switch ($file) {
    case 'main':
    case 'foo':
    case 'bar':
        include '/home/wwwrun/include/' . $file . '.php';
        break;
    default:
        include '/home/wwwrun/include/main.php';
}

?>
]]>
     </programlisting>
    </example>
   </sect1>

  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
