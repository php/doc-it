<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: a124543dd3f6b1e5567b07420d23899e582514dc Maintainer: lacatoire Status: ready -->

<sect1 xml:id="function.include" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>include</title>
 <?phpdoc print-version-for="include"?>
 <simpara>
  L'espressione <literal>include</literal> include e valuta
  il file specificato.
 </simpara>
 <simpara>
  La documentazione seguente si applica anche a <function>require</function>.
 </simpara>
 <simpara>
  I file vengono inclusi in base al percorso indicato o, se non viene indicato, in base
  all'<link linkend="ini.include-path">include_path</link> specificato. Se il file
  non viene trovato nell'<link linkend="ini.include-path">include_path</link>,
  <literal>include</literal> cercherà infine nella directory dello script
  chiamante e nella directory di lavoro corrente prima di fallire. Il
  costrutto <literal>include</literal> emetterà un
  <constant>E_WARNING</constant> se
  non riesce a trovare un file; questo è un comportamento diverso da
  <function>require</function>, che emetterà un
  <constant>E_ERROR</constant>.
 </simpara>
 <simpara>
  Sia <literal>include</literal> che <literal>require</literal>
  generano ulteriori <constant>E_WARNING</constant>, se il file non può essere
  acceduto, prima di generare il <constant>E_WARNING</constant> o
  <constant>E_ERROR</constant> finale, rispettivamente.
 </simpara>
 <simpara>
  Se viene definito un percorso — sia assoluto (che inizia con una lettera di unità
  o <literal>\</literal> su Windows, o <literal>/</literal> su sistemi Unix/Linux)
  che relativo alla directory corrente (che inizia con
  <literal>.</literal> o <literal>..</literal>) — l'
  <link linkend="ini.include-path">include_path</link> verrà ignorato
  completamente. Ad esempio, se un nome di file inizia con <literal>../</literal>,
  il parser cercherà nella directory genitore per trovare il file richiesto.
 </simpara>
 <simpara>
  Per maggiori informazioni su come PHP gestisce l'inclusione dei file e il percorso di inclusione,
  consultare la documentazione per <link linkend="ini.include-path">include_path</link>.
 </simpara>
 <simpara>
  Quando un file viene incluso, il codice che contiene eredita lo
  <link linkend="language.variables.scope">scope delle variabili</link> della
  riga in cui si verifica l'inclusione. Tutte le variabili disponibili a quella riga
  nel file chiamante saranno disponibili all'interno del file chiamato, da quel
  punto in poi.
  Tuttavia, tutte le funzioni e le classi definite nel file incluso hanno
  scope globale.
 </simpara>
 <para>
  <example>
   <title>Esempio base di <literal>include</literal></title>
   <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'green';
$fruit = 'apple';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  Se l'inclusione avviene all'interno di una funzione nel file chiamante,
  tutto il codice contenuto nel file chiamato si comporterà come
  se fosse stato definito all'interno di quella funzione. Quindi, seguirà
  lo scope delle variabili di quella funzione.
  Un'eccezione a questa regola sono le <link
  linkend="language.constants.magic">costanti magiche</link> che vengono
  valutate dal parser prima che avvenga l'inclusione.
 </simpara>
 <para>
  <example>
   <title>Inclusione all'interno di funzioni</title>
   <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "A $color $fruit";
}

/* vars.php è nello scope di foo() quindi     *
* $fruit NON è disponibile al di fuori di    *
* questo scope.  $color lo è perché è stato  *
* dichiarato come global.                    */

foo();                    // A green apple
echo "A $color $fruit";   // A green

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  Quando un file viene incluso, il parsing esce dalla modalità PHP ed
  entra in modalità HTML all'inizio del file di destinazione, e riprende
  nuovamente alla fine. Per questo motivo, qualsiasi codice all'interno del file
  di destinazione che debba essere eseguito come codice PHP deve essere racchiuso tra
  <link linkend="language.basic-syntax.phpmode">tag PHP di apertura
  e chiusura validi</link>.
 </simpara>
 <simpara>
  Se gli "<link linkend="ini.allow-url-include">URL include wrapper</link>"
  sono abilitati in PHP,
  è possibile specificare il file da includere usando un URL (tramite HTTP o
  un altro wrapper supportato - consultare <xref linkend="wrappers"/> per un elenco
  dei protocolli) invece di un percorso locale. Se il server di destinazione interpreta
  il file di destinazione come codice PHP, è possibile passare variabili al file incluso
  usando una stringa di richiesta URL come quella utilizzata con HTTP GET. Questo
  non è esattamente la stessa cosa che includere il file e fargli ereditare
  lo scope delle variabili del file genitore; lo script viene effettivamente
  eseguito sul server remoto e il risultato viene poi
  incluso nello script locale.
 </simpara>
 <para>
  <example>
   <title><literal>include</literal> tramite HTTP</title>
   <programlisting role="php">
<![CDATA[
<?php

/* Questo esempio presuppone che www.example.com sia configurato per analizzare i file .php
* e non i file .txt. Inoltre, 'Works' qui significa che le variabili
* $foo e $bar sono disponibili all'interno del file incluso. */

// Non funzionerà; file.txt non viene gestito da www.example.com come PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Non funzionerà; cerca un file chiamato 'file.php?foo=1&bar=2' nel
// filesystem locale.
include 'file.php?foo=1&bar=2';

// Funziona.
include 'http://www.example.com/file.php?foo=1&bar=2';
?>
]]>
   </programlisting>
  </example>
 </para>
 <warning>
  <title>Avviso di sicurezza</title>
  <para>
   Il file remoto potrebbe essere elaborato sul server remoto (a seconda dell'estensione
   del file e del fatto che il server remoto esegua PHP o meno) ma deve comunque
   produrre uno script PHP valido perché verrà elaborato sul
   server locale. Se il file del server remoto deve essere elaborato
   là e fornire solo l'output, <function>readfile</function> è una funzione
   molto più adatta da utilizzare. Altrimenti, è necessario prestare particolare attenzione
   per proteggere lo script remoto affinché produca un codice valido e desiderato.
  </para>
 </warning>
 <para>
  Consultare anche <link linkend="features.remote-files">File remoti</link>,
  <function>fopen</function> e <function>file</function> per informazioni
  correlate.
 </para>
 <simpara>
  Gestione dei valori di ritorno: <literal>include</literal> restituisce
  <literal>FALSE</literal> in caso di fallimento e genera un avviso. Le inclusioni
  riuscite, a meno che non venga sovrascritto dal file incluso, restituiscono
  <literal>1</literal>. È possibile eseguire un'istruzione <function>return</function>
  all'interno di un file incluso per terminare l'elaborazione in
  quel file e tornare allo script che lo ha chiamato. Inoltre, è possibile
  restituire valori dai file inclusi. È possibile ottenere il valore della
  chiamata include come per una funzione normale. Questo non è, tuttavia,
  possibile quando si includono file remoti a meno che l'output del file remoto
  abbia <link linkend= "language.basic-syntax.phpmode">tag PHP di apertura
  e chiusura validi</link> (come con qualsiasi file locale). È possibile dichiarare le
  variabili necessarie all'interno di quei tag e saranno introdotte nel
  punto in cui il file è stato incluso.
 </simpara>
 <para>
  Poiché <literal>include</literal> è un costrutto speciale del linguaggio,
  le parentesi non sono necessarie attorno al suo argomento. Prestare attenzione quando
  si confronta il valore di ritorno.
  <example>
   <title>Confronto del valore di ritorno di include</title>
   <programlisting role="php">
<![CDATA[
<?php
// non funzionerà, valutato come include(('vars.php') == TRUE), cioè include('1')
if (include('vars.php') == TRUE) {
    echo 'OK';
}

// funziona
if ((include 'vars.php') == TRUE) {
    echo 'OK';
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title><literal>include</literal> e l'istruzione <function>return</function></title>
   <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // stampa 'PHP'

$bar = include 'noreturn.php';

echo $bar; // stampa 1

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  <literal>$bar</literal> ha il valore <literal>1</literal> perché l'inclusione
  è riuscita. Notare la differenza tra gli esempi precedenti. Il primo usa
  <function>return</function> all'interno del file incluso mentre l'altro no.
  Se il file non può essere incluso, viene restituito &false; e viene
  emesso un <constant>E_WARNING</constant>.
 </simpara>
 <para>
  Se ci sono funzioni definite nel file incluso, possono essere utilizzate nel
  file principale indipendentemente dal fatto che siano prima di <function>return</function> o dopo.
  Se il file viene incluso due volte, PHP genererà un errore fatale perché le
  funzioni erano già state dichiarate.
  Si raccomanda di usare <function>include_once</function> invece di
  verificare se il file è già stato incluso e restituire condizionalmente un valore
  all'interno del file incluso.
 </para>
 <simpara>
  Un altro modo per "includere" un file PHP in una variabile è catturare
  l'output usando le <link linkend="ref.outcontrol">Funzioni di Controllo
  dell'Output</link> con <literal>include</literal>. Ad esempio:
 </simpara>
 <para>
  <example>
   <title>Uso del buffering dell'output per includere un file PHP in una stringa</title>
   <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        return ob_get_clean();
    }
    return false;
}

?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  Per includere automaticamente file all'interno degli script, consultare anche le
  opzioni di configurazione
  <link linkend="ini.auto-prepend-file">auto_prepend_file</link> e
  <link linkend="ini.auto-append-file">auto_append_file</link>
  in &php.ini;.
 </para>

 &note.language-construct;

 <simpara>
  Vedere anche <function>require</function>, <function>require_once</function>,
  <function>include_once</function>, <function>get_included_files</function>,
  <function>readfile</function>, <function>virtual</function> e
  <link linkend="ini.include-path">include_path</link>.
 </simpara>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
