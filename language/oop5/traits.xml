<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: c1f37a6c270aadbbb3da56a3973ffd62197adf2b Maintainer: lacatoire Status: ready -->
 <sect1 xml:id="language.oop5.traits" xmlns="http://docbook.org/ns/docbook">
  <title>Trait</title>
  <para>
   PHP implementa un modo per riutilizzare il codice chiamato Trait.
  </para>
  <para>
   I Trait sono un meccanismo per il riutilizzo del codice nei linguaggi a
   ereditarietà singola come PHP. Un Trait è pensato per ridurre alcune
   limitazioni dell'ereditarietà singola permettendo a uno sviluppatore di
   riutilizzare liberamente insiemi di metodi in diverse classi indipendenti
   che vivono in diverse gerarchie di classi. La semantica della combinazione
   di Trait e classi è definita in modo da ridurre la complessità ed evitare
   i tipici problemi associati all'ereditarietà multipla e ai Mixin.
  </para>
  <para>
   Un Trait è simile a una classe, ma è pensato solo per raggruppare
   funzionalità in modo granulare e coerente. Non è possibile istanziare un
   Trait da solo. È un'aggiunta all'ereditarietà tradizionale e permette la
   composizione orizzontale del comportamento; ovvero, l'applicazione di
   membri di classe senza richiedere l'ereditarietà.
  </para>
  <example xml:id="language.oop5.traits.basicexample">
    <title>Esempio di Trait</title>
    <programlisting role="php">
<![CDATA[
<?php

trait TraitA {
    public function sayHello() {
        echo 'Hello';
    }
}

trait TraitB {
    public function sayWorld() {
        echo 'World';
    }
}

class MyHelloWorld
{
    use TraitA, TraitB; // Una classe può usare più trait

    public function sayHelloWorld() {
        $this->sayHello();
        echo ' ';
        $this->sayWorld();
        echo "!\n";
    }
}

$myHelloWorld = new MyHelloWorld();
$myHelloWorld->sayHelloWorld();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Hello World!
]]>
    </screen>
   </example>

  <sect2 xml:id="language.oop5.traits.precedence">
   <title>Precedenza</title>
   <para>
    Un membro ereditato da una classe base viene sovrascritto da un membro
    inserito da un Trait. L'ordine di precedenza è che i membri della classe
    corrente sovrascrivono i metodi del Trait, che a loro volta sovrascrivono
    i metodi ereditati.
   </para>
   <example xml:id="language.oop5.traits.precedence.examples.ex1">
    <title>Esempio di ordine di precedenza</title>
    <para>
     Un metodo ereditato da una classe base viene sovrascritto dal metodo
     inserito in MyHelloWorld dal Trait SayWorld. Il comportamento è lo stesso
     per i metodi definiti nella classe MyHelloWorld. L'ordine di precedenza
     è che i metodi della classe corrente sovrascrivono i metodi del Trait,
     che a loro volta sovrascrivono i metodi della classe base.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}

class MyHelloWorld extends Base {
    use SayWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Hello World!
]]>
    </screen>
   </example>
   <example xml:id="language.oop5.traits.precedence.examples.ex2">
    <title>Esempio alternativo di ordine di precedenza</title>
    <programlisting role="php">
<![CDATA[
<?php
trait HelloWorld {
    public function sayHello() {
        echo 'Hello World!';
    }
}

class TheWorldIsNotEnough {
    use HelloWorld;
    public function sayHello() {
        echo 'Hello Universe!';
    }
}

$o = new TheWorldIsNotEnough();
$o->sayHello();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Hello Universe!
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.traits.multiple">
   <title>Trait multipli</title>
   <para>
    È possibile inserire più Trait in una classe elencandoli nell'istruzione
    <literal>use</literal>, separati da virgole.
   </para>
   <example xml:id="language.oop5.traits.multiple.ex1">
    <title>Utilizzo di Trait multipli</title>
    <programlisting role="php">
<![CDATA[
<?php
trait Hello {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait World {
    public function sayWorld() {
        echo 'World';
    }
}

class MyHelloWorld {
    use Hello, World;
    public function sayExclamationMark() {
        echo '!';
    }
}

$o = new MyHelloWorld();
$o->sayHello();
$o->sayWorld();
$o->sayExclamationMark();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Hello World!
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.traits.conflict">
   <title>Risoluzione dei conflitti</title>
   <para>
    Se due Trait inseriscono un metodo con lo stesso nome, viene prodotto un
    errore fatale se il conflitto non viene risolto esplicitamente.
   </para>
   <para>
    Per risolvere i conflitti di denominazione tra Trait utilizzati nella stessa
    classe, è necessario usare l'operatore <literal>insteadof</literal> per
    scegliere esattamente uno dei metodi in conflitto.
   </para>
   <para>
    Poiché questo permette solo di escludere metodi, l'operatore
    <literal>as</literal> può essere usato per aggiungere un alias a uno dei
    metodi. Si noti che l'operatore <literal>as</literal> non rinomina il
    metodo e non influisce su nessun altro metodo.
   </para>
   <example xml:id="language.oop5.traits.conflict.ex1">
    <title>Risoluzione dei conflitti</title>
    <para>
      In questo esempio, Talker usa i trait A e B.
      Poiché A e B hanno metodi in conflitto, viene definito di usare
      la variante di smallTalk dal trait B, e la variante di bigTalk dal
      trait A.
    </para>
    <para>
      Aliased_Talker fa uso dell'operatore <literal>as</literal>
      per poter usare l'implementazione di bigTalk di B con un alias
      aggiuntivo <literal>talk</literal>.
    </para>
    <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php
trait A {
    public function smallTalk() {
        echo 'a';
    }
    public function bigTalk() {
        echo 'A';
    }
}

trait B {
    public function smallTalk() {
        echo 'b';
    }
    public function bigTalk() {
        echo 'B';
    }
}

class Talker {
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
    }
}

class Aliased_Talker {
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
        B::bigTalk as talk;
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.traits.visibility">
   <title>Modifica della visibilità dei metodi</title>
   <para>
    Utilizzando la sintassi <literal>as</literal>, è anche possibile regolare
    la visibilità del metodo nella classe che lo espone.
   </para>
   <example xml:id="language.oop5.traits.visibility.ex1">
    <title>Modifica della visibilità dei metodi</title>
    <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php
trait HelloWorld {
    public function sayHello() {
        echo 'Hello World!';
    }
}

// Modifica la visibilità di sayHello
class MyClass1 {
    use HelloWorld { sayHello as protected; }
}

// Alias del metodo con visibilità modificata
// la visibilità di sayHello non viene cambiata
class MyClass2 {
    use HelloWorld { sayHello as private myPrivateHello; }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.traits.composition">
   <title>Trait composti da Trait</title>
   <para>
    Così come le classi possono usare i trait, anche altri trait possono farlo.
    Usando uno o più trait nella definizione di un trait, questo può essere
    composto parzialmente o interamente dai membri definiti in quegli altri trait.
   </para>
   <example xml:id="language.oop5.traits.composition.ex1">
    <title>Trait composti da Trait</title>
    <programlisting role="php">
<![CDATA[
<?php
trait Hello {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait World {
    public function sayWorld() {
        echo 'World!';
    }
}

trait HelloWorld {
    use Hello, World;
}

class MyHelloWorld {
    use HelloWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
$o->sayWorld();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Hello World!
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.traits.abstract">
   <title>Membri astratti dei Trait</title>
   <para>
    I Trait supportano l'uso di metodi astratti per imporre requisiti
    alla classe che li espone. Sono supportati i metodi pubblici, protetti e
    privati. Prima di PHP 8.0.0, erano supportati solo i metodi astratti
    pubblici e protetti.
   </para>
   <caution>
    <simpara>
     A partire da PHP 8.0.0, la firma di un metodo concreto deve seguire le
     <link linkend="language.oop.lsp">regole di compatibilità della firma</link>.
     In precedenza, la firma poteva essere diversa.
    </simpara>
   </caution>
   <example xml:id="language.oop5.traits.abstract.ex1">
    <title>Esprimere requisiti tramite metodi astratti</title>
    <programlisting role="php">
<![CDATA[
<?php
trait Hello {
    public function sayHelloWorld() {
        echo 'Hello'.$this->getWorld();
    }
    abstract public function getWorld();
}

class MyHelloWorld {
    private $world;
    use Hello;
    public function getWorld() {
        return $this->world;
    }
    public function setWorld($val) {
        $this->world = $val;
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.traits.static">
   <title>Membri statici dei Trait</title>
   <para>
    I Trait possono definire variabili statiche, metodi statici e proprietà
    statiche.
   </para>
   <note>
    <para>
     A partire da PHP 8.1.0, la chiamata di un metodo statico o l'accesso a una
     proprietà statica direttamente su un trait è deprecata. I metodi statici e
     le proprietà statiche devono essere accessibili solo su una classe che usa
     il trait.
    </para>
   </note>
   <example xml:id="language.oop5.traits.static.ex1">
    <title>Variabili statiche</title>
    <programlisting role="php">
<![CDATA[
<?php

trait Counter
{
    public function inc()
    {
        static $c = 0;
        $c = $c + 1;
        echo "$c\n";
    }
}

class C1
{
    use Counter;
}

class C2
{
    use Counter;
}

$o = new C1();
$o->inc();
$p = new C2();
$p->inc();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
1
1
]]>
    </screen>
   </example>
   <example xml:id="language.oop5.traits.static.ex2">
    <title>Metodi statici</title>
    <programlisting role="php">
<![CDATA[
<?php

trait StaticExample
{
    public static function doSomething()
    {
        return 'Doing something';
    }
}

class Example
{
    use StaticExample;
}

echo Example::doSomething();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Doing something
]]>
    </screen>
   </example>
   <example xml:id="language.oop5.traits.static.ex3">
    <title>Proprietà statiche</title>
    <caution>
     <simpara>
      Prima di PHP 8.3.0, le proprietà statiche definite in un trait erano
      condivise tra tutte le classi nella stessa gerarchia di ereditarietà che
      usavano quel trait. A partire da PHP 8.3.0, se una classe figlia usa un
      trait con una proprietà statica, questa sarà considerata distinta da
      quella definita nella classe genitore.
     </simpara>
    </caution>
    <programlisting role="php">
     <![CDATA[
<?php

trait T
{
    public static $counter = 1;
}

class A
{
    use T;

    public static function incrementCounter()
    {
        static::$counter++;
    }
}

class B extends A
{
    use T;
}

A::incrementCounter();

echo A::$counter, "\n";
echo B::$counter, "\n";

?>
]]>
    </programlisting>
    &example.outputs.83;
    <screen>
<![CDATA[
2
1
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.traits.properties">
   <title>Proprietà</title>
   <para>
    I Trait possono anche definire proprietà.
   </para>
   <example xml:id="language.oop5.traits.properties.example">
    <title>Definizione di proprietà</title>
    <programlisting role="php">
<![CDATA[
<?php

trait PropertiesTrait
{
    public $x = 1;
}

class PropertiesExample
{
    use PropertiesTrait;
}

$example = new PropertiesExample();
$example->x;

?>
]]>
    </programlisting>
   </example>
   <para>
    Se un trait definisce una proprietà, una classe non può definire una
    proprietà con lo stesso nome a meno che non sia compatibile (stessa
    visibilità e tipo, modificatore readonly e valore iniziale), altrimenti
    viene emesso un errore fatale.
   </para>
   <example xml:id="language.oop5.traits.properties.conflicts">
    <title>Risoluzione dei conflitti</title>
    <programlisting role="php">
<![CDATA[
<?php
trait PropertiesTrait {
    public $same = true;
    public $different1 = false;
    public bool $different2;
    public bool $different3;
}

class PropertiesExample {
    use PropertiesTrait;
    public $same = true;
    public $different1 = true; // Errore fatale
    public string $different2; // Errore fatale
    readonly protected bool $different3; // Errore fatale
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

 <sect2 xml:id="language.oop5.traits.constants">
  <title>&Constants;</title>
  <para>
   I Trait possono, a partire da PHP 8.2.0, anche definire costanti.
  </para>
  <example xml:id="language.oop5.traits.constants.example">
   <title>Definizione di costanti</title>
   <programlisting role="php">
<![CDATA[
<?php
trait ConstantsTrait {
    public const FLAG_MUTABLE = 1;
    final public const FLAG_IMMUTABLE = 5;
}

class ConstantsExample {
    use ConstantsTrait;
}

$example = new ConstantsExample;
echo $example::FLAG_MUTABLE;
?>
]]>
   </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
1
]]>
    </screen>
  </example>
  <para>
   Se un trait definisce una costante, una classe non può definire una costante
   con lo stesso nome a meno che non sia compatibile (stessa visibilità, valore
   iniziale e finalità), altrimenti viene emesso un errore fatale.
  </para>
  <example xml:id="language.oop5.traits.constants.conflicts">
   <title>Risoluzione dei conflitti</title>
   <programlisting role="php">
<![CDATA[
<?php
trait ConstantsTrait {
    public const FLAG_MUTABLE = 1;
    final public const FLAG_IMMUTABLE = 5;
}

class ConstantsExample {
    use ConstantsTrait;
    public const FLAG_IMMUTABLE = 5; // Errore fatale
}
?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.traits.final-methods">
  <title>Metodi final</title>
  <simpara>
   A partire da PHP 8.3.0, il modificatore <link linkend="language.oop5.final">final</link>
   può essere applicato usando l'operatore <literal>as</literal>
   ai metodi importati dai trait. Questo può essere usato per impedire alle
   classi figlie di sovrascrivere il metodo. Tuttavia, la classe che usa il
   trait può comunque sovrascrivere il metodo.
  </simpara>
  <example xml:id="language.oop5.traits.final-methods.example">
   <title>Definire un metodo proveniente da un trait come <literal>final</literal></title>
   <programlisting role="php">
    <![CDATA[
<?php

trait CommonTrait
{
    public function method()
    {
        echo 'Hello';
    }
}

class FinalExampleA
{
    use CommonTrait {
        CommonTrait::method as final; // Il 'final' impedisce alle classi figlie di sovrascrivere il metodo
    }
}

class FinalExampleB extends FinalExampleA
{
    public function method() {}
}

?>
]]>
   </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Fatal error: Cannot override final method FinalExampleA::method() in ...
]]>
    </screen>
  </example>
 </sect2>

 </sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
