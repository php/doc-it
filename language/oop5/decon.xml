<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 82fc6a1c8670b96f1bd2b40932b6eb19929f4f6f Maintainer: lacatoire Status: ready -->
 <sect1 xml:id="language.oop5.decon" xmlns="http://docbook.org/ns/docbook">
  <title>Costruttori e Distruttori</title>

  <sect2 xml:id="language.oop5.decon.constructor">
   <title>Costruttore</title>
   <methodsynopsis xml:id="object.construct">
    <type>void</type><methodname>__construct</methodname>
    <methodparam rep="repeat"><type>mixed</type><parameter>values</parameter><initializer>""</initializer></methodparam>
   </methodsynopsis>
   <para>
    PHP consente agli sviluppatori di dichiarare metodi costruttore per le classi.
    Le classi che hanno un metodo costruttore chiamano questo metodo su ogni
    oggetto appena creato, rendendolo adatto a qualsiasi inizializzazione di cui
    l'oggetto potrebbe aver bisogno prima di essere utilizzato.
   </para>
   <note>
    <simpara>
     I costruttori genitori non vengono chiamati implicitamente se la classe figlia definisce
     un costruttore. Per eseguire un costruttore genitore, è necessaria una chiamata a
     <function>parent::__construct</function> all'interno del costruttore figlio.
     Se il figlio non definisce un costruttore, può essere ereditato
     dalla classe genitore come un normale metodo di classe (se non è stato dichiarato
     come private).
    </simpara>
   </note>
   <example>
    <title>Costruttori nell'ereditarietà</title>
    <programlisting role="php">
<![CDATA[
<?php
class BaseClass {
    function __construct() {
        print "In BaseClass constructor\n";
    }
}

class SubClass extends BaseClass {
    function __construct() {
        parent::__construct();
        print "In SubClass constructor\n";
    }
}

class OtherSubClass extends BaseClass {
    // eredita il costruttore di BaseClass
}

// In BaseClass constructor
$obj = new BaseClass();

// In BaseClass constructor
// In SubClass constructor
$obj = new SubClass();

// In BaseClass constructor
$obj = new OtherSubClass();
?>
]]>
    </programlisting>
   </example>
   <para>
    A differenza degli altri metodi, <link linkend="object.construct">__construct()</link>
    è esente dalle normali
    <link linkend="language.oop.lsp">regole di compatibilità delle firme</link>
    quando viene esteso.
   </para>
   <para>
    I costruttori sono metodi ordinari che vengono chiamati durante l'istanziazione del
    loro oggetto corrispondente. Come tali, possono definire un numero arbitrario di argomenti, che
    possono essere obbligatori, possono avere un tipo e possono avere un valore predefinito. Gli argomenti del costruttore
    vengono chiamati inserendo gli argomenti tra parentesi dopo il nome della classe.
   </para>
   <example>
    <title>Utilizzo degli argomenti del costruttore</title>
    <programlisting role="php">
<![CDATA[
<?php
class Point {
    protected int $x;
    protected int $y;

    public function __construct(int $x, int $y = 0) {
        $this->x = $x;
        $this->y = $y;
    }
}

// Passa entrambi i parametri.
$p1 = new Point(4, 5);
// Passa solo il parametro obbligatorio. $y prenderà il valore predefinito 0.
$p2 = new Point(4);
// Con parametri nominati (a partire da PHP 8.0):
$p3 = new Point(y: 5, x: 4);
?>
]]>
    </programlisting>
   </example>
   <para>
    Se una classe non ha costruttore, o il costruttore non ha argomenti obbligatori, le parentesi
    possono essere omesse.
   </para>
   <sect3>
    <title>Costruttori vecchio stile</title>
    <para>
     Prima di PHP 8.0.0, le classi nello spazio dei nomi globale interpretavano un metodo con lo stesso
     nome della classe come costruttore vecchio stile. Quella sintassi è deprecata
     e genererà un errore <constant>E_DEPRECATED</constant> ma chiamerà comunque quella funzione come costruttore.
     Se sia <link linkend="object.construct">__construct()</link> che un metodo con lo stesso nome sono
     definiti, verrà chiamato <link linkend="object.construct">__construct()</link>.
    </para>
    <para>
     Nelle classi con namespace, o in qualsiasi classe a partire da PHP 8.0.0, un metodo con lo
     stesso nome della classe non ha mai alcun significato speciale.
    </para>
    <para>Utilizzare sempre <link linkend="object.construct">__construct()</link> nel nuovo codice.
    </para>
   </sect3>
   <sect3 xml:id="language.oop5.decon.constructor.promotion">
    <title>Promozione dei parametri del costruttore</title>
    <para>
     A partire da PHP 8.0.0, i parametri del costruttore possono anche essere promossi per corrispondere a
     una proprietà dell'oggetto. È molto comune che i parametri del costruttore vengano assegnati a
     una proprietà nel costruttore senza essere altrimenti utilizzati. La promozione del costruttore
     fornisce una scorciatoia per questo caso d'uso. L'esempio precedente può essere riscritto come segue.
    </para>
    <example>
     <title>Utilizzo della promozione delle proprietà del costruttore</title>
     <programlisting role="php">
<![CDATA[
<?php
class Point {
    public function __construct(protected int $x, protected int $y = 0) {
    }
}
]]>
     </programlisting>
    </example>
    <para>
     Quando un argomento del costruttore include un modificatore, PHP lo interpreterà sia come
     una proprietà dell'oggetto che come un argomento del costruttore, e assegnerà il valore dell'argomento
     alla proprietà. Il corpo del costruttore può quindi essere vuoto o può contenere altre istruzioni.
     Eventuali istruzioni aggiuntive verranno eseguite dopo che i valori degli argomenti saranno stati assegnati
     alle proprietà corrispondenti.
    </para>
    <para>
     Non tutti gli argomenti devono essere promossi. È possibile mescolare argomenti promossi e non promossi,
     in qualsiasi ordine. Gli argomenti promossi non hanno alcun impatto sul codice che chiama il costruttore.
    </para>
    <note>
     <para>
      L'uso di un <link linkend="language.oop5.visibility">modificatore di visibilità</link> (<literal>public</literal>,
      <literal>protected</literal> o <literal>private</literal>) è il modo più comune per applicare la promozione
      delle proprietà, ma qualsiasi altro singolo modificatore (come <literal>readonly</literal>) avrà lo stesso effetto.
     </para>
    </note>
    <note>
     <para>
      Le proprietà degli oggetti non possono essere tipizzate come <type>callable</type> a causa di un'ambiguità del motore.
      Di conseguenza, anche gli argomenti promossi non possono essere tipizzati come <type>callable</type>. Qualsiasi
      altra <link linkend="language.types.declarations">dichiarazione di tipo</link> è invece consentita.
     </para>
    </note>
    <note>
     <para>
      Poiché le proprietà promosse vengono tradotte sia in una proprietà che in un parametro di funzione, qualsiasi
      e tutte le restrizioni di denominazione per entrambe le proprietà e i parametri si applicano.
     </para>
    </note>
    <note>
     <para>
      Gli <link linkend="language.attributes">attributi</link> posti su un
      argomento del costruttore promosso verranno replicati sia sulla proprietà
      che sull'argomento. I valori predefiniti su un argomento del costruttore promosso verranno replicati solo sull'argomento e non sulla proprietà.
     </para>
    </note>
   </sect3>

   <sect3 xml:id="language.oop5.decon.constructor.new">
    <title>New negli inizializzatori</title>
    <para>
     A partire da PHP 8.1.0, gli oggetti possono essere utilizzati come valori predefiniti dei parametri,
     variabili statiche e costanti globali, così come negli argomenti degli attributi.
     Gli oggetti possono anche essere passati a <function>define</function>.
    </para>
    <note>
     <para>
      L'uso di un nome di classe dinamico o non stringa o di una classe anonima non è consentito.
      L'uso dell'unpacking degli argomenti non è consentito.
      L'uso di espressioni non supportate come argomenti non è consentito.
     </para>
    </note>
    <example>
     <title>Utilizzo di new negli inizializzatori</title>
     <programlisting role="php" annotations="non-interactive">
<![CDATA[
<?php

// Tutti consentiti:
static $x = new Foo;

const C = new Foo;

function test($param = new Foo) {}

#[AnAttribute(new Foo)]
class Test {
    public function __construct(
        public $prop = new Foo,
    ) {}
}

// Tutti non consentiti (errore in fase di compilazione):
function test(
    $a = new (CLASS_NAME_CONSTANT)(), // nome di classe dinamico
    $b = new class {}, // classe anonima
    $c = new A(...[]), // unpacking degli argomenti
    $d = new B($abc), // espressione costante non supportata
) {}
?>
]]>
     </programlisting>
    </example>
   </sect3>

   <sect3 xml:id="language.oop5.decon.constructor.static">
    <title>Metodi di creazione statici</title>
    <para>
     PHP supporta un solo costruttore per classe. In alcuni casi, tuttavia, può essere
     desiderabile consentire la costruzione di un oggetto in modi diversi con input diversi.
     Il modo raccomandato per farlo è utilizzare metodi statici come wrapper del costruttore.
    </para>
    <example>
     <title>Utilizzo di metodi di creazione statici</title>
     <programlisting role="php">
<![CDATA[
<?php
$some_json_string = '{ "id": 1004, "name": "Elephpant" }';
$some_xml_string = "<animal><id>1005</id><name>Elephpant</name></animal>";

class Product {

    private ?int $id;
    private ?string $name;

    private function __construct(?int $id = null, ?string $name = null) {
        $this->id = $id;
        $this->name = $name;
    }

    public static function fromBasicData(int $id, string $name): static {
        $new = new static($id, $name);
        return $new;
    }

    public static function fromJson(string $json): static {
        $data = json_decode($json, true);
        return new static($data['id'], $data['name']);
    }

    public static function fromXml(string $xml): static {
        $data = simplexml_load_string($xml);
        $new = new static();
        $new->id = (int) $data->id;
        $new->name = $data->name;
        return $new;
    }
}

$p1 = Product::fromBasicData(5, 'Widget');
$p2 = Product::fromJson($some_json_string);
$p3 = Product::fromXml($some_xml_string);

var_dump($p1, $p2, $p3);
]]>
     </programlisting>
    </example>
    <para>
     Il costruttore può essere reso private o protected per impedirne la chiamata dall'esterno.
     In tal caso, solo un metodo statico sarà in grado di istanziare la classe. Poiché si trovano nella
     stessa definizione di classe, hanno accesso ai metodi privati, anche se non della stessa istanza
     dell'oggetto. Il costruttore privato è opzionale e può o meno avere senso a seconda del
     caso d'uso.
    </para>
    <para>
     I tre metodi statici pubblici dimostrano poi diversi modi di istanziare l'oggetto.
    </para>
    <simplelist>
     <member><code>fromBasicData()</code> accetta i parametri esatti necessari, quindi crea
      l'oggetto chiamando il costruttore e restituendo il risultato.</member>
     <member><code>fromJson()</code> accetta una stringa JSON e la pre-elabora
     per convertirla nel formato desiderato dal costruttore. Quindi restituisce il nuovo oggetto.</member>
     <member><code>fromXml()</code> accetta una stringa XML, la pre-elabora, e quindi crea un
     oggetto vuoto. Il costruttore viene comunque chiamato, ma poiché tutti i parametri sono opzionali il metodo
     li salta. Quindi assegna i valori alle proprietà dell'oggetto direttamente prima di restituire il risultato.</member>
    </simplelist>
    <para>
     In tutti e tre i casi, la parola chiave <code>static</code> viene tradotta nel nome della classe in cui si trova il codice.
     In questo caso, <code>Product</code>.
    </para>
   </sect3>
  </sect2>
  <sect2 xml:id="language.oop5.decon.destructor">
   <title>Distruttore</title>
   <methodsynopsis xml:id="object.destruct">
    <type>void</type><methodname>__destruct</methodname>
    <void />
   </methodsynopsis>
   <para>
    PHP possiede un concetto di distruttore simile a quello di altri
    linguaggi orientati agli oggetti, come il C++. Il metodo distruttore verrà
    chiamato non appena non ci saranno più altri riferimenti a un particolare oggetto,
    o in qualsiasi ordine durante la sequenza di spegnimento.
   </para>
   <example>
    <title>Esempio di distruttore</title>
    <programlisting role="php">
<![CDATA[
<?php

class MyDestructableClass
{
    function __construct() {
        print "In constructor\n";
    }

    function __destruct() {
        print "Destroying " . __CLASS__ . "\n";
    }
}

$obj = new MyDestructableClass();

]]>
    </programlisting>
   </example>
   <para>
    Come i costruttori, i distruttori genitori non verranno chiamati implicitamente dal
    motore. Per eseguire un distruttore genitore, è necessario
    chiamare esplicitamente <function>parent::__destruct</function> nel corpo del distruttore.
    Inoltre, come i costruttori, una classe figlia può ereditare il distruttore del genitore
    se non ne implementa uno proprio.
   </para>
   <para>
    Il distruttore verrà chiamato anche se l'esecuzione dello script viene interrotta usando
    <function>exit</function>. Chiamare <function>exit</function> in un distruttore
    impedirà l'esecuzione delle restanti routine di spegnimento.
   </para>
   <para>
    Se un distruttore crea nuovi riferimenti al suo oggetto, non verrà chiamato
    una seconda volta quando il contatore dei riferimenti raggiunge nuovamente zero o durante la
    sequenza di spegnimento.
   </para>
   <para>
    A partire da PHP 8.4.0, quando
    la <link linkend="features.gc.collecting-cycles">raccolta dei cicli</link>
    avviene durante l'esecuzione di una
    <link linkend="language.fibers">Fiber</link>, i distruttori degli oggetti
    programmati per la raccolta vengono eseguiti in una Fiber separata, chiamata
    <literal>gc_destructor_fiber</literal>.
    Se questa Fiber viene sospesa, ne verrà creata una nuova per eseguire eventuali
    distruttori rimanenti.
    La precedente <literal>gc_destructor_fiber</literal> non sarà più
    referenziata dal garbage collector e potrà essere raccolta se non è
    referenziata altrove.
    Gli oggetti il cui distruttore è sospeso non verranno raccolti fino a quando il
    distruttore non restituisce o la Fiber stessa non viene raccolta.
   </para>
   <note>
    <para>
     I distruttori chiamati durante lo spegnimento dello script hanno gli header HTTP già
     inviati. La directory di lavoro nella fase di spegnimento dello script può essere diversa
     con alcuni SAPI (ad es. Apache).
    </para>
   </note>
   <note>
    <para>
     Tentare di lanciare un'eccezione da un distruttore (chiamato durante la fase di
     terminazione dello script) causa un errore fatale.
    </para>
   </note>
  </sect2>

 </sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
