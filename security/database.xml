<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 7204e2dbb9b484c8b67bb5ad4a93fa1369c5b317 Maintainer: ManueldG Status: ready -->
  <chapter xml:id="security.database" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
   <title>Sicurezza del Database</title>

   <simpara>
    Al giorno d'oggi, i database sono componenti essenziali di qualsiasi
    applicazione basata sul Web, consentendo ai siti Web di fornire molti contenuti
    dinamici. Poiché anche le informazioni sensibili o segrete possono
    essere archiviate in un database, dovresti prendere seriamente in considerazione di 
    proteggere i tuoi database.
   </simpara>
   <simpara>
    Per recuperare o archiviare qualsiasi informazione di cui hai bisogno per connetterti al database,
    eseguire una query, recuperare il risultato e quindi chiudere la connessione.
    Oggigiorno, il linguaggio più utilizzato per questo tipo di interazione è 
    l'SQL (Structured Query Language). Di seguito viene mostrato come un'aggressore può <link
    linkend="security.database.sql-injection">manometterlo con una query SQL</link>.
   </simpara>
   <simpara>
    Da come si può immaginare, <acronym>PHP</acronym> non può proteggere da solo il database. 
    Le prossime sezioni puntano a introdurre le modalità di come
    accedere e manipolare ai database all'interno di uno script <acronym>PHP</acronym>.
   </simpara>
   <simpara>
    Bisogna tener presente questa semplice regola: (Defense in Depth) difesa in profondità. Più prendi provvedimenti
    per aumentare la sicurezza del database, minore è probabilità che un utente malintenzionato
    riesca ad accedere o abusare di eventuali dati archiviati. Una buona progettazione
    dello schema del database e dell'applicazione previene le tue più grandi paure.
   </simpara>

   <sect1 xml:id="security.database.design"> 
    <title>Progettazione del database</title>
     <simpara>
      Il primo passo è quello di creare il database, a meno che non si voglia utilizzarne uno
      di terze parti. Una volta creato il database, viene assegnato un proprietario, 
      a chi ha eseguito l'istruzione di creazione. Di solito, solo il proprietario 
      (o l'amministratore) può fare qualsiasi cosa con gli oggetti di quel database e, 
      per consentire ad altri utenti di utilizzarlo, gli devono essere concessi dei privilegi.
     </simpara>
     <simpara>
      Le applicazioni non dovrebbero mai connettersi al database come proprietario o 
      amministratore, poiché questi utenti possono eseguire qualsiasi query a piacimento, 
      ad esempio, potrebbero modificare lo schema (ad esempio eliminando le tabelle) o potrebbero 
      eliminare l'intero contenuto.
     </simpara>
     <simpara>
      E' possibile creare vari utenti del database uno per ogni ruolo della tua applicazione
      con diritti molto limitati sugli elementi del database. Dovrebbero essere concessi
      solo i privilegi necessari per evitare che lo stesso utente possa modificare
      il database tramite le diverse funzionalità. Ciò significa che se gli intrusi ottengono 
      l'accesso al tuo database utilizzando le credenziali delle tue applicazioni, 
      potrebbero apportare tutte le modifiche quante ne sono previste dai privilegi.
     </simpara> 
   </sect1>

   <sect1 xml:id="security.database.connection">
    <title>Connessione al database</title>
    <simpara>
     E' possibile per una maggiore sicurezza stabilire connessioni SSL per criptare le
     comunicazioni client/server oppure è possibile utilizzare SSH
     per criptare la connessione di rete tra i client e il server del database.
     Se viene utilizzato uno di questi sistemi, sarà difficile monitorare il traffico e ottenere
     le informazioni del tuo database da parte di un potenziale malintenzionato.
    </simpara>
    <simpara>
     Se il server del database ha il supporto nativo SSL, si può considerare l'uso delle funzioni <link
     linkend="ref.openssl">OpenSSL</link> per comunicazioni tra
     <acronym>PHP</acronym> e database tramite SSL.
    </simpara>
   </sect1>

   <sect1 xml:id="security.database.storage"> <!-- tradurlo o lasciarlo in Inglese? - Encrypted Storage Model-->
    <title>Modello d'archiviazione crittografato</title>
    <simpara>
     SSL/SSH protegge i dati che viaggiano dal client al server: SSL/SSH
     non protegge i dati persistenti archiviati in un database. SSL è un
     protocollo on-the-wire.
    </simpara>
    <simpara>
     Una volta che un utente malintenzionato ottiene l'accesso diretto al tuo database (aggirando il server web), 
     i dati sensibili memorizzati potrebbero essere esposti o utilizzati in modo improprio, a meno che
     le informazioni siano protette dal database stesso. La crittografia dei dati
     è un buon modo per limitare questa minaccia, ma pochissimi database offrono
     questo tipo di crittografia dei dati.
    </simpara>
    <simpara> <!--XXX pacchetto?? classe libreria funzione   -->
     Il modo più semplice per aggirare il problema è innanzitutto creare il proprio pacchetto di crittografia,<!-- classe o funzione-->
     e quindi utilizzarlo nei tuoi script <acronym>PHP</acronym>. <acronym>PHP</acronym>
     può aiutarti con diverse estensioni, come <link
     linkend="book.openssl">OpenSSL</link> o <link
     linkend="book.sodium">Sodium</link>, che impiega un'ampia varietà di algoritmi di crittografia. <!-- vanta usa impiega-->
     Lo script cripta i dati prima di inserirli nel database e li decripta
     durante il recupero. Vedere i riferimenti per ulteriori esempi 
     su come funziona la crittografia.
    </simpara>

    <sect2 xml:id="security.database.storage.hashing">
    <title>Hashing</title>
     <simpara>
      Nel caso di dati veramente segreti <!--estremamente /privati- segreti -->, se non è necessaria la loro rappresentazione originale <!--originale - in chiaro - grezza -->
      (p.es. non dev'essere visualizzato), è necessario prendere in considerazione l'hashing.
      Un'esempio ben noto di hashing <!-- è la memorizzazione della password criptata tramite hashing  -->
      è il salvataggio dell'hash della password nel database, 
      invece della password stessa.
     </simpara>
     <simpara>
      Le funzioni per le <link linkend="ref.password">password</link>
      possono fornire un modo semplice per eseguire l'hashing dei dati sensibili e lavorare con questi hash.
     </simpara>
     <simpara>
      <function>password_hash</function> viene utilizzato per eseguire l'hashing di una determinata stringa utilizzando
      l'algoritmo più potente attualmente disponibile e <function>password_verify</function>
      controlla se la password fornita corrisponde all'hash memorizzato nel database.
     </simpara>
     <example> 
      <title>Campo per l'Hash della password</title>
      <programlisting role="php">
      <!--tradurre-->
<![CDATA[ 
<?php

// storing password hash
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            pg_escape_string($username),
            password_hash($password, PASSWORD_DEFAULT));
$result = pg_query($connection, $query);

// querying if user submitted the right password
$query = sprintf("SELECT pwd FROM users WHERE name='%s';",
            pg_escape_string($username));
$row = pg_fetch_assoc(pg_query($connection, $query));

if ($row && password_verify($password, $row['pwd'])) {
    echo 'Welcome, ' . htmlspecialchars($username) . '!';
} else {
    echo 'Authentication failed for ' . htmlspecialchars($username) . '.';
}

?>
]]>
      </programlisting>
     </example>
    </sect2>
   </sect1>
   <sect1 xml:id="security.database.sql-injection">
    <title>SQL Injection</title>
    <simpara>
     L'SQL injection è una tecnica dove un'utente malintenzionato sfrutta i difetti del
     codice responsabile della creazione di query SQL dinamiche.
     L'aggressore può accedere a sezioni privilegiate dell'applicazione,
     recuperare tutte le informazioni dal database, manomettere i dati esistenti,
     o addirittura eseguire comandi pericolosi a livello di sistema Host dul database. 
     La vulnerabilità si verifica quando gli sviluppatori concatenano o
     interpolano dati arbitrari nelle loro istruzioni SQL.
    </simpara>
    <para>
     <example>
      <title> 
       Dividere il set di risultati in pagine ... e creare amministratori <!-- amministratori -->
       (PostgreSQL)
      </title>
      <simpara>
       Nell'esempio seguente, l'input dell'utente viene interpolato direttamente nella
       Query SQL che consente all'aggressore di ottenere un account amministratore nel database.
      </simpara>
      <programlisting role="php">
<![CDATA[
<?php

$offset = $_GET['offset']; // beware, no input validation!
$query  = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";
$result = pg_query($conn, $query);

?>
]]>
      </programlisting>
     </example>
      Di solito gli utenti usano i collegamenti "next", "previous" dove l'<varname>$offset</varname>
      viene passato nell'<acronym>URL</acronym>. Lo script si aspetta che l'<varname>$offset</varname> 
      sia un numero. Tuttavia, cosa succede se qualcuno prova a craccarlo
      aggiungendo quanto segue all'<acronym>URL</acronym>?
      <informalexample>
       <programlisting role="sql">
<![CDATA[
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--
]]>
       </programlisting>
      </informalexample>
      Se ciò dovesse accadere, lo script fornirebbe un accesso d'amministratore all'aggressore.
      Tieni presente che <literal>0;</literal> fornisce un offset valido alla query originale 
      e la terminerebbe.
    </para>
    <note>
     <para>
      Una tecnica comune per forzare il parser SQL a ignorare il resto della richiesta
      query scritta dal programmatore è usare <literal>--</literal> che introduce <!-- con \-\- inserisce i commenti in sql -->
      i commenti in SQL.
     </para>
    </note>
    <para>
     Un modo possibile per ottenere le password è analizzare le pagine dei risultati di ricerca.
     L'unica cosa che l'attaccante deve fare è vedere se sono presenti variabili inviate
     utilizzate nelle istruzioni SQL che non vengono gestite correttamente. Questi filtri di solito possono essere impostati
     in un form usato precedentemente e personalizzarlo usando le clausole <literal>WHERE, ORDER BY,
     LIMIT</literal> e <literal>OFFSET</literal> nell'istruzione <literal>SELECT</literal>. 
     Se il database supporta il costrutto <literal>UNION</literal>,
     l'aggressore potrebbe tentare di aggiungere un'intera query a quella originale per far elencare <!-- in modo da -->
     le password da una tabella arbitraria. <!-- è fortemente consigliato salvare/inserire solo la chiave hash -->Si consiglia vivamente di salvare sole le secure hash delle password 
     anziché le password stesse.
     <example> <!-- XXX controllo -->
      <title>Elencare gli articoli... e alcune password (può essere usato su qualunque database server).</title>
      <programlisting role="php">
<![CDATA[
<?php

$query  = "SELECT id, name, inserted, size FROM products
           WHERE size = '$size'";
$result = odbc_exec($conn, $query);

?>
]]>
      </programlisting>
     </example>
     La parte statica della query può essere combinata con un'altra <literal>SELECT</literal>
     per rivelare tutte le password: <!-- statement which reveals all passwords:-->
     <informalexample>
      <programlisting role="sql">
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Anche le istruzioni <literal>UPDATE</literal> e <literal>INSERT</literal> sono
     suscettibili a tali attacchi.
     <example>
     <title>Dalla reimpostazione di una password... all'acquisizione di più privilegi (per qualsiasi database server)</title>
      <programlisting role="php">
<![CDATA[
<?php
$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
?>
]]>
      </programlisting>
     </example>
     Se un utente malintenzionato invia la stringa <!-- XXX da rivedere -->
     per cambiare la password dell'amministratore
     <literal>' or uid like '%admin%</literal> in <varname>$uid</varname>
      oppure impostare la variabile <varname>$pwd</varname> semplicemente con
     <literal>hehehe', trusted=100, admin='yes</literal> per ottenere  
     privilegi più elevati, la query verrà aggirata: <!-- craccata inquinata corrotta -->
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php

// $uid: ' or uid like '%admin%
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%';";

// $pwd: hehehe', trusted=100, admin='yes
$query = "UPDATE usertable SET pwd='hehehe', trusted=100, admin='yes' WHERE
...;";

?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara> 
     Mentre è scontato che un malintenzionato debba possederne almeno alcune nozioni 
     dell'architettura del database per condurre un'attacco ben riuscito <!-- a buon fine - riuscire -->, 
     è spesso molto semplice ottenere queste informazioni. Per esempio,
     il codice può far parte di un software open source ed essere disponibile al pubblico.
     Tali informazioni potranno anche essere divulgate
     tramite codice closed-source, anche se è codificato, offuscato o compilato -
     e anche tramite il proprio codice attraverso la visualizzazione di messaggi di errore
     Altri metodi includono l'uso di nomi di tabelle e colonne tipici.  Per
     ad esempio, un modulo d'accesso che utilizza una tabella "utenti" con nomi di colonne
     "id", "username" e "password".
    </simpara>
    <para>
     <example>

      <title>Attaccare il sistema operativo host del database (MSSQL Server)</title>
       <simpara>
        Un preoccupante esempio di come è possibile accedere ai comandi a livello di sistema operativo
        da parte di alcuni database su host.
       </simpara>

      <programlisting role="php">
<![CDATA[
<?php

$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);

?>
]]>
      </programlisting>
     </example>
     Se l'attaccante invia la stringa 
     <literal>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</literal>
     a <varname>$prod</varname>, quindi <varname>$query</varname> sarà:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php

$query  = "SELECT * FROM products
           WHERE id LIKE '%a%'
           exec master..xp_cmdshell 'net user test testpass /ADD' --%'";
$result = mssql_query($query);

?>
]]>
      </programlisting>
     </informalexample>
     MSSQL Server esegue le istruzioni SQL nel batch incluso un comando
     per aggiungere un nuovo utente al database degli account locali. Se questa applicazione
     era in esecuzione come <literal>sa</literal> e il servizio MSSQLSERVER era
     in esecuzione con privilegi sufficienti, l'utente malintenzionato ora avrebbe un'account
     con cui accedere a questa macchina.
    </para>
    <note>
     <para>
      Alcuni esempi sopra riportati sono legati ad uno specifico database, ma
      non significa che un attacco simile sia impossibile verso altri prodotti.
      Il tuo database potrebbe essere altrettanto vulnerabile in un altri modi.
     </para>
    </note>
    <para>
     <mediaobject>
      <alt>Un esempio divertente dei problemi riguardanti SQL injection</alt>
      <imageobject>
       <imagedata fileref="it/security/figures/xkcd-bobby-tables.png" format="PNG"/>
      </imageobject>
      <caption>
       <simpara>
        Image courtesy of <link xlink:href="&url.xkcd;327">xkcd</link>
       </simpara>
      </caption>
     </mediaobject>
    </para>

    <sect2 xml:id="security.database.avoiding">
     <title>Tecniche di elusione</title><!-- evasione - elusione  -->
     <para><!-- XXX poco chiaro-->
      Un modo consigliato per evitare l'SQL injection è associare tutti i dati 
      usando <!-- istruzioni preparate-->prepared-statements. L'utilizzo di query parametrizzate non è 
      sufficiente per evitare completamente l'injection SQL, ma è il modo più 
      semplice e sicuro per fornire l'input alle istruzioni SQL. Tutti i letterali
      di dati dinamici nelle clausole <literal>WHERE</literal>,
     <literal>SET</literal> e <literal>VALUES</literal> devono essere sostituiti
      con un segnaposto. I dati effettivi verranno trasposti<!--bindings trasposti trasposizione interpolazione--> durante l'esecuzione e 
      inviati separatamente dal comando SQL.
     </para>

     <para>
      Il binding dei parametri può essere utilizzato solo per i dati. Altre 
      parti dinamiche della query SQL devono essere filtrate in base a un elenco
      noto di valori consentiti.
     </para><!-- XXX tradotto poco chiaro -->
     <para>
      <example>
      <title> Eludere un'SQL injection usando PDO prepared Statement</title>
       <programlisting role="php">
<![CDATA[
<?php

// La parte SQL dinamica viene convalidata in base ai valori previsti 
$sortingOrder = $_GET['sortingOrder'] === 'DESC' ? 'DESC' : 'ASC';
$productId = $_GET['productId'];
// Il codice SQL viene trasposto con un placeholder
$stmt = $pdo->prepare("SELECT * FROM products WHERE id LIKE ? ORDER BY price {$sortingOrder}");
// Il valore è reso disponibile usando LIKE
$stmt->execute(["%{$productId}%"]);

?>
]]>
       </programlisting>
      </example>
     </para>

     <simpara>
      I Prepared statement sono forniti da
      <link linkend="pdo.prepared-statements">PDO</link>,
      <link linkend="mysqli.quickstart.prepared-statements"> MySQLi</link>,
      e da altre librerie per database.
     </simpara>     

     <simpara>
      Gli attacchi SQL injection sfruttano principalmente il codice scritto
      senza pensare<!--fare attenzione--> alla sicurezza. Non fidarti mai di nessun input, specialmente
      dal lato client, anche se proviene da un menu a tendina,
      un campo di input nascosto o un cookie. Il primo esempio mostra che una query così
      semplice può causare disastri.
    </simpara>

     <para>
      Una strategia di difesa in-depth comporta diverse Best Practics <!--buone pratiche--> di scrittura del codice:
      <itemizedlist>
       <listitem>
        <simpara>
         Non connettersi mai al database come amministratore o come proprietario. 
         Utilizzare sempre appositi utenti <!-- custom - ad hoc - mirati - appositi --> con privilegi minimi.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Controlla se l'input fornito è del tipo di dati previsto.<!-- controlla --> <acronym>PHP</acronym> ha
         una vasta gamma di funzioni per la convalida dell'input, da quelle più semplici
         che si trovano in <link linkend="ref.var">Funzioni variabili</link> e <!-- funzioni variabili -->
         in <link linkend="ref.ctype">Funzioni tipo carattere</link><!-- funzioni Ctype-->
         (es.: rispettivamente <function>is_numeric</function> e <function>ctype_digit</function>) 
         oltre al supporto per le <link linkend="ref.pcre">Espressioni regolari compatibili con Perl</link>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Se l'applicazione prevede un input numerico, prendere in considerazione la verifica dei dati
         con <function>ctype_digit</function>, modificare con discrezione il suo tipo
         usando <function>settype</function> o formattare la sua rappresentazione numerica
         con <function>sprintf</function>.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Se l'interfaccia <!-- il livello --> del database non supporta il binding delle variabili, allora
         va messo tra virgolette <!--quote--> ogni valore non numerico fornito dall'utente che viene passato al
         database con la specifica funzione di escape del database per le stringhe (ad esempio
         <function>mysql_real_escape_string</function>,
         <function>sqlite_escape_string</function>, ecc.).
         Le funzioni generiche come <function>addslashes</function> sono utili solo
         in un ambiente molto specifico<!--limitato--> (ad esempio MySQL in un set di caratteri a singolo byte
         con <varname>NO_BACKSLASH_ESCAPES</varname> disabilitato) e quindi è
         meglio evitarle.
         <function>mysql_real_escape_string</function>,
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Non far visualizare a qualunque costo le informazioni dettagliate del database 
         e in particolare la struttura <!-- schema --> <!--con mezzi leciti o illeciti-->. Vedere anche le sezioni<link
         linkend="security.errors">Segnalazione degli errori</link> e <link
         linkend="ref.errorfunc">Funzioni di gestione e registrazione degli errori</link>.
        </simpara>
       </listitem>
      </itemizedlist>
     </para>

     <simpara>
      Oltre a ciò, puoi trarre vantaggio dal log delle query tramite il tuo script <!-- cronologia - report - log - traccia- traking -->
      o, se lo supporta, attraverso il database stesso. Ovviamente, il log non è in grado
      di prevenire alcun tentativo d'attacco, ma può essere utile per capire quale
      applicazione è stata colpita. Il registro non è utile di per sé, ma
      sono utili le informazioni che contiene. Generalmente più dettagli ci sono nel log meglio è.
     </simpara>
    </sect2>
   </sect1>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
