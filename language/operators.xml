<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 3d9dad29c75a70e7985ed595dfa2a836e61418da Maintainer: pastore Status: ready -->
<!-- CREDITS: cucinato -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Operatori</title>
  <simpara>
   Un operatore è un qualcosa che si posiziona tra uno o più valori (od espressioni,
   in gergo tecnico) e produce un'altro valore (in modo tale che la costruzione
   stessa diventi a sua volta un'espressione). i
  </simpara>
  <para>
   Gli operatori possono essere raggruppati a seconda del numero di valori che trattano. Gli
   operatori unari quali richiedono un solo valore, ad esempio <literal>!</literal>i
   (l'<link linkend="language.operators.logical">operatore logico noti</link>) oppure
   <literal>++</literal> 
   (l'<link linkend="language.operators.increment">operatore di autoincremento</link>).
   Gli operatori binari accettano due valor, come i familiari
   <link linkend="language.operators.arithmetic">operatori aritmetici</link>
   <literal>+</literal> (più) e <literal>-</literal> (meno), e la
   maggior parte degli operatori disponibili in PHP ricadono in questa categoria. Infine, esiste un
   solo <link linkend="language.operators.comparison.ternary">operatore
   ternario</link>, <literal>? :</literal>, che accetta tre valori; viene
   normalmente chiamato "l'operatore ternario" (anche se potrebbe
   forse essere chiamato più precisamente operatore condizionale).
  </para>
  <para>
   Una lista completa degli operatore è fornita nella sezione
   <link linkend="language.operators.precedence">Precedenza degli operatori</link>.
   Questa sezione spiega anche la precedenza degli operatori e l'associatività, che stabiliscono
   esattamente come le espressioni contenenti differenti operatori sono
   valutate ed eseguite.
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>Precedenza degli operatori</title>
   <para>
    La precedenza di un operatore specifica come esso tenga legate assieme "strettamente" due
    espressioni. Per esempio, nell'espressione <literal>1 +
    5 * 3</literal>, la risposta è <literal>16</literal> e non
    <literal>18</literal> perché l'operatore di moltiplicazione ("*")
    ha una precedenza più alta rispetto all'operatore di addizione ("+").
    Le parentesi possono essere usate per forzare la precedenza, se necessario. Per
    esempio: <literal>(1 + 5) * 3</literal> viene valutata
    <literal>18</literal>.
   </para>
   <para>
    Quando gli operatori hanno precedenza identica, la loro associatività decide
    come gli operatori sono raggruppati. Per esempio "-" è associativo a sinistra, quindi
    <literal>1 - 2 - 3</literal> è raggruppato come <literal>(1 - 2) - 3</literal>
    e valutato come <literal>-4</literal>. D'altra parte "=" è
    associativo a destra, quindi <literal>$a = $b = $c</literal> è raggruppato come
    <literal>$a = ($b = $c)</literal>.
   </para>
   <para>
    Operatori di uguale precedenza che non sono associativi non possono essere usati
    vicini l'uno all'altro, per esempio <literal>1 &lt; 2 &gt; 1</literal> è
    illegale in PHP. D'altra parte l'espressione <literal>1 &lt;= 1 == 1</literal>
    è legale, perchè l'operatore <literal>==</literal> ha una minore
    precedenza dell'operatore <literal>&lt;=</literal>.
   </para>
   <para>
    L'associatività è significativa solo per gli operatori binari (e ternari).
    Gli operatori unari sono prefisso o suffisso, quindi questa nozione non è applicabile.
    Ad esempio <literal>!!$a</literal> può essere raggruppato solo come <literal>!(!$a)</literal>.
   </para>
   <para>
    L'uso delle parentesi, anche quando non strettamente necessario, può spesso aumentare
    la leggibilità del codice rendendo il raggruppamento esplicito piuttosto che fare affidamento
    sulla precedenza e sull'associatività implicite degli operatori.
   </para>
   <para>
    La seguente tabella fornisce una lista della precedenza degli operatori con gli
    operatori a più alta precedenza elencati prima. Gli operatori presenti nella medesima linea
    hanno uguale precedenza, in questi casi la loro associativià decide il raggruppamento.
    <table>
     <title>Precedenza degli operatori</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associatività</entry>
        <entry>Operatori</entry>
        <entry>Informazioni aggiuntive</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>(n/a)</entry>
        <entry>
         <literal>clone</literal>
         <literal>new</literal>
        </entry>
        <entry><link linkend="language.oop5.cloning">clone</link> e <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry><literal>**</literal></entry>
        <entry><link linkend="language.operators.arithmetic">operatori aritmetici</link></entry>
       </row>
       <row>
        <entry>(n/a)</entry>
        <entry>
         <literal>+</literal> 
         <literal>-</literal> 
         <literal>++</literal> 
         <literal>--</literal> 
         <literal>~</literal> 
         <literal>(int)</literal> 
         <literal>(float)</literal> 
         <literal>(string)</literal> 
         <literal>(array)</literal>
         <literal>(object)</literal> 
         <literal>(bool)</literal> 
         <literal>@</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritmetici</link> (unari <literal>+</literal> e <literal>-</literal>),
         <link linkend="language.operators.increment">incremento/decremento</link>,
         <link linkend="language.operators.bitwise">bitwise</link>,
         <link linkend="language.types.typecasting">casting del tipo</link>&listendand;
         <link linkend="language.operators.errorcontrol">controllo dell'errore</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>instanceof</literal></entry>
        <entry>
         <link linkend="language.operators.type">tipo</link>
        </entry>
       </row>
       <row>
        <entry>(n/a)</entry>
        <entry><literal>!</literal></entry>
        <entry>
         <link linkend="language.operators.logical">logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         <literal>*</literal>
         <literal>/</literal>
         <literal>%</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritmetici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         <literal>+</literal> 
         <literal>-</literal> 
         <literal>.</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritmetici</link> (binari <literal>+</literal> e <literal>-</literal>),
         <link linkend="language.operators.array">array</link>&listendand;
         <link linkend="language.operators.string">stringhe</link> (<literal>.</literal> prima di PHP 8.0.0)
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         <literal>&lt;&lt;</literal> 
         <literal>&gt;&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.bitwise">bit</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>.</literal></entry>
        <entry>
         <link linkend="language.operators.string">stringhe</link> (a partire da PHP 8.0.0)
        </entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>
         <literal>&lt;</literal> 
         <literal>&lt;=</literal> 
         <literal>&gt;</literal> 
         <literal>&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">confronto</link>
        </entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry>
         <literal>==</literal>
         <literal>!=</literal> 
         <literal>===</literal> 
         <literal>!==</literal> 
         <literal>&lt;&gt;</literal>
         <literal>&lt;=&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">operatori di confronto</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>&listendand;
         <link linkend="language.references">riferimenti</link></entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>^</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>|</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">operatori sui bit</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>&amp;&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>||</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>destra</entry>
        <entry><literal>??</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.coalesce">null coalescing</link>
        </entry>
       </row>
       <row>
        <entry>non associativi</entry>
        <entry><literal>? :</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">ternari</link>
         (associativi a sinistra prima di PHP 8.0.0)
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry>
         <literal>=</literal> 
         <literal>+=</literal> 
         <literal>-=</literal> 
         <literal>*=</literal> 
         <literal>**=</literal> 
         <literal>/=</literal> 
         <literal>.=</literal> 
         <literal>%=</literal> 
         <literal>&amp;=</literal> 
         <literal>|=</literal> 
         <literal>^=</literal> 
         <literal>&lt;&lt;=</literal> 
         <literal>&gt;&gt;=</literal>
         <literal>??=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.assignment">operatori di assegnazione</link>
        </entry>
       </row>
       <row>
        <entry>(n/a)</entry>
        <entry><literal>yield from</literal></entry>
        <entry>
         <link linkend="control-structures.yield.from">yield from</link>
        </entry>
       </row>
       <row>
        <entry>(n/a)</entry>
        <entry><literal>yield</literal></entry>
        <entry>
         <link linkend="control-structures.yield">yield</link>
        </entry>
       </row>
       <row>
        <entry>(n/a)</entry>
        <entry><literal>print</literal></entry>
        <entry><function>print</function></entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>and</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>xor</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
       <row>
        <entry>sinistra</entry>
        <entry><literal>or</literal></entry>
        <entry>
         <link linkend="language.operators.logical">operatori logici</link>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    <example>
     <title>Associatività</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// l'associatività dell'operatore ternario differisce da quella di C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2 (prima di PHP 8.0.0)

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
    </para>
   <para>
    La precedenza e l'associatività dell'operatore determinano solo come le espressioni
    sono raggruppate, esse non specificano un ordine di valutazione. PHP non
    specifica (nel caso generale) in quale ordine un'espressione è valutata
    e un codice che presuppone uno specifico ordine di valutazione dovrebbe essere evitato,
    perchè il comportamento può cambiare tra le versioni di PHP o in base al
    codice circostante.
    <example>
     <title>Ordine di valutazione indefinito</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // può stampare 2 o 3

$i = 1;
$array[$i] = $i++; // può impostare l'indice 1 o 2
?>
]]>
     </programlisting>
    </example>
    <example>
     <title><literal>+</literal>, <literal>-</literal> e <literal>.</literal> hanno la stessa precedenza (prima di PHP 8.0.0)</title>
     <programlisting role="php">
<![CDATA[
<?php
$x = 4;
// questa linea potrebbe causare un risultato inaspettato:
echo "x minus one equals " . $x-1 . ", or so I hope\n";
// perché è valutata come questa linea (prima di PHP 8.0.0):
echo (("x minus one equals " . $x) - 1) . ", or so I hope\n";
// la precedenza desiderata può essere forzata usando le parentesi:
echo "x minus one equals " . ($x-1) . ", or so I hope\n";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
-1, or so I hope
-1, or so I hope
x minus one equals 3, or so I hope
]]>
     </screen>
    </example>
   </para>
   <note>
    <para>
     Sebbene <literal>=</literal> abbia una precedenza minore rispetto
     alla maggior parte degli altri operatori, PHP permette comunque espressioni
     simili alla seguente: <literal>if (!$a = foo())</literal>,
     in questo caso l'output di <literal>foo()</literal> viene
     inserito in <varname>$a</varname>.
    </para>
   </note>
   <sect2 role="changelog">
    &reftitle.changelog;
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>8.0.0</entry>
        <entry>
         La concatenazione delle stringhe (<literal>.</literal>) ora ha una precedenza inferiore rispetto
         all'addizione/sottrazione aritmetica (<literal>+</literal> e <literal>-</literal>) e
         lo spostamento bit a bit a sinistra/destra (<literal>&lt;&lt;</literal> e <literal>&gt;&gt;</literal>);
         precedentemente aveva la stessa precedenza di <literal>+</literal> e <literal>-</literal>
         e una precedenza superiore a <literal>&lt;&lt;</literal> e <literal>&gt;&gt;</literal>.
        </entry>
       </row>
       <row>
        <entry>8.0.0</entry>
        <entry>
         L'operatore ternario (<literal>? :</literal>) ora è non-associativo;
         precedentemente era associativo a sinistra.
        </entry>
       </row>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Fare affidamento sulla precedenza della concatenazione di stringhe (<literal>.</literal>) rispetto all'
         addizione/sottrazione aritmetica (<literal>+</literal> o <literal>-</literal>) o
         lo spostamento bit a bit a sinistra/destra (<literal>&lt;&lt;</literal> o <literal>&gt;&gt;</literal>),
         ovvero utilizzarli insieme in un'espressione senza parentesi, è deprecato.
        </entry>
       </row>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Fare affidamento sull'associatività a sinistra dell'operatore ternario (<literal>? :</literal>),
         ovvero annidare più operatori ternari senza parentesi, è deprecato.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Operatori aritmetici</title>
   <simpara>
    Ricordate l'aritmetica di base dalla scuola? Questi operatori funzionano esattamente
    nello stesso modo.
   </simpara>
   <table>
    <title>Operatori aritmetici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>+$a</entry>
       <entry>Identità</entry>
       <entry>
        Conversione di <varname>$a</varname> in <type>int</type> o
        <type>float</type> in modo appropriato.
       </entry>
      </row>
      <row>
       <entry>-$a</entry>
       <entry>Negazione</entry>
       <entry>Opposto di <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Addizione</entry>
       <entry>La somma di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Sottrazione</entry>
       <entry>La differenza di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Moltiplicazione</entry>
       <entry>il prodotto di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Divisione</entry>
       <entry>Quoziente di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Modulo</entry>
       <entry>Il resto di <varname>$a</varname> diviso da <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a ** $b</entry>
       <entry>Elevamento a potenza</entry>
       <entry>Risultato di elevazione <varname>$a</varname> alla <varname>$b</varname>esima potenza.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    L'operatore di divisione ("/") restituisce un valore float a meno che i due operandi
    siano interi (oppure stringhe che vengono convertite in interi) e i numeri
    siano divisibili, nel qual caso viene restituito un valore intero. Per le
    divisioni di interi, vedere <function>intdiv</function>.
   </simpara>
   <simpara>
    Gli operandi del modulo sono convertiti in <type>int</type>
    prima dell'operazione. Per il modulo di numeri a virgola mobile, vedere
    <function>fmod</function>.
   </simpara>
   <para>
    Il risultato dell'operatore modulo <literal>%</literal> ha lo stesso segno
    del dividendo - ovvero, il risultato di <literal>$a % $b</literal>
    avrà lo stesso segno di <varname>$a</varname>. Per esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // prints 2
echo (5 % -3)."\n";          // prints 2
echo (-5 % 3)."\n";          // prints -2
echo (-5 % -3)."\n";         // prints -2

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.math">Funzioni matematiche</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Operatori di assegnazione</title>
   <simpara>
    L'operatore di base dell'assegnazione è "=". Il primo impulso può
    essere quello di pensare che corrisponda a "uguale a". Invece questo operatore significa che
    l'operando a sinistra assume il valore dell'espressione a
    destra (cioè, "assegna il valore a").
   </simpara>
   <para>
    Il valore di un'espressione di assegnazione è il valore assegnato. Ovvero
    il valore di "$a = 3" è 3. Questo permette di fare qualche
    trucchetto:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a è uguale a 9 ora, e $b è stato impostato a 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    In aggiunta all'operatore di base dell'assegnazione, ci sono gli "operatori
    combinati" per tutta <link linkend="language.operators">l'aritmetica binaria</link>
    e gli operatori di stringa
    che consentono di usare un valore in un'espressione e poi impostare il suo
    valore al risultato di quell'espressione. Per esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // imposta $a a 8, corrispondente a: $a = $a + 5;
$b = "Ciao ";
$b .= "come va?"; // imposta $b a "Ciao come va?", proprio come $b = $b . "come va?";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Si noti che l'assegnazione copia la variabile originale nella nuova
    (assegnazione per valore), così i cambiamenti della prima non si verificheranno nell'
    altra. Ciò può anche avere rilevanza se si ha bisogno di copiare
    un grande array in un ciclo molto stretto. 
   </para>
   <para>
    Un'eccezione al comportamento standard dell'assegnazione per valore avviene
    con gli<type>object</type>, che sono assegnati per riferimento.
    Gli oggetti possono essere copiati esplicitamente attraverso la keyword <link
    linkend="language.oop5.cloning">clone</link>.
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>Assegnazione per referimento</title>
    <para>
     L'assegnazione per riferimento è pure supportato, usando la sintassi
     "<computeroutput>$var = &amp;$othervar;</computeroutput>.
     'Assegnazione per riferimento' significa che entrambe le variabili finiscono con il puntare agli
     stessi dati, e nulla è copiato.
    </para>
    <para>
     <example>
      <title>Assegnare per riferimento</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b è un riferimento ad $a

print "$a\n"; // stampa 3
print "$b\n"; // stampa 3

$a = 4; // modifica $a

print "$a\n"; // stampa 4
print "$b\n"; // stampa ugualmente 4, dal momento che $b è un riferimento ad $a, che è
              // stata modificata
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     L'operatore <link linkend="language.oop5.basic.new">new</link>
     restituisce automaticamente un riferimento, quindi assegnare il risultato di
     <link linkend="language.oop5.basic.new">new</link> per riferimento è un errore.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

$o = &new C;
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Parse error: syntax error, unexpected 'new' (T_NEW) in …
]]>
      </screen>
     </informalexample>
    </para>
    <para>
     Ulteriori informazioni sui riferimenti e sul loro uso possono essere trovati
     nella sezione del manuale
     <link linkend="language.references">Spiegazioni sui riferimenti</link>.
    </para>
   </sect2>

   <sect2 xml:id="language.operators.assignment.arithmetic">
    <title>Operatori di Assegnamento Aritmetici</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Esempio</entry>
        <entry>Equivalente</entry>
        <entry>Operazione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a += $b</entry>
        <entry>$a = $a + $b</entry>
        <entry>Addizione</entry>
       </row>
       <row>
        <entry>$a -= $b</entry>
        <entry>$a = $a - $b</entry>
        <entry>Sottrazione</entry>
       </row>
       <row>
        <entry>$a *= $b</entry>
        <entry>$a = $a * $b</entry>
        <entry>Moltiplicazione</entry>
       </row>
       <row>
        <entry>$a /= $b</entry>
        <entry>$a = $a / $b</entry>
        <entry>Divisione</entry>
       </row>
       <row>
        <entry>$a %= $b</entry>
        <entry>$a = $a % $b</entry>
        <entry>Modulo</entry>
       </row>
       <row>
        <entry>$a **= $b</entry>
        <entry>$a = $a ** $b</entry>
        <entry>Esponenziale</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.bitwise">
    <title>Operatori di Assegnazione Bit A Bit</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Esempio</entry>
        <entry>Equivalente</entry>
        <entry>Operazione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a &amp;= $b</entry>
        <entry>$a = $a &amp; $b</entry>
        <entry>And Bit a Bit</entry>
       </row>
       <row>
        <entry>$a |= $b</entry>
        <entry>$a = $a | $b</entry>
        <entry>Or Bit a Bit</entry>
       </row>
       <row>
        <entry>$a ^= $b</entry>
        <entry>$a = $a ^ $b</entry>
        <entry>Xor Bit a Bit</entry>
       </row>
       <row>
        <entry>$a &lt;&lt;= $b</entry>
        <entry>$a = $a &lt;&lt; $b</entry>
        <entry>Shift a Sinistra</entry>
       </row>
       <row>
        <entry>$a &gt;&gt;= $b</entry>
        <entry>$a = $a &gt;&gt; $b</entry>
        <entry>Shift a Destra</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.other">
    <title>Altri Operatori di Assegnamento</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Esempio</entry>
        <entry>Equivalente</entry>
        <entry>Operazione</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a .= $b</entry>
        <entry>$a = $a . $b</entry>
        <entry>Concatenazione di stringhe</entry>
       </row>
       <row>
        <entry>$a ??= $b</entry>
        <entry>$a = $a ?? $b</entry>
        <entry>Null Coalesce</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 role="seealso" xml:id="language.operators.assignment.see-also">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.operators.arithmetic">operatori aritmetici</link></member>
      <member><link linkend="language.operators.bitwise">operatori bit a bit</link></member>
      <member><link linkend="language.operators.comparison.coalesce">operatori null coalescing</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Operatori sui bit</title>
   <simpara>
    Gli operatori sui bit permettono la valutazione e manipolazione di specifici
    bit in un valore intero.
   </simpara>
   <table>
    <title>Operatori sui bit</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>And</entry>
       <entry>Vengono accesi i bit che sono accesi sia in <varname>$a</varname> che in <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Or (inclusive or)</entry>
       <entry>Vengono accesi i bit che sono accesi o in <varname>$a</varname> oppure in <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Xor (exclusive or)</entry>
       <entry>
 Vengono accesi i bit che sono accesi in <varname>$a</varname> o in <varname>$b</varname>, ma non quelli accesi in entrambe le variabili.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Not</entry>
       <entry>
 Vengono accesi i bit che sono spenti in <varname>$a</varname>, e viceversa
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Shift left</entry>
       <entry>
 Sposta verso sinistra i bit di <varname>$a</varname> per <varname>$b</varname> volte (ogni passo significa
 "moltiplica per due")
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Shift right</entry>
       <entry>
 Sposta verso destra i bit di <varname>$a</varname> per <varname>$b</varname> volte (ogni passo significa
 "dividi per due")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Lo spostamento di bit in PHP è aritmetico.
    I bit spostati al di fuori delle estremità sono scartati.
    Gli spostamenti a sinistra inseriscono zeri a destra mentre il bit
    di segno è scartato sulla sinistra, quindi il segno di un operando
    non è conservato.
    Gli spostamenti a destra copiano il bit di segno sulla sinistra,
    quindi il segno di un operando è conservato.
   </para>
   <para>
    Utilizzare le parentesi per assicurare la
    <link linkend="language.operators.precedence">precedenza</link> desiderata.
    Per esempio, <literal>$a &amp; $b == true</literal> valuta
    l'equivalenza e poi l'operatore and; mentre
    <literal>($a &amp; $b) == true</literal> valuta l'operatore and e
    poi l'equivalenza.
   </para>
   <para>
    Se entrambi gli operandi per il operatori <literal>&amp;</literal>, <literal>|</literal>
    e <literal>^</literal> sono stringhe, allora l'operazione verrà
    eseguita sui valori ASCII dei caratteri che compongono le stringhe e
    il risultato sarà una stringa. In tutti gli altri casi, entrambi gli operandi saranno
    <link linkend="language.types.integer.casting">convertiti in interi</link>
    e il risultato sarà un intero.
   </para>
   <para>
    Se l'operando per l'operatore <literal>~</literal> è una stringa,
    l'operazione verrà eseguita sui valori ASCII dei caratteri che compongono
    la stringa e il risultato sarà una stringa, altrimenti l'operando e il
    risultato saranno trattati come interi.
   </para>
   <para>
    Sia gli operandi che il risultato per gli operatori <literal>&lt;&lt;</literal>
    e <literal>&gt;&gt;</literal> sono sempre trattati come interi.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
L'opzione ini error_reporting di PHP usa valori imappati sui bit,
fornendo quindi una dimostrazione reale dello spegnimento 
dei bit. Per mostrare tutti gli errori, eccettuati gli avvisi,
le istruzioni del file php.ini dicono di usare:
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Si prende il valore di E_ALL:
<computeroutput>00000000000000000111011111111111</computeroutput>
Quindi quello di E_NOTICE...
<computeroutput>00000000000000000000000000001000</computeroutput>
... e lo si inverte con <literal>~</literal>:
<computeroutput>11111111111111111111111111110111</computeroutput>
infine, si usa AND (&amp;) pre trovare i bit che sono accesi
in entrambi i valori:
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Un altro metodo per ottenere questo risultato è usare XOR (<literal>^</literal>)
per trovare i bit che sono accesi solo in uno dei due operandi:
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting può essere usata anche per dimostrare come accendere i bit.
Il modo per mostrare solo gli errori e gli errori recuperabili è:
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Questo processo combina E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
e
<computeroutput>00000000000000000001000000000000</computeroutput>
usando l'operatore OR (<literal>|</literal>)
per recuperare i bit accesi in entrambi i valori:
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>Operazioni AND, OR e XOR su interi</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Ignorare la sezione iniziale,
 * server solo a formattare per rendere più leggibile il risultato.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 risultato     valore     op test
 ---------     ---------  -- ---------
EOH;


/*
 * Ecco gli esempi.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitwise AND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitwise Inclusive OR \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitwise Exclusive OR (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 risultato     valore     op test
 ---------     ---------  -- ---------
 Bitwise AND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitwise Inclusive OR
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitwise Exclusive OR (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>Operazioni XOR su stringhe</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Ritorna '5'

echo "12" ^ "9"; // Ritorna il carattere Backspace (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Ritorna i valori ascii #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Ritorna 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Ritorna 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Spostamento di bit su interi</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Ecco gli esempi.
 */

echo "\n--- SPOSTAMENTO A DESTRA SU INTERI POSITIVI ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copia del bit di segno inserito a sinistra');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'i bit escono dal lato destro');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'come sopra; non c'è spostamento oltre lo 0');


echo "\n--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copia del bit di segno inserito a sinistra');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'i bit escono dal lato destro');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'come sopra; non c'è spostamento oltre il -1');


echo "\n--- SPOSTAMENTO A SINISTRA SU INTERI POSITIVI ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeri inseriti a destra');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'i bit di segno sono spostati');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'i bit escono dal lato sinistro');


echo "\n--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeri inseriti a destra');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'i bit escono dal lato sinistro, incluso il bit di segno');


/*
 * Ignorare questa sezione finale,
 * server solo a formattare per rendere più leggibile il risultato.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Espressione: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Decimale:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binario:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " NOTA: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- SPOSTAMENTO A DESTRA SU INTERI POSITIVI ---
Espressione: 2 = 4 >> 1
 Decimale:
  val=4
  res=2
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTA: copia del bit di segno inserito a sinistra

Espressione: 1 = 4 >> 2
 Decimale:
  val=4
  res=1
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Espressione: 0 = 4 >> 3
 Decimale:
  val=4
  res=0
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: i bit escono dal lato destro

Espressione: 0 = 4 >> 4
 Decimale:
  val=4
  res=0
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: come sopra; non c'è spostamento oltre lo 0


--- SPOSTAMENTO A DESTRA SU INTERI NEGATIVI ---
Espressione: -2 = -4 >> 1
 Decimale:
  val=-4
  res=-2
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTA: copia del bit di segno inserito a sinistra

Espressione: -1 = -4 >> 2
 Decimale:
  val=-4
  res=-1
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTA: i bit escono dal lato destro

Espressione: -1 = -4 >> 3
 Decimale:
  val=-4
  res=-1
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTA: come sopra; non c'è spostamento oltre il -1


--- SPOSTAMENTO A SINISTRA SU INTERI POSITIVI ---
Espressione: 8 = 4 << 1
 Decimale:
  val=4
  res=8
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTA: zeri inseriti a destra

Espressione: 1073741824 = 4 << 28
 Decimale:
  val=4
  res=1073741824
 Binario:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Espressione: -2147483648 = 4 << 29
 Decimale:
  val=4
  res=-2147483648
 Binario:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTA:i bit di segno sono spostati

Espressione: 0 = 4 << 30
 Decimale:
  val=4
  res=0
 Binario:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro


--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---
Espressione: -8 = -4 << 1
 Decimale:
  val=-4
  res=-8
 Binario:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTA: zeri inseriti a destra

Espressione: -2147483648 = -4 << 29
 Decimale:
  val=-4
  res=-2147483648
 Binario:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Espressione: 0 = -4 << 30
 Decimale:
  val=-4
  res=0
 Binario:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro, incluso il bit di segno
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- SPOSTAMENTO A DESTRA SU INTERI POSITIVI ---
Espressione: 2 = 4 >> 1
 Decimale:
  val=4
  res=2
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTA: copia del bit di segno inserito a sinistra

Espressione: 1 = 4 >> 2
 Decimale:
  val=4
  res=1
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Espressione: 0 = 4 >> 3
 Decimale:
  val=4
  res=0
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit escono dal lato destro

Espressione: 0 = 4 >> 4
 Decimale:
  val=4
  res=0
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: come sopra; non c'è spostamento oltre lo 0


--- SPOSTAMENTO A DESTRA SU INTERI NEGATIVI ---
Espressione: -2 = -4 >> 1
 Decimale:
  val=-4
  res=-2
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTA: copia del bit di segno inserito a sinistra

Espressione: -1 = -4 >> 2
 Decimale:
  val=-4
  res=-1
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTA: i bit escono dal lato destro

Espressione: -1 = -4 >> 3
 Decimale:
  val=-4
  res=-1
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTA: come sopra; non c'è spostamento oltre il -1


--- SPOSTAMENTO A SINISTRA SU INTERI POSITIVI ---
Espressione: 8 = 4 << 1
 Decimale:
  val=4
  res=8
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTA: zeri inseriti a destra

Espressione: 4611686018427387904 = 4 << 60
 Decimale:
  val=4
  res=4611686018427387904
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Espressione: -9223372036854775808 = 4 << 61
 Decimale:
  val=4
  res=-9223372036854775808
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit di segno sono spostati

Espressione: 0 = 4 << 62
 Decimale:
  val=4
  res=0
 Binario:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro


--- SPOSTAMENTO A SINISTRA SU INTERI NEGATIVI ---
Espressione: -8 = -4 << 1
 Decimale:
  val=-4
  res=-8
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTA: zeri inseriti a destra

Espressione: -9223372036854775808 = -4 << 61
 Decimale:
  val=-4
  res=-9223372036854775808
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Espressione: 0 = -4 << 62
 Decimale:
  val=-4
  res=0
 Binario:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTA: i bit escono dal lato sinistro, incluso il bit di segno
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     Utilizzare le funzioni dell'estensione <link linkend="book.gmp">gmp</link> per
     manipolazioni bit a bit su numeri che vanno oltre il valore di <literal>PHP_INT_MAX</literal>.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
<!-- <link linkend="language.oop5.basic.class.class">::class</link> -->
      <member><function>pack</function></member>
      <member><function>unpack</function></member>
      <member><function>gmp_and</function></member>
      <member><function>gmp_or</function></member>
      <member><function>gmp_xor</function></member>
      <member><function>gmp_testbit</function></member>
      <member><function>gmp_clrbit</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Operatori di confronto</title>
   <simpara>
    Gli operatori di confronto, come suggerisce il loro nome, permettono di confrontare
    due valori. Può essere interessante vedere la
    <link linkend="types.comparisons">tabella di raffronto dei tipi</link>,
    dato che mostra esempi di vari confronti tra i tipi di variabili.
   </simpara>
   <table>
    <title>Operatori di confronto</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Uguale</entry>
       <entry>&true; se <varname>$a</varname> è uguale a <varname>$b</varname> dopo la manipolazione dei tipi.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identico</entry>
       <entry>
        &true; se <varname>$a</varname> è uguale a <varname>$b</varname>, ed sono dello stesso
        tipo.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Diversi</entry>
       <entry>&true; se <varname>$a</varname> è diverso da <varname>$b</varname> dopo la manipolazione dei tipi.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Diversi</entry>
       <entry>&true; se <varname>$a</varname> è diverso da <varname>$b</varname> dopo la manipolazione dei tipi.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Non identici</entry>
       <entry>
        &true; se <varname>$a</varname> è diverso da <varname>$b</varname>, o se non sono dello stesso
        tipo.
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Minore</entry>
       <entry>&true; se <varname>$a</varname> è strettamente minore di <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Maggiore</entry>
       <entry>&true; se <varname>$a</varname> è strettamente maggiore di <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Minore o uguale</entry>
       <entry>&true; se <varname>$a</varname> è minore o uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Maggiore o uguale</entry>
       <entry>&true; se <varname>$a</varname> è maggiore o uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;=&gt; $b</entry>
       <entry>Spaceship</entry>
       <entry>
        Un <type>int</type> minore di, uguale a, o maggiore di zero quando
        <varname>$a</varname> è minore di, uguale a, o maggiore di
        <varname>$b</varname>.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Se entrambi gli operandi sono
    <link linkend="language.types.numeric-strings">stringhe numeriche</link>
    o un operando è un numero e l'altro è una
    <link linkend="language.types.numeric-strings">stringa numerica</link>,
    quindi il confronto viene eseguito numericamente.
    Queste regole si applicano anche all'
    istruzione <link linkend="control-structures.switch">switch</link>.
    La conversione del tipo non ha luogo quando il confronto è
    <literal>===</literal> o <literal>!==</literal> poiché implica
    il confronto del tipo e del valore.
   </para>
   
   <warning>
    <para>
     Prima di PHP 8.0.0, se una <type>stringa</type> veniva confrontata con un numero
     o una stringa numerica, la <type>stringa</type> veniva convertita in un
     numero prima di eseguire il confronto. Questo può portare a risultati
     sorprendenti, come si può vedere con il seguente esempio:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a");
var_dump("1" == "01");
var_dump("10" == "1e1");
var_dump(100 == "1e2");

switch ("a") {
case 0:
    echo "0";
    break;
case "a":
    echo "a";
    break;
}
?>
]]>
      </programlisting>
      &example.outputs.7;
      <screen>
<![CDATA[
bool(true)
bool(true)
bool(true)
bool(true)
0
]]>
      </screen>
      &example.outputs.8;
      <screen>
<![CDATA[
bool(false)
bool(true)
bool(true)
bool(true)
a
]]>
      </screen>      
     </informalexample>
    </para>
   </warning>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php  
// Interi
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
 
// Numeri float
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// Stringhe
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
 
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1
 
// Array
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1
 
// Oggetti
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 0
 
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "c"]; 
echo $a <=> $b; // -1
 
$a = (object) ["a" => "c"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 1
 
// non vengono confrontati solo i valori; le chiavi devono corrispondere
$a = (object) ["a" => "b"]; 
$b = (object) ["b" => "b"]; 
echo $a <=> $b; // 1

?>
]]>
      
     </programlisting>
    </informalexample>
   </para>

   <para>
    Se i tipi di operandi utilizzati differiscono, il confronto viene svolto
    nell'ordine indicato della seguente tabella.
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Confronti con differenti tipi</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Tipo dell'operando 1</entry>
       <entry>Tipo dell'operando 2</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> oppure <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>Si converte &null; in "", confronto numerico o lessicale</entry>
      </row>
      <row>
       <entry><type>bool</type> oppure <type>null</type></entry>
       <entry>qualsiasi</entry>
       <entry>Converte entrambi i lati in <type>bool</type>, &false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>Le classi predefinite possono avere la propria funzione di confronto, classi differenti
        non sono confrontabili, per la stessa classe vedere <link
        linkend="language.oop5.object-comparison">Confronto di Oggetti</link>.
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type>, <type>int</type> oppure <type>float</type></entry>
       <entry><type>string</type>, <type>resource</type>, <type>int</type> oppure <type>float</type></entry>
       <entry>Stringhe e risorse sono converti in numeri, confronto matematico</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>La matrice con meno membri è più piccola, se la chiave dell'operando 1 non si
        trova nell'operando 2 allora le matrici non si possono confrontare, in altri casi
        il confronto avviene valore per valore (vedere l'esempio seguente)</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>qualsiasi</entry>
       <entry><type>object</type> è sempre più grande</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>qualsiasi</entry>
       <entry><type>array</type> è sempre più grande</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
   <para>
    <example>
     <title>Confronto Boolean/null</title>
     <programlisting role="php">
<![CDATA[
<?php
// Bool e null sono confrontati sempre come bool
var_dump(1 == TRUE);  // TRUE - uguale a (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - uguale a (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - uguale a (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - uguale a (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 è FALSE < TRUE
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    <example>
     <title>Trascrizione del confronto standard tra matrici</title>
     <programlisting role="php">
<![CDATA[
<?php
// Gli array vengono confrontati in questo modo con gli operatori di confronto standard e con l'operatore spaceship.
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return 1;
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <warning>
    <title>Confronto di numeri in virgola mobile</title>

    <para>
     A causa del modo in cui i <type>float</type> sono rappresentati internamente al PHP, non
     si dovrebbe esaminare l'eguaglianza di due <type>float</type>.
    </para>

    <para>
     Per maggior informazioni, fare riferimento alla documentazione del tipo <type>float</type>.
    </para>
   </warning>

   <note>
    <simpara>
     Tenere presente che la manipolazione dei tipi di PHP non è sempre ovvia quando si confrontano valori di tipi diversi,
     in particolare confrontando &integer; con &boolean; o &integer; con &string;. È quindi generalmente
     consigliabile utilizzare confronti <literal>===</literal> e <literal>!==</literal> piuttosto che
     <literal>==</literal> e <literal>!=</literal> nella maggior parte dei casi.
    </simpara>
   </note>

   <sect2 xml:id="language.operators.comparison.incomparable">
    <title>Incomparable Values</title>
    <simpara>
     Mentre il confronto di identità (<literal>===</literal> e <literal>!==</literal>)
     può essere applicato a valori arbitrari, gli altri operatori di confronto dovrebbero essere applicati
     solo a valori comparabili. Il risultato del confronto di valori incomparabili non
     è definito e non dovrebbe essere considerato attendibile.
    </simpara>
   </sect2>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>strcasecmp</function></member>
      <member><function>strcmp</function></member>
      <member><link linkend="language.operators.array">Operatori degli array</link></member>
      <member><link linkend="language.types">Tipi</link></member>
     </simplelist>
    </para>
   </sect2>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Operatore ternario</title>
    <para>
     Un altro operatore condizionale è l'operatore ternario "?:".
     <example>
      <title>Assegnazione di un valore di default</title>
      <programlisting role="php">
<![CDATA[
<?php
// Esempio di utilizzo dell'operatore ternario
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// La riga precedente è simile a
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
?>
]]>
      </programlisting>
     </example>
     L'espressione <literal>(espressione1) ? (espressione2) : (espressione3)</literal>
     vale <replaceable>espressione2</replaceable> se
     <replaceable>espressione1</replaceable> è &true;, e
     <replaceable>espressione3</replaceable> se
     <replaceable>espressione1</replaceable> è &false;.
    </para>
    <para>
     È possibile tralasciare l'elemento centrale dell'operatore ternario.
     L'espressione <literal>espressione1 ?: espressione3</literal> viene valutata
     al risultato di <replaceable>espressione1</replaceable> se <replaceable>espressione1</replaceable>
     viene valutata &true;, e <replaceable>espressione3</replaceable> in caso contrario.
     <replaceable>espressione1</replaceable> viene valutata solo una volta.
    </para>
    <note>
     <simpara>
      Si noti che l'operatore ternario è un'espressione, e non viene valutato
      come variabile, ma come risultato di un'espressione. Questo
      è importante da sapere nel caso si desideri restituire una variabile per riferimento.
      La riga <literal>return $var == 42 ? $a : $b;</literal> in una funzione
      che restituisce per riferimento non funzionerà e genererà un
      avvertimento.
     </simpara>
    </note>
    <note>
     <para>
      Si raccomanda di evitare di "sovrapporre" espressioni ternarie.
      Il comportamento di PHP quando si utilizza più di un operatore ternario senza parentesi all'interno di una singola
      espressione non è ovvio rispetto ad altri linguaggi.
      In effetti, prima di PHP 8.0.0, le espressioni ternarie venivano valutate associative a sinistra,
      anziché associative a destra come la maggior parte degli altri linguaggi di programmazione.
      Fare affidamento sull'associatività di sinistra è deprecato a partire da PHP 7.4.0.
      A partire da PHP 8.0.0, l'operatore ternario non è associativo.
      <example>
       <title>Comportamento ternario non ovvio</title>
       <programlisting role="php">
<![CDATA[
<?php
// a prima vista, questa istruzione dovrebbe restituire 'true'
echo (true ? 'true' : false ? 't' : 'f');

// invece, l'output effettivo di quanto sopra è 't' prima di PHP 8.0.0
// questo perché le espressioni ternarie sono associative a sinistra

// quanti segue è una versione più chiara dello stesso codice
echo ((true ? 'true' : false) ? 't' : 'f');

// qui, si può notare che la prima espressione viene valutata come "true", che
// a sua volta diventa (bool)true, e quindi restituisce il ramo true della
// seconda espressione ternaria.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
    <note>
     <para>
      Il concatenamento di ternari brevi (<literal>?:</literal>), tuttavia, è stabile e si comporta in modo ragionevole.
      Verrà valutato al primo argomento valutato come valore non falso. Si noti che i valori non
      definiti genereranno comunque un avviso.
      <example>
       <title>Concatenamento ternario breve</title>
       <programlisting role="php">
<![CDATA[
<?php
echo 0 ?: 1 ?: 2 ?: 3, PHP_EOL; //1
echo 0 ?: 0 ?: 2 ?: 3, PHP_EOL; //2
echo 0 ?: 0 ?: 0 ?: 3, PHP_EOL; //3
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>
   
   <sect2 xml:id="language.operators.comparison.coalesce">
    <title>L'operatore Null Coalescing</title>
    <para>
     Un altro utile operatore abbreviato è il "??" (o null coalescing).
     <example>
      <title>Assegnazione di un valore predefinito</title>
      <programlisting role="php">
<![CDATA[
<?php
// Esempio di utilizzo per: Operatore Null Coalesce
$action = $_POST['action'] ?? 'default';

// Quello sopra è identico a questa istruzione if/else
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';
}
?>
]]>
      </programlisting>
     </example>
     L'espressione <literal>(expr1) ?? (expr2)</literal> viene valutata a
     <replaceable>expr2</replaceable> se <replaceable>expr1</replaceable> è
     &null;, e <replaceable>expr1</replaceable> in caso contrario.
    </para>
    <para>
     In particolare, questo operatore non emette un avviso o un avvertimento se il valore del lato
     sinistro non esiste, proprio come <function>isset</function>. Questo è particolarmente
     utile sulle chiavi degli array.
    </para>
    <note>
     <simpara>
      Si prega di notare che l'operatore null coalescing è un'espressione, e che essa
      non viene valutata ad una variabile, ma al risultato di un'espressione. Questo
      è importante da sapere nel caso in cui si volesse restituire una variabile per riferimento.
      L'istruzione <literal>return $foo ?? $bar;</literal> in una funzione
      che restituisce un riferimento quindi non funzionerà e verrà emesso un
      avviso.
     </simpara>
    </note>
    <note>
     <para>
      L'operatore null coalescing ha una precedenza bassa. Ciò significa che se lo si mescola
      con altri operatori (come la concatenazione di stringhe o gli operatori aritmetici)
      saranno probabilmente necessarie parentesi.
     </para>
     <programlisting role="php">
<![CDATA[
<?php
// Genera un avviso che $name non è definito.
print 'Mr. ' . $name ?? 'Anonymous';

// Stampa "Mr. Anonymous"
print 'Mr. ' . ($name ?? 'Anonymous');
?>
]]>
     </programlisting>
    </note>
    <note>
     <para>
      Si prega di notare che l'operatore null coalescing permette semplici nidificazioni:
      <example>
       <title>Operatore null coalescing nidificato</title>
       <programlisting role="php">
<![CDATA[
<?php

$foo = null;
$bar = null;
$baz = 1;
$qux = 2;

echo $foo ?? $bar ?? $baz ?? $qux; // stampa 1

?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2> 
  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Operatori di controllo errori</title>
   <simpara>
    PHP supporta un operatore di controllo dell'errore: il carattere at (<literal>@</literal>).
    Quando viene anteposto ad una espressione in PHP, qualunque messaggio di errore che possa
    essere generato da quella espressione sarà soppresso.
   </simpara>
   <para>
    Se è stata assegnata una funzione personalizzata di gestione degli errori con
    <function>set_error_handler</function> questa verrà comunque chiamata, anche se
    la diagnostica è stata soppressa.
   </para>

   <warning>
    <para>
     Prima di PHP 8.0.0, la funzione <function>error_reporting</function> chiamata all'interno del gestore di errori personalizzato
     restituiva sempre <literal>0</literal> se l'errore veniva soppresso dall'operatore <literal>@</literal>.
     A partire da PHP 8.0.0, restituisce il valore <literal>E_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR | E_RECOVERABLE_ERROR | E_PARSE</letterale>.
    </para>
   </warning>
   
   <simpara>
    Qualsiasi messaggio di errore generato dall'espressione è disponibile nell'elemento
    <literal>"message"</literal> dell'array restituito da <function>error_get_last</function>.
    Il risultato di quella funzione cambierà ad ogni errore, quindi deve essere controllato in anticipo.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Errore di file intenzionale */
$my_file = @file ('file_inesistente') or
    die ("Apertura del file fallita: l'errore è stato '" . error_get_last()['message'] . "'");

// questo funziona per qualsiasi espressione, non solo funzioni:
$value = @$cache[$key];
// non verrà generata una notifica se l'indice $key non esiste.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     L'operatore <literal>@</literal> funziona solo sulle 
     <link linkend="language.expressions">espressioni</link>.
     Una semplice regola è: se si può ottenere il valore di qualcosa,
     allora si può anteporre ad esso l'operatore <literal>@</literal>.
     Per esempio, si può anteporre a variabili, chiamate di funzioni,
     determinate chiamate di costrutti di linguaggio (per esempio <function>include</function>),
     e così via.
     Non si può anteporre a definizioni di funzioni o classi,
     o strutture condizionali come <literal>if</literal> e
     <literal>foreach</literal>, e così via.
    </simpara>
   </note>
   <warning>
    <para>
     Prima di PHP 8.0.0, era possibile per l'operatore <literal>@</literal>
     disabilitare gli errori critici che interrompevano l'esecuzione dello script.
     Ad esempio, anteporre <literal>@</literal> ad una chiamata di una funzione
     che non esiste, non essendo disponibile o digitata in modo errato, causerebbe
     il termine dello script senza alcuna indicazione sul perché.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>error_reporting</function></member>
      <member><link linkend="ref.errorfunc">Funzioni di Gestione degli Errori e Logging</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Operatori di esecuzione</title>
   <para>
    PHP supporta un operatore di esecuzione: backticks (``). Si noti che
    non sono apostrofi o apici! PHP cercherà di eseguire
    il contenuto dei backticks come comando di shell; sarà restituito l'output
    (ovvero, non sarà semplicemente inviato all'output, ma potrà
    essere assegnato ad una variabile). L'uso dell'operatore backtick è identico
    alla funzione <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     L'operatore backtick è disabilitato quando
     è disabilitata <function>shell_exec</function>.
    </para>
   </note>
   <note>
    <para>
     Diversamente da altri linguaggi, i backtick non hanno un significato speciale
     all'interno di stringhe delimitate da doppi apici.
    </para>
   </note>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.exec">Funzioni per l'Esecuzione di Programmi</link></member>
      <member><function>popen</function></member>
      <member><function>proc_open</function></member>
      <member><link linkend="features.commandline">Utilizzo di PHP da linea di comando</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Operatori di incremento/decremento</title>
   <para>
    PHP supporta lo stile C degli operatori di pre- e post-incremento
    e decremento.
   </para>
   <note>
    <simpara>
     Gli operatori di incremento e decremento agiscono solo su numeri e stringhe.
     Array, oggetti, booleani e risorse non ne sono interessati.
     Anche decrementare il valore &null; non ha effetti, ma incrementarlo
     darà come risultato <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Operatori di incremento/decremento</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Effetto</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pre-incremento</entry>
       <entry>Incrementa <varname>$a</varname> di una unità, quindi restituisce <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-incremento</entry>
       <entry>Restituisce <varname>$a</varname>, quindi incrementa <varname>$a</varname> di una unità.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pre-decremento</entry>
       <entry>Decrementa <varname>$a</varname> di una unità, quindi restituisce <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-decremento</entry>
       <entry>Restituisce <varname>$a</varname>, quindi decrementa <varname>$a</varname> di una unità.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Un semplice script di esempio:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Dovrebbe essere 5: " . $a++ . "<br />\n";
echo "Dovrebbe essere 6: " . $a . "<br />\n";

echo "<h3>Pre-incremento</h3>";
$a = 5;
echo "Dovrebbe essere 6: " . ++$a . "<br />\n";
echo "Dovrebbe essere 6: " . $a . "<br />\n";

echo "<h3>Post-decremento</h3>";
$a = 5;
echo "Dovrebbe essere 5: " . $a-- . "<br />\n";
echo "Dovrebbe essere 4: " . $a . "<br />\n";

echo "<h3>Pre-decremento</h3>";
$a = 5;
echo "Dovrebbe essere 4: " . --$a . "<br />\n";
echo "Dovrebbe essere 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Il PHP segue le convenzioni di Perl e non del C quando tratta le operazioni matematiche
    sui caratteri. Ad esempio, in PHP e Perl
    <literal>$a = 'Z'; $a++;</literal> modifica <literal>$a</literal> in <literal>'AA'</literal>, mentre in C
    <literal>a = 'Z'; a++;</literal> modifica <literal>a</literal> in <literal>'['</literal>
    (il valore ASCII di <literal>'Z'</literal> è 90, quello di <literal>'['</literal> è 91).
    Si noti che le variabili carattere possono essere incrementate ma non decrementate e
    anche in questo caso solo i caratteri e i numeri ASCII (a-z, A-Z e 0-9) sono supportati.
    Incrementare/decrementare altre variabili di carattere non ha effetto, la
    stringa originale non viene modificata.
    <example>
     <title>Operazioni aritmetiche su variabili carattere</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '== Alphabets ==' . PHP_EOL;
$s = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// I caratteri numerici si comportano diversamente
echo '== Digits ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
== Characters ==
X
Y
Z
AA
AB
AC
== Digits ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
     </screen>
    </example>
   </para>
   <para>
    Incrementare o decrementare valori booleani non ha effetto.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>Operatori logici</title>

   <table>
    <title>Operatori logici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>And</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> sono entrambe &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Or</entry>
       <entry>&true; se <varname>$a</varname> o <varname>$b</varname> è &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Xor</entry>
       <entry>&true; se <varname>$a</varname> o <varname>$b</varname> è &true;, ma non entrambe.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Not</entry>
       <entry>&true; se <varname>$a</varname> non è &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>And</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> sono entrambe &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Or</entry>
       <entry>&true; se <varname>$a</varname> o <varname>$b</varname> è &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    La ragione per le due differenti variazioni degli operatori "and" e "or"
    è che operano con differenti precedenze. (Vedere
    <link linkend="language.operators.precedence">Precedenza degli
    operatori</link>.)
   </simpara>
   <example>
    <title>Dimostrazione degli operatori logici</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() non viene mai chiamata in quanto gli operatori sono in corto-circuito

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" ha una precedenza maggiore rispetto a "or"

// Il risultato dell'espressione (false || true) è assegnato a $e
// Funziona come: ($e = (false || true))
$e = false || true;

// La costante false è assegnata a $f prima che l'operazione "or" avvenga
// Funziona come: (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" ha una precesenza maggiore rispetto a "and"

// Il risultato dell'espressione (true && false) è assegnato a $g
// Funziona come: ($g = (true && false))
$g = true && false;

// La costante true è assegnata a $h prima che l'operazione "and" avvenga
// Funziona come: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Operatori di stringa</title>
   <simpara>
    Ci sono due operatori di <type>stringa</type>. Il primo è l'operatore di
    concatenazione ('.'), che restituisce la concatenazione dei suoi argomenti di destra e
    di sinistra. Il secondo è l'operatore di
    assegnazione concatenato ('.='), che accoda l'argomento sul lato destro all'argomento sul lato
    sinistro. Vedere <link
    linkend="language.operators.assignment">Operatori di
    assegnazione</link> per maggiori informazioni.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Ciao ";
$b = $a . "Mondo!"; // ora $b contiene "Ciao Mondo!"

$a = "Ciao ";
$a .= "Mondo!";     // ora $a contiene "Ciao Mondo!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.string">Il tipo Stringa</link></member>
      <member><link linkend="ref.strings">Funzioni per le stringhe</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Operatori per matrici</title>
   <table>
    <title>Operatori per matrici</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Esempio</entry>
       <entry>Nome</entry>
       <entry>Risultato</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Unione</entry>
       <entry>Unione di <varname>$a</varname> e <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Uguaglianza</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> hanno le stesse coppie di chiavi/valori.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identità</entry>
       <entry>&true; se <varname>$a</varname> e <varname>$b</varname> hanno le stesse coppie di chiavi/valori nel
        medesimo ordine e dl medesimo tipo.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Disuguaglianza</entry>
       <entry>&true; se <varname>$a</varname> non è uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Disuguaglianza</entry>
       <entry>&true; se <varname>$a</varname> non è uguale a <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Non-identità</entry>
       <entry>&true; se <varname>$a</varname> non è identico a <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    L'operatore <literal>+</literal> restituisce la matrice di destra aggiunta
    a quella di sinistra; per le chiavi esistenti in entrambe le matrici, vengono usati gli elementi
    della matrice di sinistra, e gli elementi duplicati in quella
    di destra sono ignorati.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Unione di $a e $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Unione di $b e $a
echo "Union of \$b and \$a: \n";
var_dump($c);

$a += $b; // Unione di $a += $b è $a e $b
echo "Union of \$a += \$b: \n";
var_dump($a);
?>
]]>
     </programlisting>
    </informalexample>
    Una volta eseguito, lo script visualizzerà:
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
Union of $a += $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    Gli elementi di una matrice sono uguali nel confronto se hanno le
    stesse chiavi e gli stessi valori.
   </para>
   <para>
    <example>
     <title>Confrontare le matrici</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.array">Il tipo Array</link></member>
      <member><link linkend="ref.array">Funzioni per gli array</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.type">
   <title>Operatori di tipi</title>
   <para>
    <literal>instanceof</literal> è utilizzato per determinare se una variabile PHP
    è un oggetto istanza di una certa
    <link linkend="language.oop5.basic.class">classe</link>:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con le classi</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> può essere usato anche per determinare se una variabile
    è un oggetto istanziato da una classe che eredita da una classe parente:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con le classi ereditate</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Al fine di controllare se un oggetto <emphasis>non</emphasis> è un instanceof di una classe, si
    può usare l'<link linkend="language.operators.logical">operatore logico <literal>not</literal>
    </link>.
    <example>
     <title>Utilizzo di <literal>instanceof</literal> per controllare se un oggetto <emphasis>non</emphasis> è
     un'instanceof di una classe</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Infine, <literal>instanceof</literal> può essere usato anche per deretmnare se
    una variable è un oggetto istanziato da una classe che implementa una
    <link linkend="language.oop5.interfaces">interfaccia</link>:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con interfacce</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Anche se <literal>instanceof</literal> è normalmente usata con un nome di classe letterale,
    può essere usata con un altro oggetto o con una variabile stringa:
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con altre variabili</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b è un oggetto di classe MyClass
var_dump($a instanceof $c); // $c è la stringa 'MyClass'
var_dump($a instanceof $d); // $d è la stringa 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    instanceof non genera errori se la variabile che viene controllata non è
    un oggetto, ma ritorna semplicemente &false;. Le costanti non erano comunque ammesse
    prima di PHP 7.3.0.
    <example>
     <title>Utilizzo di <literal>instanceof</literal> per controllare altre variabili</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a è un integer
var_dump($b instanceof stdClass); // $b è NULL
var_dump($c instanceof stdClass); // $c è una risorsa
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
     </screen>
    </example>
   </para>
   <para>
    A partire da PHP 7.3.0, le costanti sono permesse sul lato sinistro
    dell'operatore <literal>instanceof</literal>.
    <example>
     <title>Utilizzo di <literal>instanceof</literal> per testare le costanti</title>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    A partire da PHP 8.0.0, <literal>instanceof</literal> ora può essere utilizzato con espressioni arbitrarie.
    L'espressione deve essere racchiusa tra parentesi e produrre una <type>string</type>.
    <!-- RFC: https://wiki.php.net/rfc/variable_syntax_tweaks -->
    <example>
     <title>Utilizzo di <literal>instanceof</literal> con un'espressione arbitraria</title>
     <programlisting role="php">
      <![CDATA[
<?php

class ClassA extends \stdClass {}
class ClassB extends \stdClass {}
class ClassC extends ClassB {}
class ClassD extends ClassA {}

function getSomeClass(): string
{
    return ClassA::class;
}

var_dump(new ClassA instanceof ('std' . 'Class'));
var_dump(new ClassB instanceof ('Class' . 'B'));
var_dump(new ClassC instanceof ('Class' . 'A'));
var_dump(new ClassD instanceof (getSomeClass()));
?>
]]>
     </programlisting>
     &example.outputs.8;
     <screen>
      <![CDATA[
bool(true)
bool(true)
bool(false)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    L'operatore <literal>instanceof</literal> ha una variante funzionale
    con la funzione <function>is_a</function>.
   </simpara>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>get_class</function></member>
      <member><function>is_a</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
