<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 2f1812217524ac60414745bad05cbbee00262b3b Maintainer: maiobarbero Status: ready -->
<sect1 xml:id="language.operators.functional">
 <title>Operatori Funzionali</title>
 <titleabbrev>Operatori Funzionali</titleabbrev>
 <para>
  PHP 8.5, e versioni successive, supportano un operatore che lavora direttamente sui callables.
  L'operatore <literal>|&gt;</literal>, o “pipe”, accetta un callable con singolo parametro a destra
  e gli passa il valore che si trova a sinistra, valutando infine il risultato del callable.
  Il callable a destra può essere un qualsiasi callable PHP valido: una <classname>Closure</classname>,
  un <link linkend="functions.first_class_callable_syntax">first-class callable</link>,
  un oggetto che implementa <link linkend="object.invoke">__invoke()</link>, ecc.
 </para>
 <para>
  Questo significa che le seguenti righe sono equivalenti.
  <example>
   <title>Uso di <literal>|&gt;</literal></title>
   <programlisting role="php">
<![CDATA[
<?php
$result = "Hello World" |> strlen(...);
echo $result, PHP_EOL;

$result = strlen("Hello World");
echo $result, PHP_EOL;
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
11
11
]]>
   </screen>
  </example>
 </para>
 <para>
  Per una singola chiamata questo non è particolarmente utile. Diventa utile quando più chiamate sono concatenate insieme.
  I seguenti frammenti di codice sono equivalenti dal punto di vista logico:
  <example>
   <title>Concatenare chiamate |&gt;</title>
   <programlisting role="php">
<![CDATA[
<?php
$result = "PHP Rocks"
    |> htmlentities(...)
    |> str_split(...)
    |> (fn($x) => array_map(strtoupper(...), $x))
    |> (fn($x) => array_filter($x, fn($v) => $v != 'O'))
;
print_r($result);

$temp = "PHP Rocks";
$temp = htmlentities($temp);
$temp = str_split($temp);
$temp = array_map(strtoupper(...), $temp);
$temp = array_filter($temp, fn($v) => $v != 'O');
$result = $temp;
print_r($result);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => P
    [1] => H
    [2] => P
    [3] =>
    [4] => R
    [6] => C
    [7] => K
    [8] => S
)
Array
(
    [0] => P
    [1] => H
    [2] => P
    [3] =>
    [4] => R
    [6] => C
    [7] => K
    [8] => S
)
]]>
   </screen>
  </example>
 </para>
 <para>
  La parte sinistra del pipe può essere qualsiasi valore o espressione. La parte destra
  può essere qualsiasi callable PHP valido che accetti un singolo parametro,
  o qualsiasi espressione che valuti a un callable di questo tipo. Le funzioni con più di
  un parametro richiesto non sono consentite e falliranno come se la funzione fosse chiamata con argomenti insufficienti.
  Le funzioni che accettano una variabile per riferimento non sono consentite. Se la parte destra
  non valuta in un callable valido, genererà un Error.
 </para>
 <note>
  <para>
   È importante notare che, per evitare ambiguità sintattiche, le <link linkend="functions.arrow">arrow functions</link>
   DEVONO essere racchiuse tra parentesi quando vengono usate con un operatore pipe, come negli esempi precedenti.
   In caso contrario, si verificherà un errore fatale.
  </para>
 </note>

 <sect2 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><classname>Closure</classname></member>
   </simplelist>
  </para>
 </sect2>
</sect1>
